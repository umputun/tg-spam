
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>webapi: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/umputun/tg-spam/app/webapi/config.go (93.3%)</option>
				
				<option value="file1">github.com/umputun/tg-spam/app/webapi/config_store_mock.go (36.7%)</option>
				
				<option value="file2">github.com/umputun/tg-spam/app/webapi/webapi.go (79.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package webapi

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        log "github.com/go-pkgz/lgr"
        "github.com/go-pkgz/rest"

        "github.com/umputun/tg-spam/app/config"
)

//go:generate moq --out config_store_mock.go --with-resets --skip-ensure . SettingsStore

// SettingsStore provides access to configuration stored in database
type SettingsStore interface {
        Load(ctx context.Context) (*config.Settings, error)
        Save(ctx context.Context, settings *config.Settings) error
        Delete(ctx context.Context) error
        LastUpdated(ctx context.Context) (time.Time, error)
        Exists(ctx context.Context) (bool, error)
}

// saveConfigHandler handles POST /config request.
// It saves the current configuration to the database.
func (s *Server) saveConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if s.SettingsStore == nil </span><span class="cov8" title="1">{
                http.Error(w, "Configuration storage not available", http.StatusInternalServerError)
                return
        }</span>

        // save current settings to database
        <span class="cov8" title="1">err := s.SettingsStore.Save(r.Context(), s.AppSettings)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[ERROR] failed to save configuration: %v", err)
                http.Error(w, fmt.Sprintf("Failed to save configuration: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if r.Header.Get("HX-Request") == "true" </span><span class="cov8" title="1">{
                // return a success message for HTMX
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration saved successfully&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov8" title="1">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration saved successfully"})</span>
}

// loadConfigHandler handles GET /config request.
// It loads configuration from the database.
func (s *Server) loadConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if s.SettingsStore == nil </span><span class="cov8" title="1">{
                http.Error(w, "Configuration storage not available", http.StatusInternalServerError)
                return
        }</span>

        // load settings from database
        <span class="cov8" title="1">settings, err := s.SettingsStore.Load(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[ERROR] failed to load configuration: %v", err)
                http.Error(w, fmt.Sprintf("Failed to load configuration: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // preserve CLI-provided credentials and transient settings
        // CLI credentials have precedence over database values if provided
        <span class="cov8" title="1">transient := s.AppSettings.Transient
        telegramToken := s.AppSettings.Telegram.Token
        openAIToken := s.AppSettings.OpenAI.Token
        webAuthHash := s.AppSettings.Server.AuthHash
        webAuthPasswd := s.AppSettings.Transient.WebAuthPasswd

        // restore transient values
        settings.Transient = transient

        // restore CLI-provided credentials if they were set
        // these override database values because CLI parameters take precedence
        if telegramToken != "" </span><span class="cov8" title="1">{
                settings.Telegram.Token = telegramToken
        }</span>
        <span class="cov8" title="1">if openAIToken != "" </span><span class="cov8" title="1">{
                settings.OpenAI.Token = openAIToken
        }</span>
        <span class="cov8" title="1">if webAuthHash != "" </span><span class="cov0" title="0">{
                settings.Server.AuthHash = webAuthHash
        }</span>
        <span class="cov8" title="1">if webAuthPasswd != "" </span><span class="cov0" title="0">{
                settings.Transient.WebAuthPasswd = webAuthPasswd
        }</span>

        // update current settings
        <span class="cov8" title="1">s.AppSettings = settings

        if r.Header.Get("HX-Request") == "true" </span><span class="cov8" title="1">{
                // return a success message for HTMX with reload
                w.Header().Set("HX-Refresh", "true") // force page reload to reflect new settings
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration loaded successfully. Refreshing page...&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov8" title="1">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration loaded successfully"})</span>
}

// updateConfigHandler handles PUT /config request.
// It updates specific configuration settings in memory and optionally saves to database.
func (s *Server) updateConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if err := r.ParseForm(); err != nil </span><span class="cov8" title="1">{
                http.Error(w, fmt.Sprintf("Failed to parse form: %v", err), http.StatusBadRequest)
                return
        }</span>

        // update settings based on form values - auth settings are never modified
        <span class="cov8" title="1">updateSettingsFromForm(s.AppSettings, r)

        // save changes to database if requested
        if r.FormValue("saveToDb") == "true" &amp;&amp; s.SettingsStore != nil </span><span class="cov8" title="1">{
                err := s.SettingsStore.Save(r.Context(), s.AppSettings)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("[ERROR] failed to save updated configuration: %v", err)
                        http.Error(w, fmt.Sprintf("Failed to save configuration: %v", err), http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov8" title="1">if r.Header.Get("HX-Request") == "true" </span><span class="cov8" title="1">{
                // return a success message for HTMX
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration updated successfully&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov8" title="1">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration updated successfully"})</span>
}

// deleteConfigHandler handles DELETE /config request.
// It deletes the saved configuration from the database.
func (s *Server) deleteConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if s.SettingsStore == nil </span><span class="cov8" title="1">{
                http.Error(w, "Configuration storage not available", http.StatusInternalServerError)
                return
        }</span>

        // delete configuration from database
        <span class="cov8" title="1">err := s.SettingsStore.Delete(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[ERROR] failed to delete configuration: %v", err)
                http.Error(w, fmt.Sprintf("Failed to delete configuration: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if r.Header.Get("HX-Request") == "true" </span><span class="cov8" title="1">{
                // return a success message for HTMX
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration deleted successfully&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov8" title="1">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration deleted successfully"})</span>
}

// updateSettingsFromForm updates settings from form values
func updateSettingsFromForm(settings *config.Settings, r *http.Request) <span class="cov8" title="1">{
        // general settings
        if val := r.FormValue("primaryGroup"); val != "" </span><span class="cov8" title="1">{
                settings.Telegram.Group = val
        }</span>
        <span class="cov8" title="1">if val := r.FormValue("adminGroup"); val != "" </span><span class="cov0" title="0">{
                settings.Admin.AdminGroup = val
        }</span>
        <span class="cov8" title="1">settings.Admin.DisableAdminSpamForward = r.FormValue("disableAdminSpamForward") == "on"
        settings.Logger.Enabled = r.FormValue("loggerEnabled") == "on"
        settings.NoSpamReply = r.FormValue("noSpamReply") == "on"

        // handle CasEnabled separately because we need to set CAS.API
        casEnabled := r.FormValue("casEnabled") == "on"
        if casEnabled &amp;&amp; settings.CAS.API == "" </span><span class="cov8" title="1">{
                settings.CAS.API = "https://api.cas.chat" // default CAS API endpoint
        }</span> else<span class="cov8" title="1"> if !casEnabled </span><span class="cov8" title="1">{
                settings.CAS.API = ""
        }</span>

        // parse super users from comma-separated string
        <span class="cov8" title="1">if superUsers := r.FormValue("superUsers"); superUsers != "" </span><span class="cov8" title="1">{
                users := strings.Split(superUsers, ",")
                settings.Admin.SuperUsers = make([]string, 0, len(users))
                for _, user := range users </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(user)
                        if trimmed != "" </span><span class="cov8" title="1">{
                                settings.Admin.SuperUsers = append(settings.Admin.SuperUsers, trimmed)
                        }</span>
                }
        }

        // meta checks
        <span class="cov8" title="1">metaEnabled := r.FormValue("metaEnabled") == "on"

        if val := r.FormValue("metaLinksLimit"); val != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.Meta.LinksLimit = limit
                }</span>
        } else<span class="cov8" title="1"> if !metaEnabled </span><span class="cov8" title="1">{
                settings.Meta.LinksLimit = -1
        }</span>

        <span class="cov8" title="1">if val := r.FormValue("metaMentionsLimit"); val != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.Meta.MentionsLimit = limit
                }</span>
        } else<span class="cov8" title="1"> if !metaEnabled </span><span class="cov8" title="1">{
                settings.Meta.MentionsLimit = -1
        }</span>

        <span class="cov8" title="1">settings.Meta.LinksOnly = r.FormValue("metaLinksOnly") == "on"
        settings.Meta.ImageOnly = r.FormValue("metaImageOnly") == "on"
        settings.Meta.VideosOnly = r.FormValue("metaVideoOnly") == "on"
        settings.Meta.AudiosOnly = r.FormValue("metaAudioOnly") == "on"
        settings.Meta.Forward = r.FormValue("metaForwarded") == "on"
        settings.Meta.Keyboard = r.FormValue("metaKeyboard") == "on"

        if val := r.FormValue("metaUsernameSymbols"); val != "" </span><span class="cov8" title="1">{
                settings.Meta.UsernameSymbols = val
        }</span> else<span class="cov8" title="1"> if !metaEnabled </span><span class="cov8" title="1">{
                settings.Meta.UsernameSymbols = ""
        }</span>

        // openAI settings
        <span class="cov8" title="1">openAIEnabled := r.FormValue("openAIEnabled") == "on"
        if !openAIEnabled </span><span class="cov8" title="1">{
                settings.OpenAI.APIBase = ""
        }</span>

        <span class="cov8" title="1">settings.OpenAI.Veto = r.FormValue("openAIVeto") == "on"

        if val := r.FormValue("openAIHistorySize"); val != "" </span><span class="cov8" title="1">{
                if size, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.OpenAI.HistorySize = size
                }</span>
        }

        <span class="cov8" title="1">if val := r.FormValue("openAIModel"); val != "" </span><span class="cov8" title="1">{
                settings.OpenAI.Model = val
        }</span>

        // lua plugins
        <span class="cov8" title="1">settings.LuaPlugins.Enabled = r.FormValue("luaPluginsEnabled") == "on"
        settings.LuaPlugins.DynamicReload = r.FormValue("luaDynamicReload") == "on"

        if val := r.FormValue("luaPluginsDir"); val != "" </span><span class="cov8" title="1">{
                settings.LuaPlugins.PluginsDir = val
        }</span>

        // get selected Lua plugins
        <span class="cov8" title="1">settings.LuaPlugins.EnabledPlugins = r.Form["luaEnabledPlugins"]

        // spam detection
        if val := r.FormValue("similarityThreshold"); val != "" </span><span class="cov8" title="1">{
                if threshold, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov8" title="1">{
                        settings.SimilarityThreshold = threshold
                }</span>
        }

        <span class="cov8" title="1">if val := r.FormValue("minMsgLen"); val != "" </span><span class="cov8" title="1">{
                if msgLen, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.MinMsgLen = msgLen
                }</span>
        }

        <span class="cov8" title="1">if val := r.FormValue("maxEmoji"); val != "" </span><span class="cov8" title="1">{
                if count, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.MaxEmoji = count
                }</span>
        }

        <span class="cov8" title="1">if val := r.FormValue("minSpamProbability"); val != "" </span><span class="cov8" title="1">{
                if prob, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov8" title="1">{
                        settings.MinSpamProbability = prob
                }</span>
        }

        <span class="cov8" title="1">settings.ParanoidMode = r.FormValue("paranoidMode") == "on"

        if val := r.FormValue("firstMessagesCount"); val != "" </span><span class="cov8" title="1">{
                if count, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.FirstMessagesCount = count
                }</span>
        }

        // startupMessageEnabled controls Message.Startup
        <span class="cov8" title="1">startupMessageEnabled := r.FormValue("startupMessageEnabled") == "on"
        if startupMessageEnabled &amp;&amp; settings.Message.Startup == "" </span><span class="cov8" title="1">{
                settings.Message.Startup = "Bot started"
        }</span> else<span class="cov8" title="1"> if !startupMessageEnabled </span><span class="cov8" title="1">{
                settings.Message.Startup = ""
        }</span>

        <span class="cov8" title="1">settings.Training = r.FormValue("trainingEnabled") == "on"
        settings.SoftBan = r.FormValue("softBanEnabled") == "on"
        settings.AbnormalSpace.Enabled = r.FormValue("abnormalSpacingEnabled") == "on"

        if val := r.FormValue("multiLangLimit"); val != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                        settings.MultiLangWords = limit
                }</span>
        }

        <span class="cov8" title="1">if val := r.FormValue("historySize"); val != "" </span><span class="cov8" title="1">{
                if size, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.History.Size = size
                }</span>
        }

        // data storage
        <span class="cov8" title="1">if val := r.FormValue("samplesDataPath"); val != "" </span><span class="cov0" title="0">{
                settings.Files.SamplesDataPath = val
        }</span>

        <span class="cov8" title="1">if val := r.FormValue("dynamicDataPath"); val != "" </span><span class="cov0" title="0">{
                settings.Files.DynamicDataPath = val
        }</span>

        <span class="cov8" title="1">if val := r.FormValue("watchIntervalSecs"); val != "" </span><span class="cov8" title="1">{
                if secs, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        settings.Files.WatchInterval = secs
                }</span>
        }

        // debug modes - they're primarily CLI settings but we still update them here
        <span class="cov8" title="1">settings.Transient.Dbg = r.FormValue("debugModeEnabled") == "on"
        settings.Dry = r.FormValue("dryModeEnabled") == "on"
        settings.Transient.TGDbg = r.FormValue("tgDebugModeEnabled") == "on"</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package webapi

import (
        "context"
        "github.com/umputun/tg-spam/app/config"
        "sync"
        "time"
)

// SettingsStoreMock is a mock implementation of SettingsStore.
//
//        func TestSomethingThatUsesSettingsStore(t *testing.T) {
//
//                // make and configure a mocked SettingsStore
//                mockedSettingsStore := &amp;SettingsStoreMock{
//                        DeleteFunc: func(ctx context.Context) error {
//                                panic("mock out the Delete method")
//                        },
//                        ExistsFunc: func(ctx context.Context) (bool, error) {
//                                panic("mock out the Exists method")
//                        },
//                        LastUpdatedFunc: func(ctx context.Context) (time.Time, error) {
//                                panic("mock out the LastUpdated method")
//                        },
//                        LoadFunc: func(ctx context.Context) (*config.Settings, error) {
//                                panic("mock out the Load method")
//                        },
//                        SaveFunc: func(ctx context.Context, settings *config.Settings) error {
//                                panic("mock out the Save method")
//                        },
//                }
//
//                // use mockedSettingsStore in code that requires SettingsStore
//                // and then make assertions.
//
//        }
type SettingsStoreMock struct {
        // DeleteFunc mocks the Delete method.
        DeleteFunc func(ctx context.Context) error

        // ExistsFunc mocks the Exists method.
        ExistsFunc func(ctx context.Context) (bool, error)

        // LastUpdatedFunc mocks the LastUpdated method.
        LastUpdatedFunc func(ctx context.Context) (time.Time, error)

        // LoadFunc mocks the Load method.
        LoadFunc func(ctx context.Context) (*config.Settings, error)

        // SaveFunc mocks the Save method.
        SaveFunc func(ctx context.Context, settings *config.Settings) error

        // calls tracks calls to the methods.
        calls struct {
                // Delete holds details about calls to the Delete method.
                Delete []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Exists holds details about calls to the Exists method.
                Exists []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // LastUpdated holds details about calls to the LastUpdated method.
                LastUpdated []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Load holds details about calls to the Load method.
                Load []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Save holds details about calls to the Save method.
                Save []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // Settings is the settings argument value.
                        Settings *config.Settings
                }
        }
        lockDelete      sync.RWMutex
        lockExists      sync.RWMutex
        lockLastUpdated sync.RWMutex
        lockLoad        sync.RWMutex
        lockSave        sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *SettingsStoreMock) Delete(ctx context.Context) error <span class="cov8" title="1">{
        if mock.DeleteFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.DeleteFunc: method is nil but SettingsStore.Delete was just called")</span>
        }
        <span class="cov8" title="1">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockDelete.Lock()
        mock.calls.Delete = append(mock.calls.Delete, callInfo)
        mock.lockDelete.Unlock()
        return mock.DeleteFunc(ctx)</span>
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//        len(mockedSettingsStore.DeleteCalls())
func (mock *SettingsStoreMock) DeleteCalls() []struct {
        Ctx context.Context
} <span class="cov8" title="1">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockDelete.RLock()
        calls = mock.calls.Delete
        mock.lockDelete.RUnlock()
        return calls
}</span>

// ResetDeleteCalls reset all the calls that were made to Delete.
func (mock *SettingsStoreMock) ResetDeleteCalls() <span class="cov0" title="0">{
        mock.lockDelete.Lock()
        mock.calls.Delete = nil
        mock.lockDelete.Unlock()
}</span>

// Exists calls ExistsFunc.
func (mock *SettingsStoreMock) Exists(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        if mock.ExistsFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.ExistsFunc: method is nil but SettingsStore.Exists was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockExists.Lock()
        mock.calls.Exists = append(mock.calls.Exists, callInfo)
        mock.lockExists.Unlock()
        return mock.ExistsFunc(ctx)</span>
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//        len(mockedSettingsStore.ExistsCalls())
func (mock *SettingsStoreMock) ExistsCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockExists.RLock()
        calls = mock.calls.Exists
        mock.lockExists.RUnlock()
        return calls
}</span>

// ResetExistsCalls reset all the calls that were made to Exists.
func (mock *SettingsStoreMock) ResetExistsCalls() <span class="cov0" title="0">{
        mock.lockExists.Lock()
        mock.calls.Exists = nil
        mock.lockExists.Unlock()
}</span>

// LastUpdated calls LastUpdatedFunc.
func (mock *SettingsStoreMock) LastUpdated(ctx context.Context) (time.Time, error) <span class="cov0" title="0">{
        if mock.LastUpdatedFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.LastUpdatedFunc: method is nil but SettingsStore.LastUpdated was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockLastUpdated.Lock()
        mock.calls.LastUpdated = append(mock.calls.LastUpdated, callInfo)
        mock.lockLastUpdated.Unlock()
        return mock.LastUpdatedFunc(ctx)</span>
}

// LastUpdatedCalls gets all the calls that were made to LastUpdated.
// Check the length with:
//
//        len(mockedSettingsStore.LastUpdatedCalls())
func (mock *SettingsStoreMock) LastUpdatedCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockLastUpdated.RLock()
        calls = mock.calls.LastUpdated
        mock.lockLastUpdated.RUnlock()
        return calls
}</span>

// ResetLastUpdatedCalls reset all the calls that were made to LastUpdated.
func (mock *SettingsStoreMock) ResetLastUpdatedCalls() <span class="cov0" title="0">{
        mock.lockLastUpdated.Lock()
        mock.calls.LastUpdated = nil
        mock.lockLastUpdated.Unlock()
}</span>

// Load calls LoadFunc.
func (mock *SettingsStoreMock) Load(ctx context.Context) (*config.Settings, error) <span class="cov8" title="1">{
        if mock.LoadFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.LoadFunc: method is nil but SettingsStore.Load was just called")</span>
        }
        <span class="cov8" title="1">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockLoad.Lock()
        mock.calls.Load = append(mock.calls.Load, callInfo)
        mock.lockLoad.Unlock()
        return mock.LoadFunc(ctx)</span>
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//        len(mockedSettingsStore.LoadCalls())
func (mock *SettingsStoreMock) LoadCalls() []struct {
        Ctx context.Context
} <span class="cov8" title="1">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockLoad.RLock()
        calls = mock.calls.Load
        mock.lockLoad.RUnlock()
        return calls
}</span>

// ResetLoadCalls reset all the calls that were made to Load.
func (mock *SettingsStoreMock) ResetLoadCalls() <span class="cov0" title="0">{
        mock.lockLoad.Lock()
        mock.calls.Load = nil
        mock.lockLoad.Unlock()
}</span>

// Save calls SaveFunc.
func (mock *SettingsStoreMock) Save(ctx context.Context, settings *config.Settings) error <span class="cov8" title="1">{
        if mock.SaveFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.SaveFunc: method is nil but SettingsStore.Save was just called")</span>
        }
        <span class="cov8" title="1">callInfo := struct {
                Ctx      context.Context
                Settings *config.Settings
        }{
                Ctx:      ctx,
                Settings: settings,
        }
        mock.lockSave.Lock()
        mock.calls.Save = append(mock.calls.Save, callInfo)
        mock.lockSave.Unlock()
        return mock.SaveFunc(ctx, settings)</span>
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//        len(mockedSettingsStore.SaveCalls())
func (mock *SettingsStoreMock) SaveCalls() []struct {
        Ctx      context.Context
        Settings *config.Settings
} <span class="cov8" title="1">{
        var calls []struct {
                Ctx      context.Context
                Settings *config.Settings
        }
        mock.lockSave.RLock()
        calls = mock.calls.Save
        mock.lockSave.RUnlock()
        return calls
}</span>

// ResetSaveCalls reset all the calls that were made to Save.
func (mock *SettingsStoreMock) ResetSaveCalls() <span class="cov0" title="0">{
        mock.lockSave.Lock()
        mock.calls.Save = nil
        mock.lockSave.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SettingsStoreMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockDelete.Lock()
        mock.calls.Delete = nil
        mock.lockDelete.Unlock()

        mock.lockExists.Lock()
        mock.calls.Exists = nil
        mock.lockExists.Unlock()

        mock.lockLastUpdated.Lock()
        mock.calls.LastUpdated = nil
        mock.lockLastUpdated.Unlock()

        mock.lockLoad.Lock()
        mock.calls.Load = nil
        mock.lockLoad.Unlock()

        mock.lockSave.Lock()
        mock.calls.Save = nil
        mock.lockSave.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package webapi provides a web API spam detection service.
package webapi

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/rand"
        "crypto/sha1" //nolint
        "embed"
        "encoding/json"
        "errors"
        "fmt"
        "html/template"
        "io"
        "io/fs"
        "math/big"
        "net/http"
        "path"
        "strconv"
        "strings"
        "time"

        "github.com/didip/tollbooth/v8"
        log "github.com/go-pkgz/lgr"
        "github.com/go-pkgz/rest"
        "github.com/go-pkgz/rest/logger"
        "github.com/go-pkgz/routegroup"

        "github.com/umputun/tg-spam/app/config"
        "github.com/umputun/tg-spam/app/storage"
        "github.com/umputun/tg-spam/app/storage/engine"
        "github.com/umputun/tg-spam/lib/approved"
        "github.com/umputun/tg-spam/lib/spamcheck"
)

//go:generate moq --out mocks/detector.go --pkg mocks --with-resets --skip-ensure . Detector
//go:generate moq --out mocks/spam_filter.go --pkg mocks --with-resets --skip-ensure . SpamFilter
//go:generate moq --out mocks/locator.go --pkg mocks --with-resets --skip-ensure . Locator
//go:generate moq --out mocks/detected_spam.go --pkg mocks --with-resets --skip-ensure . DetectedSpam
//go:generate moq --out mocks/storage_engine.go --pkg mocks --with-resets --skip-ensure . StorageEngine

//go:embed assets/* assets/components/*
var templateFS embed.FS
var tmpl = template.Must(template.ParseFS(templateFS, "assets/*.html", "assets/components/*.html"))

// startTime tracks when the server started
var startTime = time.Now()

// Server is a web API server.
type Server struct {
        Config
}

// Config defines  server parameters
type Config struct {
        Version       string           // version to show in /ping
        ListenAddr    string           // listen address
        Detector      Detector         // spam detector
        SpamFilter    SpamFilter       // spam filter (bot)
        DetectedSpam  DetectedSpam     // detected spam accessor
        Locator       Locator          // locator for user info
        StorageEngine StorageEngine    // database engine access for backups
        SettingsStore SettingsStore    // configuration storage interface
        AuthUser      string           // basic auth username (default: "tg-spam")
        AuthPasswd    string           // basic auth password
        AuthHash      string           // basic auth hash. If both AuthPasswd and AuthHash are provided, AuthHash is used
        Dbg           bool             // debug mode
        AppSettings   *config.Settings // application settings
        ConfigDBMode  bool             // indicates if app is running with database config
}

// Settings contains all application settings
type Settings struct {
        InstanceID              string        `json:"instance_id"`
        PrimaryGroup            string        `json:"primary_group"`
        AdminGroup              string        `json:"admin_group"`
        DisableAdminSpamForward bool          `json:"disable_admin_spam_forward"`
        LoggerEnabled           bool          `json:"logger_enabled"`
        SuperUsers              []string      `json:"super_users"`
        NoSpamReply             bool          `json:"no_spam_reply"`
        CasEnabled              bool          `json:"cas_enabled"`
        MetaEnabled             bool          `json:"meta_enabled"`
        MetaLinksLimit          int           `json:"meta_links_limit"`
        MetaMentionsLimit       int           `json:"meta_mentions_limit"`
        MetaLinksOnly           bool          `json:"meta_links_only"`
        MetaImageOnly           bool          `json:"meta_image_only"`
        MetaVideoOnly           bool          `json:"meta_video_only"`
        MetaAudioOnly           bool          `json:"meta_audio_only"`
        MetaForwarded           bool          `json:"meta_forwarded"`
        MetaKeyboard            bool          `json:"meta_keyboard"`
        MetaUsernameSymbols     string        `json:"meta_username_symbols"`
        MultiLangLimit          int           `json:"multi_lang_limit"`
        OpenAIEnabled           bool          `json:"openai_enabled"`
        LuaPluginsEnabled       bool          `json:"lua_plugins_enabled"`
        LuaPluginsDir           string        `json:"lua_plugins_dir"`
        LuaEnabledPlugins       []string      `json:"lua_enabled_plugins"`
        LuaDynamicReload        bool          `json:"lua_dynamic_reload"`
        LuaAvailablePlugins     []string      `json:"lua_available_plugins"` // the list of all available Lua plugins
        SamplesDataPath         string        `json:"samples_data_path"`
        DynamicDataPath         string        `json:"dynamic_data_path"`
        WatchIntervalSecs       int           `json:"watch_interval_secs"`
        SimilarityThreshold     float64       `json:"similarity_threshold"`
        MinMsgLen               int           `json:"min_msg_len"`
        MaxEmoji                int           `json:"max_emoji"`
        MinSpamProbability      float64       `json:"min_spam_probability"`
        ParanoidMode            bool          `json:"paranoid_mode"`
        FirstMessagesCount      int           `json:"first_messages_count"`
        StartupMessageEnabled   bool          `json:"startup_message_enabled"`
        TrainingEnabled         bool          `json:"training_enabled"`
        StorageTimeout          time.Duration `json:"storage_timeout"`
        OpenAIVeto              bool          `json:"openai_veto"`
        OpenAIHistorySize       int           `json:"openai_history_size"`
        OpenAIModel             string        `json:"openai_model"`
        SoftBanEnabled          bool          `json:"soft_ban_enabled"`
        AbnormalSpacingEnabled  bool          `json:"abnormal_spacing_enabled"`
        HistorySize             int           `json:"history_size"`
        DebugModeEnabled        bool          `json:"debug_mode_enabled"`
        DryModeEnabled          bool          `json:"dry_mode_enabled"`
        TGDebugModeEnabled      bool          `json:"tg_debug_mode_enabled"`
}

// Detector is a spam detector interface.
type Detector interface {
        Check(req spamcheck.Request) (spam bool, cr []spamcheck.Response)
        ApprovedUsers() []approved.UserInfo
        AddApprovedUser(user approved.UserInfo) error
        RemoveApprovedUser(id string) error
        GetLuaPluginNames() []string // Returns the list of available Lua plugin names
}

// SpamFilter is a spam filter, bot interface.
type SpamFilter interface {
        UpdateSpam(msg string) error
        UpdateHam(msg string) error
        ReloadSamples() (err error)
        DynamicSamples() (spam, ham []string, err error)
        RemoveDynamicSpamSample(sample string) error
        RemoveDynamicHamSample(sample string) error
}

// Locator is a storage interface used to get user id by name and vice versa.
type Locator interface {
        UserIDByName(ctx context.Context, userName string) int64
        UserNameByID(ctx context.Context, userID int64) string
}

// DetectedSpam is a storage interface used to get detected spam messages and set added flag.
type DetectedSpam interface {
        Read(ctx context.Context) ([]storage.DetectedSpamInfo, error)
        SetAddedToSamplesFlag(ctx context.Context, id int64) error
        FindByUserID(ctx context.Context, userID int64) (*storage.DetectedSpamInfo, error)
}

// StorageEngine provides access to the database engine for operations like backup
type StorageEngine interface {
        Backup(ctx context.Context, w io.Writer) error
        Type() engine.Type
        BackupSqliteAsPostgres(ctx context.Context, w io.Writer) error
}

// NewServer creates a new web API server.
func NewServer(cfg Config) *Server <span class="cov8" title="1">{
        return &amp;Server{Config: cfg}
}</span>

// Run starts server and accepts requests checking for spam messages.
func (s *Server) Run(ctx context.Context) error <span class="cov8" title="1">{
        router := routegroup.New(http.NewServeMux())
        router.Use(rest.Recoverer(log.Default()))
        router.Use(logger.New(logger.Log(log.Default()), logger.Prefix("[DEBUG]")).Handler)
        router.Use(rest.Throttle(1000))
        router.Use(rest.AppInfo("tg-spam", "umputun", s.Version), rest.Ping)
        router.Use(tollbooth.HTTPMiddleware(tollbooth.NewLimiter(50, nil)))
        router.Use(rest.SizeLimit(1024 * 1024)) // 1M max request size

        // set default username if not provided
        if s.AuthUser == "" </span><span class="cov8" title="1">{
                s.AuthUser = "tg-spam" // default username
        }</span>

        // hash-based authentication for maximum security
        <span class="cov8" title="1">if s.AuthHash != "" </span><span class="cov8" title="1">{
                log.Printf("[INFO] basic auth enabled for webapi server (user: %s)", s.AuthUser)
                router.Use(rest.BasicAuthWithBcryptHashAndPrompt(s.AuthUser, s.AuthHash))
        }</span> else<span class="cov8" title="1"> {
                log.Printf("[WARN] basic auth disabled, access to webapi is not protected")
        }</span>

        <span class="cov8" title="1">router = s.routes(router) // setup routes

        srv := &amp;http.Server{Addr: s.ListenAddr, Handler: router, ReadTimeout: 5 * time.Second, WriteTimeout: 5 * time.Second}
        go func() </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to shutdown webapi server: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("[INFO] webapi server stopped")
                }</span>
        }()

        <span class="cov8" title="1">log.Printf("[INFO] start webapi server on %s", s.ListenAddr)
        if err := srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run server: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Server) routes(router *routegroup.Bundle) *routegroup.Bundle <span class="cov8" title="1">{
        // auth api routes
        router.Route(func(authApi *routegroup.Bundle) </span><span class="cov8" title="1">{
                if s.AuthHash != "" </span><span class="cov8" title="1">{
                        authApi.Use(s.authMiddleware(rest.BasicAuthWithBcryptHashAndPrompt(s.AuthUser, s.AuthHash)))
                }</span>
                <span class="cov8" title="1">authApi.HandleFunc("POST /check", s.checkMsgHandler)         // check a message for spam
                authApi.HandleFunc("GET /check/{user_id}", s.checkIDHandler) // check user id for spam

                authApi.Mount("/update").Route(func(r *routegroup.Bundle) </span><span class="cov8" title="1">{
                        // update spam/ham samples
                        r.HandleFunc("POST /spam", s.updateSampleHandler(s.SpamFilter.UpdateSpam)) // update spam samples
                        r.HandleFunc("POST /ham", s.updateSampleHandler(s.SpamFilter.UpdateHam))   // update ham samples
                }</span>)

                <span class="cov8" title="1">authApi.Mount("/delete").Route(func(r *routegroup.Bundle) </span><span class="cov8" title="1">{
                        // delete spam/ham samples
                        r.HandleFunc("POST /spam", s.deleteSampleHandler(s.SpamFilter.RemoveDynamicSpamSample))
                        r.HandleFunc("POST /ham", s.deleteSampleHandler(s.SpamFilter.RemoveDynamicHamSample))
                }</span>)

                <span class="cov8" title="1">authApi.Mount("/download").Route(func(r *routegroup.Bundle) </span><span class="cov8" title="1">{
                        r.HandleFunc("GET /spam", s.downloadSampleHandler(func(spam, _ []string) ([]string, string) </span><span class="cov0" title="0">{
                                return spam, "spam.txt"
                        }</span>))
                        <span class="cov8" title="1">r.HandleFunc("GET /ham", s.downloadSampleHandler(func(_, ham []string) ([]string, string) </span><span class="cov0" title="0">{
                                return ham, "ham.txt"
                        }</span>))
                        <span class="cov8" title="1">r.HandleFunc("GET /detected_spam", s.downloadDetectedSpamHandler)
                        r.HandleFunc("GET /backup", s.downloadBackupHandler)
                        r.HandleFunc("GET /export-to-postgres", s.downloadExportToPostgresHandler)</span>
                })

                <span class="cov8" title="1">authApi.HandleFunc("GET /samples", s.getDynamicSamplesHandler)    // get dynamic samples
                authApi.HandleFunc("PUT /samples", s.reloadDynamicSamplesHandler) // reload samples

                authApi.Mount("/users").Route(func(r *routegroup.Bundle) </span><span class="cov8" title="1">{ // manage approved users
                        // add user to the approved list and storage
                        r.HandleFunc("POST /add", s.updateApprovedUsersHandler(s.Detector.AddApprovedUser))
                        // remove user from an approved list and storage
                        r.HandleFunc("POST /delete", s.updateApprovedUsersHandler(s.removeApprovedUser))
                        // get approved users
                        r.HandleFunc("GET /", s.getApprovedUsersHandler)
                }</span>)

                <span class="cov8" title="1">authApi.HandleFunc("GET /settings", s.getSettingsHandler)</span> // get application settings
        })

        <span class="cov8" title="1">router.Route(func(webUI *routegroup.Bundle) </span><span class="cov8" title="1">{
                if s.AuthHash != "" </span><span class="cov8" title="1">{
                        webUI.Use(s.authMiddleware(rest.BasicAuthWithBcryptHashAndPrompt(s.AuthUser, s.AuthHash)))
                }</span>
                <span class="cov8" title="1">webUI.HandleFunc("GET /", s.htmlSpamCheckHandler)                         // serve template for webUI UI
                webUI.HandleFunc("GET /manage_samples", s.htmlManageSamplesHandler)       // serve manage samples page
                webUI.HandleFunc("GET /manage_users", s.htmlManageUsersHandler)           // serve manage users page
                webUI.HandleFunc("GET /detected_spam", s.htmlDetectedSpamHandler)         // serve detected spam page
                webUI.HandleFunc("GET /list_settings", s.htmlSettingsHandler)             // serve settings
                webUI.HandleFunc("POST /detected_spam/add", s.htmlAddDetectedSpamHandler) // add detected spam to samples

                // configuration management endpoints
                if s.SettingsStore != nil &amp;&amp; s.ConfigDBMode </span><span class="cov0" title="0">{
                        webUI.Route(func(config *routegroup.Bundle) </span><span class="cov0" title="0">{
                                config.HandleFunc("POST /config", s.saveConfigHandler)     // save current configuration to database
                                config.HandleFunc("GET /config", s.loadConfigHandler)      // load configuration from database
                                config.HandleFunc("PUT /config", s.updateConfigHandler)    // update configuration
                                config.HandleFunc("DELETE /config", s.deleteConfigHandler) // delete configuration
                        }</span>)
                }

                // handle logout - force Basic Auth re-authentication
                <span class="cov8" title="1">webUI.HandleFunc("GET /logout", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                        w.Header().Set("WWW-Authenticate", `Basic realm="tg-spam"`)
                        w.WriteHeader(http.StatusUnauthorized)
                        fmt.Fprintln(w, "Logged out successfully")
                }</span>)

                // serve only specific static files at root level
                <span class="cov8" title="1">staticFiles := newStaticFS(templateFS,
                        staticFileMapping{urlPath: "styles.css", filesysPath: "assets/styles.css"},
                        staticFileMapping{urlPath: "logo.png", filesysPath: "assets/logo.png"},
                        staticFileMapping{urlPath: "spinner.svg", filesysPath: "assets/spinner.svg"},
                )
                webUI.HandleFiles("/", http.FS(staticFiles))</span>
        })

        <span class="cov8" title="1">return router</span>
}

// checkMsgHandler handles POST /check request.
// it gets message text and user id from request body and returns spam status and check results.
func (s *Server) checkMsgHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        type CheckResultDisplay struct {
                Spam   bool
                Checks []spamcheck.Response
        }

        isHtmxRequest := r.Header.Get("HX-Request") == "true"

        req := spamcheck.Request{CheckOnly: true}
        if !isHtmxRequest </span><span class="cov8" title="1">{
                // API request
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusBadRequest)
                        rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                        log.Printf("[WARN] can't decode request: %v", err)
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                // for hx-request (HTMX) we need to get the values from the form
                req.UserID = r.FormValue("user_id")
                req.UserName = r.FormValue("user_name")
                req.Msg = r.FormValue("msg")
        }</span>

        <span class="cov8" title="1">spam, cr := s.Detector.Check(req)
        if !isHtmxRequest </span><span class="cov8" title="1">{
                // for API request return JSON
                rest.RenderJSON(w, rest.JSON{"spam": spam, "checks": cr})
                return
        }</span>

        <span class="cov8" title="1">if req.Msg == "" </span><span class="cov0" title="0">{
                w.Header().Set("HX-Retarget", "#error-message")
                fmt.Fprintln(w, "&lt;div class='alert alert-danger'&gt;Valid message required.&lt;/div&gt;")
                return
        }</span>

        // render result for HTMX request
        <span class="cov8" title="1">resultDisplay := CheckResultDisplay{
                Spam:   spam,
                Checks: cr,
        }

        if err := tmpl.ExecuteTemplate(w, "check_results", resultDisplay); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] can't execute result template: %v", err)
                http.Error(w, "Error rendering result", http.StatusInternalServerError)
                return
        }</span>
}

// checkIDHandler handles GET /check/{user_id} request.
// it returns JSON with the status "spam" or "ham" for a given user id.
// if user is spammer, it also returns check results.
func (s *Server) checkIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        type info struct {
                UserName  string               `json:"user_name,omitempty"`
                Message   string               `json:"message,omitempty"`
                Timestamp time.Time            `json:"timestamp,omitempty"`
                Checks    []spamcheck.Response `json:"checks,omitempty"`
        }
        resp := struct {
                Status string `json:"status"`
                Info   *info  `json:"info,omitempty"`
        }{
                Status: "ham",
        }

        userID, err := strconv.ParseInt(r.PathValue("user_id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                rest.RenderJSON(w, rest.JSON{"error": "can't parse user id", "details": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">si, err := s.DetectedSpam.FindByUserID(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't get user info", "details": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if si != nil </span><span class="cov8" title="1">{
                resp.Status = "spam"
                resp.Info = &amp;info{
                        UserName:  si.UserName,
                        Message:   si.Text,
                        Timestamp: si.Timestamp,
                        Checks:    si.Checks,
                }
        }</span>
        <span class="cov8" title="1">rest.RenderJSON(w, resp)</span>
}

// getDynamicSamplesHandler handles GET /samples request. It returns dynamic samples both for spam and ham.
func (s *Server) getDynamicSamplesHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        spam, ham, err := s.SpamFilter.DynamicSamples()
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't get dynamic samples", "details": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">rest.RenderJSON(w, rest.JSON{"spam": spam, "ham": ham})</span>
}

// downloadSampleHandler handles GET /download/spam|ham request. It returns dynamic samples both for spam and ham.
func (s *Server) downloadSampleHandler(pickFn func(spam, ham []string) ([]string, string)) func(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                spam, ham, err := s.SpamFilter.DynamicSamples()
                if err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't get dynamic samples", "details": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">samples, name := pickFn(spam, ham)
                body := strings.Join(samples, "\n")
                w.Header().Set("Content-Type", "text/plain; charset=utf-8")
                w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", name))
                w.Header().Set("Content-Length", strconv.Itoa(len(body)))
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte(body))</span>
        }
}

// updateSampleHandler handles POST /update/spam|ham request. It updates dynamic samples both for spam and ham.
func (s *Server) updateSampleHandler(updFn func(msg string) error) func(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var req struct {
                        Msg string `json:"msg"`
                }

                isHtmxRequest := r.Header.Get("HX-Request") == "true"

                if isHtmxRequest </span><span class="cov0" title="0">{
                        req.Msg = r.FormValue("msg")
                }</span> else<span class="cov8" title="1"> {
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusBadRequest)
                                rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                                return
                        }</span>
                }

                <span class="cov8" title="1">err := updFn(req.Msg)
                if err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't update samples", "details": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if isHtmxRequest </span><span class="cov0" title="0">{
                        s.renderSamples(w, "samples_list")
                }</span> else<span class="cov8" title="1"> {
                        rest.RenderJSON(w, rest.JSON{"updated": true, "msg": req.Msg})
                }</span>
        }
}

// deleteSampleHandler handles DELETE /samples request. It deletes dynamic samples both for spam and ham.
func (s *Server) deleteSampleHandler(delFn func(msg string) error) func(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var req struct {
                        Msg string `json:"msg"`
                }
                isHtmxRequest := r.Header.Get("HX-Request") == "true"
                if isHtmxRequest </span><span class="cov8" title="1">{
                        req.Msg = r.FormValue("msg")
                }</span> else<span class="cov8" title="1"> {
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusBadRequest)
                                rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                                return
                        }</span>
                }

                <span class="cov8" title="1">if err := delFn(req.Msg); err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't delete sample", "details": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if isHtmxRequest </span><span class="cov8" title="1">{
                        s.renderSamples(w, "samples_list")
                }</span> else<span class="cov8" title="1"> {
                        rest.RenderJSON(w, rest.JSON{"deleted": true, "msg": req.Msg, "count": 1})
                }</span>
        }
}

// reloadDynamicSamplesHandler handles PUT /samples request. It reloads dynamic samples from db storage.
func (s *Server) reloadDynamicSamplesHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        if err := s.SpamFilter.ReloadSamples(); err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't reload samples", "details": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">rest.RenderJSON(w, rest.JSON{"reloaded": true})</span>
}

// updateApprovedUsersHandler handles POST /users/add and /users/delete requests, it adds or removes users from approved list.
func (s *Server) updateApprovedUsersHandler(updFn func(ui approved.UserInfo) error) func(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                req := approved.UserInfo{}
                isHtmxRequest := r.Header.Get("HX-Request") == "true"
                if isHtmxRequest </span><span class="cov8" title="1">{
                        req.UserID = r.FormValue("user_id")
                        req.UserName = r.FormValue("user_name")
                }</span> else<span class="cov8" title="1"> {
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusBadRequest)
                                rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                                return
                        }</span>
                }

                // try to get userID from request and fallback to userName lookup if it's empty
                <span class="cov8" title="1">if req.UserID == "" </span><span class="cov8" title="1">{
                        req.UserID = strconv.FormatInt(s.Locator.UserIDByName(r.Context(), req.UserName), 10)
                }</span>

                <span class="cov8" title="1">if req.UserID == "" || req.UserID == "0" </span><span class="cov8" title="1">{
                        if isHtmxRequest </span><span class="cov0" title="0">{
                                w.Header().Set("HX-Retarget", "#error-message")
                                fmt.Fprintln(w, "&lt;div class='alert alert-danger'&gt;Either userid or valid username required.&lt;/div&gt;")
                                return
                        }</span>
                        <span class="cov8" title="1">w.WriteHeader(http.StatusBadRequest)
                        rest.RenderJSON(w, rest.JSON{"error": "user ID is required"})
                        return</span>
                }

                // add or remove user from the approved list of detector
                <span class="cov8" title="1">if err := updFn(req); err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't update approved users", "details": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if isHtmxRequest </span><span class="cov8" title="1">{
                        users := s.Detector.ApprovedUsers()
                        tmplData := struct {
                                ApprovedUsers      []approved.UserInfo
                                TotalApprovedUsers int
                        }{
                                ApprovedUsers:      users,
                                TotalApprovedUsers: len(users),
                        }

                        if err := tmpl.ExecuteTemplate(w, "users_list", tmplData); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>

                } else<span class="cov8" title="1"> {
                        rest.RenderJSON(w, rest.JSON{"updated": true, "user_id": req.UserID, "user_name": req.UserName})
                }</span>
        }
}

// removeApprovedUser is adopter for updateApprovedUsersHandler updFn
func (s *Server) removeApprovedUser(req approved.UserInfo) error <span class="cov8" title="1">{
        if err := s.Detector.RemoveApprovedUser(req.UserID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove approved user %s: %w", req.UserID, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// getApprovedUsersHandler handles GET /users request. It returns list of approved users.
func (s *Server) getApprovedUsersHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        rest.RenderJSON(w, rest.JSON{"user_ids": s.Detector.ApprovedUsers()})
}</span>

// getSettingsHandler returns application settings, including the list of available Lua plugins
func (s *Server) getSettingsHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // get available Lua plugins and store them directly in AppSettings
        s.AppSettings.LuaPlugins.EnabledPlugins = s.Detector.GetLuaPluginNames()

        // return the application settings directly - sensitive info is protected by json tags
        rest.RenderJSON(w, s.AppSettings)
}</span>

// htmlSpamCheckHandler handles GET / request.
// It returns rendered spam_check.html template with all the components.
func (s *Server) htmlSpamCheckHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        tmplData := struct {
                Version string
        }{
                Version: s.Version,
        }

        if err := tmpl.ExecuteTemplate(w, "spam_check.html", tmplData); err != nil </span><span class="cov8" title="1">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

// htmlManageSamplesHandler handles GET /manage_samples request.
// It returns rendered manage_samples.html template with all the components.
func (s *Server) htmlManageSamplesHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.renderSamples(w, "manage_samples.html")
}</span>

func (s *Server) htmlManageUsersHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        users := s.Detector.ApprovedUsers()
        tmplData := struct {
                ApprovedUsers      []approved.UserInfo
                TotalApprovedUsers int
        }{
                ApprovedUsers:      users,
                TotalApprovedUsers: len(users),
        }
        tmplData.TotalApprovedUsers = len(tmplData.ApprovedUsers)

        if err := tmpl.ExecuteTemplate(w, "manage_users.html", tmplData); err != nil </span><span class="cov8" title="1">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

func (s *Server) htmlDetectedSpamHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ds, err := s.DetectedSpam.Read(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[ERROR] Failed to fetch detected spam: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>

        // clean up detected spam entries
        <span class="cov8" title="1">for i, d := range ds </span><span class="cov8" title="1">{
                d.Text = strings.ReplaceAll(d.Text, "'", " ")
                d.Text = strings.ReplaceAll(d.Text, "\n", " ")
                d.Text = strings.ReplaceAll(d.Text, "\r", " ")
                d.Text = strings.ReplaceAll(d.Text, "\t", " ")
                d.Text = strings.ReplaceAll(d.Text, "\"", " ")
                d.Text = strings.ReplaceAll(d.Text, "\\", " ")
                ds[i] = d
        }</span>

        // get filter from query param, default to "all"
        <span class="cov8" title="1">filter := r.URL.Query().Get("filter")
        if filter == "" </span><span class="cov8" title="1">{
                filter = "all"
        }</span>

        // apply filtering
        <span class="cov8" title="1">var filteredDS []storage.DetectedSpamInfo
        switch filter </span>{
        case "non-classified":<span class="cov0" title="0">
                for _, entry := range ds </span><span class="cov0" title="0">{
                        hasClassifierHam := false
                        for _, check := range entry.Checks </span><span class="cov0" title="0">{
                                if check.Name == "classifier" &amp;&amp; !check.Spam </span><span class="cov0" title="0">{
                                        hasClassifierHam = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasClassifierHam </span><span class="cov0" title="0">{
                                filteredDS = append(filteredDS, entry)
                        }</span>
                }
        case "openai":<span class="cov0" title="0">
                for _, entry := range ds </span><span class="cov0" title="0">{
                        hasOpenAI := false
                        for _, check := range entry.Checks </span><span class="cov0" title="0">{
                                if check.Name == "openai" </span><span class="cov0" title="0">{
                                        hasOpenAI = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasOpenAI </span><span class="cov0" title="0">{
                                filteredDS = append(filteredDS, entry)
                        }</span>
                }
        default:<span class="cov8" title="1"> // "all" or any other value
                filteredDS = ds</span>
        }

        <span class="cov8" title="1">tmplData := struct {
                DetectedSpamEntries []storage.DetectedSpamInfo
                TotalDetectedSpam   int
                FilteredCount       int
                Filter              string
                OpenAIEnabled       bool
        }{
                DetectedSpamEntries: filteredDS,
                TotalDetectedSpam:   len(ds),
                FilteredCount:       len(filteredDS),
                Filter:              filter,
                OpenAIEnabled:       s.AppSettings != nil &amp;&amp; s.AppSettings.IsOpenAIEnabled(),
        }

        // if it's an HTMX request, render both content and count display for OOB swap
        if r.Header.Get("HX-Request") == "true" </span><span class="cov0" title="0">{
                var buf bytes.Buffer

                // first render the content template
                if err := tmpl.ExecuteTemplate(&amp;buf, "detected_spam_content", tmplData); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] can't execute content template: %v", err)
                        http.Error(w, "Error executing template", http.StatusInternalServerError)
                        return
                }</span>

                // then append OOB swap for the count display
                <span class="cov0" title="0">countHTML := ""
                if filter != "all" </span><span class="cov0" title="0">{
                        countHTML = fmt.Sprintf("(%d/%d)", len(filteredDS), len(ds))
                }</span> else<span class="cov0" title="0"> {
                        countHTML = fmt.Sprintf("(%d)", len(ds))
                }</span>

                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf(`&lt;span id="count-display" hx-swap-oob="true"&gt;%s&lt;/span&gt;`, countHTML))

                // write the combined response
                if _, err := buf.WriteTo(w); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to write response: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // full page render for normal requests
        <span class="cov8" title="1">if err := tmpl.ExecuteTemplate(w, "detected_spam.html", tmplData); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

func (s *Server) htmlAddDetectedSpamHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        reportErr := func(err error, _ int) </span><span class="cov8" title="1">{
                w.Header().Set("HX-Retarget", "#error-message")
                fmt.Fprintf(w, "&lt;div class='alert alert-danger'&gt;%s&lt;/div&gt;", err)
        }</span>
        <span class="cov8" title="1">msg := r.FormValue("msg")

        id, err := strconv.ParseInt(r.FormValue("id"), 10, 64)
        if err != nil || msg == "" </span><span class="cov8" title="1">{
                log.Printf("[WARN] bad request: %v", err)
                reportErr(fmt.Errorf("bad request: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := s.SpamFilter.UpdateSpam(msg); err != nil </span><span class="cov8" title="1">{
                log.Printf("[WARN] failed to update spam samples: %v", err)
                reportErr(fmt.Errorf("can't update spam samples: %v", err), http.StatusInternalServerError)
                return

        }</span>
        <span class="cov8" title="1">if err := s.DetectedSpam.SetAddedToSamplesFlag(r.Context(), id); err != nil </span><span class="cov8" title="1">{
                log.Printf("[WARN] failed to update detected spam: %v", err)
                reportErr(fmt.Errorf("can't update detected spam: %v", err), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

func (s *Server) htmlSettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // get database information if StorageEngine is available
        var dbInfo struct {
                DatabaseType   string `json:"database_type"`
                GID            string `json:"gid"`
                DatabaseStatus string `json:"database_status"`
        }

        if s.StorageEngine != nil </span><span class="cov8" title="1">{
                // try to cast to SQL engine to get type information
                if sqlEngine, ok := s.StorageEngine.(*engine.SQL); ok </span><span class="cov0" title="0">{
                        dbInfo.DatabaseType = string(sqlEngine.Type())
                        dbInfo.GID = sqlEngine.GID()
                        dbInfo.DatabaseStatus = "Connected"
                }</span> else<span class="cov8" title="1"> {
                        dbInfo.DatabaseType = "Unknown"
                        dbInfo.DatabaseStatus = "Connected (unknown type)"
                }</span>
        } else<span class="cov8" title="1"> {
                dbInfo.DatabaseStatus = "Not connected"
        }</span>

        // get backup information
        <span class="cov8" title="1">backupURL := "/download/backup"
        backupFilename := fmt.Sprintf("tg-spam-backup-%s-%s.sql.gz", dbInfo.DatabaseType, time.Now().Format("20060102-150405"))

        // get system info - uptime since server start
        uptime := time.Since(startTime)

        // get the list of available Lua plugins
        luaPlugins := s.Detector.GetLuaPluginNames()

        // get configuration DB status
        configAvailable := false
        var lastUpdated time.Time
        if s.SettingsStore != nil </span><span class="cov0" title="0">{
                configAvailable = true
                if lu, err := s.SettingsStore.LastUpdated(r.Context()); err == nil </span><span class="cov0" title="0">{
                        lastUpdated = lu
                }</span>
        }

        <span class="cov8" title="1">data := struct {
                *config.Settings
                LuaAvailablePlugins []string
                Version             string
                Database            struct {
                        Type   string
                        GID    string
                        Status string
                }
                Backup struct {
                        URL      string
                        Filename string
                }
                System struct {
                        Uptime string
                }
                ConfigAvailable bool
                LastUpdated     time.Time
                ConfigDBMode    bool
        }{
                Settings:            s.AppSettings,
                LuaAvailablePlugins: luaPlugins,
                Version:             s.Version,
                Database: struct {
                        Type   string
                        GID    string
                        Status string
                }{
                        Type:   dbInfo.DatabaseType,
                        GID:    dbInfo.GID,
                        Status: dbInfo.DatabaseStatus,
                },
                Backup: struct {
                        URL      string
                        Filename string
                }{
                        URL:      backupURL,
                        Filename: backupFilename,
                },
                System: struct {
                        Uptime string
                }{
                        Uptime: formatDuration(uptime),
                },
                ConfigAvailable: configAvailable,
                LastUpdated:     lastUpdated,
                ConfigDBMode:    s.ConfigDBMode,
        }

        if err := tmpl.ExecuteTemplate(w, "settings.html", data); err != nil </span><span class="cov8" title="1">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

// formatDuration formats a duration in a human-readable way
func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        days := int(d.Hours() / 24)
        hours := int(d.Hours()) % 24
        minutes := int(d.Minutes()) % 60

        if days &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
        }</span>

        <span class="cov8" title="1">if hours &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh %dm", hours, minutes)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%dm", minutes)</span>
}

func (s *Server) downloadDetectedSpamHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        spam, err := s.DetectedSpam.Read(ctx)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't get detected spam", "details": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">type jsonSpamInfo struct {
                ID        int64                `json:"id"`
                GID       string               `json:"gid"`
                Text      string               `json:"text"`
                UserID    int64                `json:"user_id"`
                UserName  string               `json:"user_name"`
                Timestamp time.Time            `json:"timestamp"`
                Added     bool                 `json:"added"`
                Checks    []spamcheck.Response `json:"checks"`
        }

        // convert entries to jsonl format with lowercase fields
        lines := make([]string, 0, len(spam))
        for _, entry := range spam </span><span class="cov8" title="1">{
                data, err := json.Marshal(jsonSpamInfo{
                        ID:        entry.ID,
                        GID:       entry.GID,
                        Text:      entry.Text,
                        UserID:    entry.UserID,
                        UserName:  entry.UserName,
                        Timestamp: entry.Timestamp,
                        Added:     entry.Added,
                        Checks:    entry.Checks,
                })
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't marshal entry", "details": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">lines = append(lines, string(data))</span>
        }

        <span class="cov8" title="1">body := strings.Join(lines, "\n")
        w.Header().Set("Content-Type", "application/x-jsonlines")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", "detected_spam.jsonl"))
        w.Header().Set("Content-Length", strconv.Itoa(len(body)))
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(body))</span>
}

// downloadBackupHandler streams a database backup as an SQL file with gzip compression
// Files are always compressed and always have .gz extension to ensure consistency
func (s *Server) downloadBackupHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if s.StorageEngine == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "storage engine not available"})
                return
        }</span>

        // set filename based on database type and timestamp
        <span class="cov8" title="1">dbType := "db"
        sqlEng, ok := s.StorageEngine.(*engine.SQL)
        if ok </span><span class="cov0" title="0">{
                dbType = string(sqlEng.Type())
        }</span>
        <span class="cov8" title="1">timestamp := time.Now().Format("20060102-150405")

        // always use a .gz extension as the content is always compressed
        filename := fmt.Sprintf("tg-spam-backup-%s-%s.sql.gz", dbType, timestamp)

        // set headers for file download - note we're using application/octet-stream
        // instead of application/sql to prevent browsers from trying to interpret the file
        w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")

        // create a gzip writer that streams to response
        gzipWriter := gzip.NewWriter(w)
        defer func() </span><span class="cov8" title="1">{
                if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to close gzip writer: %v", err)
                }</span>
        }()

        // stream backup directly to response through gzip
        <span class="cov8" title="1">if err := s.StorageEngine.Backup(r.Context(), gzipWriter); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to create backup: %v", err)
                // we've already started writing the response, so we can't send a proper error response
                return
        }</span>

        // flush the gzip writer to ensure all data is written
        <span class="cov8" title="1">if err := gzipWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to flush gzip writer: %v", err)
        }</span>
}

// downloadExportToPostgresHandler streams a PostgreSQL-compatible export from a SQLite database
func (s *Server) downloadExportToPostgresHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if s.StorageEngine == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "storage engine not available"})
                return
        }</span>

        // check if the database is SQLite
        <span class="cov8" title="1">if s.StorageEngine.Type() != engine.Sqlite </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                rest.RenderJSON(w, rest.JSON{"error": "source database must be SQLite"})
                return
        }</span>

        // set filename based on timestamp
        <span class="cov8" title="1">timestamp := time.Now().Format("20060102-150405")
        filename := fmt.Sprintf("tg-spam-sqlite-to-postgres-%s.sql.gz", timestamp)

        // set headers for file download
        w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")

        // create a gzip writer that streams to response
        gzipWriter := gzip.NewWriter(w)
        defer func() </span><span class="cov8" title="1">{
                if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to close gzip writer: %v", err)
                }</span>
        }()

        // stream export directly to response through gzip
        <span class="cov8" title="1">if err := s.StorageEngine.BackupSqliteAsPostgres(r.Context(), gzipWriter); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to create export: %v", err)
                // we've already started writing the response, so we can't send a proper error response
                return
        }</span>

        // flush the gzip writer to ensure all data is written
        <span class="cov8" title="1">if err := gzipWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to flush gzip writer: %v", err)
        }</span>
}

func (s *Server) renderSamples(w http.ResponseWriter, tmplName string) <span class="cov8" title="1">{
        spam, ham, err := s.SpamFilter.DynamicSamples()
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't fetch samples", "details": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">spam, ham = s.reverseSamples(spam, ham)

        type smpleWithID struct {
                ID     string
                Sample string
        }

        makeID := func(s string) string </span><span class="cov8" title="1">{
                hash := sha1.New() //nolint
                if _, err := hash.Write([]byte(s)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%x", s)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil))</span>
        }

        <span class="cov8" title="1">tmplData := struct {
                SpamSamples      []smpleWithID
                HamSamples       []smpleWithID
                TotalHamSamples  int
                TotalSpamSamples int
        }{
                TotalHamSamples:  len(ham),
                TotalSpamSamples: len(spam),
        }
        for _, s := range spam </span><span class="cov8" title="1">{
                tmplData.SpamSamples = append(tmplData.SpamSamples, smpleWithID{ID: makeID(s), Sample: s})
        }</span>
        <span class="cov8" title="1">for _, h := range ham </span><span class="cov8" title="1">{
                tmplData.HamSamples = append(tmplData.HamSamples, smpleWithID{ID: makeID(h), Sample: h})
        }</span>

        <span class="cov8" title="1">if err := tmpl.ExecuteTemplate(w, tmplName, tmplData); err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't execute template", "details": err.Error()})
                return
        }</span>
}

func (s *Server) authMiddleware(mw func(next http.Handler) http.Handler) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        if s.AuthHash == "" </span><span class="cov0" title="0">{
                // if no hash is provided, authentication is disabled
                return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return next
                }</span>
        }
        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return mw(next)
        }</span>
}

// reverseSamples returns reversed lists of spam and ham samples
func (s *Server) reverseSamples(spam, ham []string) (revSpam, revHam []string) <span class="cov8" title="1">{
        revSpam = make([]string, len(spam))
        revHam = make([]string, len(ham))

        for i, j := 0, len(spam)-1; i &lt; len(spam); i, j = i+1, j-1 </span><span class="cov8" title="1">{
                revSpam[i] = spam[j]
        }</span>
        <span class="cov8" title="1">for i, j := 0, len(ham)-1; i &lt; len(ham); i, j = i+1, j-1 </span><span class="cov8" title="1">{
                revHam[i] = ham[j]
        }</span>
        <span class="cov8" title="1">return revSpam, revHam</span>
}

// staticFS is a filtered filesystem that only exposes specific static files
type staticFS struct {
        fs        fs.FS
        urlToPath map[string]string
}

// staticFileMapping defines a mapping between URL path and filesystem path
type staticFileMapping struct {
        urlPath     string
        filesysPath string
}

func newStaticFS(fsys fs.FS, files ...staticFileMapping) *staticFS <span class="cov8" title="1">{
        urlToPath := make(map[string]string)
        for _, f := range files </span><span class="cov8" title="1">{
                urlToPath[f.urlPath] = f.filesysPath
        }</span>

        <span class="cov8" title="1">return &amp;staticFS{
                fs:        fsys,
                urlToPath: urlToPath,
        }</span>
}

func (sfs *staticFS) Open(name string) (fs.File, error) <span class="cov8" title="1">{
        cleanName := path.Clean("/" + name)[1:]

        fsPath, ok := sfs.urlToPath[cleanName]
        if !ok </span><span class="cov8" title="1">{
                return nil, fs.ErrNotExist
        }</span>

        <span class="cov8" title="1">file, err := sfs.fs.Open(fsPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open static file %s: %w", fsPath, err)
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}

// GenerateRandomPassword generates a random password of a given length
func GenerateRandomPassword(length int) (string, error) <span class="cov8" title="1">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()_+"
        const charsetLen = int64(len(charset))

        result := make([]byte, length)
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                n, err := rand.Int(rand.Reader, big.NewInt(charsetLen))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to generate random number: %w", err)
                }</span>
                <span class="cov8" title="1">result[i] = charset[n.Int64()]</span>
        }
        <span class="cov8" title="1">return string(result), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
