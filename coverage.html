
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/umputun/tg-spam/app/bot/bot.go (100.0%)</option>
				
				<option value="file1">github.com/umputun/tg-spam/app/bot/mocks/detector.go (0.0%)</option>
				
				<option value="file2">github.com/umputun/tg-spam/app/bot/mocks/dictionary.go (0.0%)</option>
				
				<option value="file3">github.com/umputun/tg-spam/app/bot/mocks/samples.go (0.0%)</option>
				
				<option value="file4">github.com/umputun/tg-spam/app/bot/spam.go (90.7%)</option>
				
				<option value="file5">github.com/umputun/tg-spam/app/config/crypt.go (75.0%)</option>
				
				<option value="file6">github.com/umputun/tg-spam/app/config/settings.go (100.0%)</option>
				
				<option value="file7">github.com/umputun/tg-spam/app/config/store.go (81.0%)</option>
				
				<option value="file8">github.com/umputun/tg-spam/app/events/admin.go (82.5%)</option>
				
				<option value="file9">github.com/umputun/tg-spam/app/events/events.go (84.7%)</option>
				
				<option value="file10">github.com/umputun/tg-spam/app/events/listener.go (81.0%)</option>
				
				<option value="file11">github.com/umputun/tg-spam/app/events/mocks/bot.go (0.0%)</option>
				
				<option value="file12">github.com/umputun/tg-spam/app/events/mocks/locator.go (0.0%)</option>
				
				<option value="file13">github.com/umputun/tg-spam/app/events/mocks/spam_logger.go (0.0%)</option>
				
				<option value="file14">github.com/umputun/tg-spam/app/events/mocks/tb_api.go (0.0%)</option>
				
				<option value="file15">github.com/umputun/tg-spam/app/main.go (63.3%)</option>
				
				<option value="file16">github.com/umputun/tg-spam/app/storage/approved_users.go (89.4%)</option>
				
				<option value="file17">github.com/umputun/tg-spam/app/storage/detected_spam.go (87.1%)</option>
				
				<option value="file18">github.com/umputun/tg-spam/app/storage/dictionary.go (77.5%)</option>
				
				<option value="file19">github.com/umputun/tg-spam/app/storage/engine/convert.go (82.4%)</option>
				
				<option value="file20">github.com/umputun/tg-spam/app/storage/engine/engine.go (73.1%)</option>
				
				<option value="file21">github.com/umputun/tg-spam/app/storage/engine/locker.go (0.0%)</option>
				
				<option value="file22">github.com/umputun/tg-spam/app/storage/engine/query.go (100.0%)</option>
				
				<option value="file23">github.com/umputun/tg-spam/app/storage/locator.go (81.7%)</option>
				
				<option value="file24">github.com/umputun/tg-spam/app/storage/sampe_updater.go (100.0%)</option>
				
				<option value="file25">github.com/umputun/tg-spam/app/storage/samples.go (86.4%)</option>
				
				<option value="file26">github.com/umputun/tg-spam/app/storage/storage.go (78.6%)</option>
				
				<option value="file27">github.com/umputun/tg-spam/app/webapi/config.go (93.4%)</option>
				
				<option value="file28">github.com/umputun/tg-spam/app/webapi/config_store_mock.go (36.7%)</option>
				
				<option value="file29">github.com/umputun/tg-spam/app/webapi/mocks/detected_spam.go (0.0%)</option>
				
				<option value="file30">github.com/umputun/tg-spam/app/webapi/mocks/detector.go (0.0%)</option>
				
				<option value="file31">github.com/umputun/tg-spam/app/webapi/mocks/locator.go (0.0%)</option>
				
				<option value="file32">github.com/umputun/tg-spam/app/webapi/mocks/spam_filter.go (0.0%)</option>
				
				<option value="file33">github.com/umputun/tg-spam/app/webapi/mocks/storage_engine.go (0.0%)</option>
				
				<option value="file34">github.com/umputun/tg-spam/app/webapi/webapi.go (79.2%)</option>
				
				<option value="file35">github.com/umputun/tg-spam/lib/approved/approved.go (100.0%)</option>
				
				<option value="file36">github.com/umputun/tg-spam/lib/spamcheck/history.go (100.0%)</option>
				
				<option value="file37">github.com/umputun/tg-spam/lib/spamcheck/spamcheck.go (100.0%)</option>
				
				<option value="file38">github.com/umputun/tg-spam/lib/tgspam/classifier.go (94.1%)</option>
				
				<option value="file39">github.com/umputun/tg-spam/lib/tgspam/detector.go (93.8%)</option>
				
				<option value="file40">github.com/umputun/tg-spam/lib/tgspam/metachecks.go (100.0%)</option>
				
				<option value="file41">github.com/umputun/tg-spam/lib/tgspam/mocks/http_client.go (0.0%)</option>
				
				<option value="file42">github.com/umputun/tg-spam/lib/tgspam/mocks/lua_plugin_engine.go (0.0%)</option>
				
				<option value="file43">github.com/umputun/tg-spam/lib/tgspam/mocks/openai_client.go (0.0%)</option>
				
				<option value="file44">github.com/umputun/tg-spam/lib/tgspam/mocks/sample_updater.go (0.0%)</option>
				
				<option value="file45">github.com/umputun/tg-spam/lib/tgspam/mocks/user_storage.go (0.0%)</option>
				
				<option value="file46">github.com/umputun/tg-spam/lib/tgspam/openai.go (84.9%)</option>
				
				<option value="file47">github.com/umputun/tg-spam/lib/tgspam/plugin/checker.go (93.2%)</option>
				
				<option value="file48">github.com/umputun/tg-spam/lib/tgspam/plugin/helpers.go (88.8%)</option>
				
				<option value="file49">github.com/umputun/tg-spam/lib/tgspam/plugin/watcher.go (78.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bot

import (
        "fmt"
        "strings"
        "time"

        "github.com/umputun/tg-spam/lib/spamcheck"
)

// PermanentBanDuration defines duration of permanent ban:
// If user is restricted for more than 366 days or less than 30 seconds from the current time,
// they are considered to be restricted forever.
var PermanentBanDuration = time.Hour * 24 * 400

// Response describes bot's reaction on particular message
type Response struct {
        Text          string
        Send          bool                 // status
        BanInterval   time.Duration        // bots banning user set the interval
        User          User                 // user to ban
        ChannelID     int64                // channel to ban, if set then User and BanInterval are ignored
        ReplyTo       int                  // message to reply to, if 0 then no reply but common message
        DeleteReplyTo bool                 // delete message what bot replays to
        CheckResults  []spamcheck.Response // check results for the message
}

// SenderChat is the sender of the message, sent on behalf of a chat. The
// channel itself for channel messages. The supergroup itself for messages
// from anonymous group administrators. The linked channel for messages
// automatically forwarded to the discussion group
type SenderChat struct {
        // ID is a unique identifier for this chat
        ID int64 `json:"id"`
        // the field below used only for logging purposes
        // UserName for private chats, supergroups and channels if available, optional
        UserName string `json:"username,omitempty"`
}

// Message is primary record to pass data from/to bots
type Message struct {
        ID         int
        From       User
        SenderChat SenderChat `json:"sender_chat,omitempty"`
        ChatID     int64
        Sent       time.Time
        HTML       string    `json:",omitempty"`
        Text       string    `json:",omitempty"`
        Entities   *[]Entity `json:",omitempty"`
        Image      *Image    `json:",omitempty"`
        ReplyTo    struct {
                From       User
                Text       string `json:",omitempty"`
                Sent       time.Time
                SenderChat SenderChat `json:"sender_chat,omitempty"`
        } `json:",omitempty"`

        WithVideo     bool `json:",omitempty"`
        WithVideoNote bool `json:",omitempty"`
        WithForward   bool `json:",omitempty"`
        WithAudio     bool `json:",omitempty"`
        WithKeyboard  bool `json:",omitempty"`
}

// Entity represents one special entity in a text message.
// For example, hashtags, usernames, URLs, etc.
type Entity struct {
        Type   string
        Offset int
        Length int
        URL    string `json:",omitempty"` // for “text_link” only, url that will be opened after user taps on the text
        User   *User  `json:",omitempty"` // for “text_mention” only, the mentioned user
}

// Image represents image
type Image struct {
        // fileID corresponds to Telegram file_id
        FileID   string
        Width    int
        Height   int
        Caption  string    `json:",omitempty"`
        Entities *[]Entity `json:",omitempty"`
}

// User defines user info of the Message
type User struct {
        ID          int64  `json:"id"`
        Username    string `json:"user_name,omitempty"`
        DisplayName string `json:"display_name,omitempty"`
}

// DisplayName returns user's display name or username or id
func DisplayName(msg Message) string <span class="cov10" title="10">{
        displayUsername := msg.From.DisplayName
        if displayUsername == "" </span><span class="cov9" title="8">{
                displayUsername = msg.From.Username
        }</span>
        <span class="cov10" title="10">if displayUsername == "" </span><span class="cov1" title="1">{
                displayUsername = fmt.Sprintf("%d", msg.From.ID)
        }</span>
        <span class="cov10" title="10">return strings.TrimSpace(displayUsername)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "github.com/umputun/tg-spam/lib/approved"
        "github.com/umputun/tg-spam/lib/spamcheck"
        "github.com/umputun/tg-spam/lib/tgspam"
        "io"
        "sync"
)

// DetectorMock is a mock implementation of bot.Detector.
//
//        func TestSomethingThatUsesDetector(t *testing.T) {
//
//                // make and configure a mocked bot.Detector
//                mockedDetector := &amp;DetectorMock{
//                        AddApprovedUserFunc: func(user approved.UserInfo) error {
//                                panic("mock out the AddApprovedUser method")
//                        },
//                        ApprovedUsersFunc: func() []approved.UserInfo {
//                                panic("mock out the ApprovedUsers method")
//                        },
//                        CheckFunc: func(request spamcheck.Request) (bool, []spamcheck.Response) {
//                                panic("mock out the Check method")
//                        },
//                        GetLuaPluginNamesFunc: func() []string {
//                                panic("mock out the GetLuaPluginNames method")
//                        },
//                        IsApprovedUserFunc: func(userID string) bool {
//                                panic("mock out the IsApprovedUser method")
//                        },
//                        LoadSamplesFunc: func(exclReader io.Reader, spamReaders []io.Reader, hamReaders []io.Reader) (tgspam.LoadResult, error) {
//                                panic("mock out the LoadSamples method")
//                        },
//                        LoadStopWordsFunc: func(readers ...io.Reader) (tgspam.LoadResult, error) {
//                                panic("mock out the LoadStopWords method")
//                        },
//                        RemoveApprovedUserFunc: func(id string) error {
//                                panic("mock out the RemoveApprovedUser method")
//                        },
//                        RemoveHamFunc: func(msg string) error {
//                                panic("mock out the RemoveHam method")
//                        },
//                        RemoveSpamFunc: func(msg string) error {
//                                panic("mock out the RemoveSpam method")
//                        },
//                        UpdateHamFunc: func(msg string) error {
//                                panic("mock out the UpdateHam method")
//                        },
//                        UpdateSpamFunc: func(msg string) error {
//                                panic("mock out the UpdateSpam method")
//                        },
//                }
//
//                // use mockedDetector in code that requires bot.Detector
//                // and then make assertions.
//
//        }
type DetectorMock struct {
        // AddApprovedUserFunc mocks the AddApprovedUser method.
        AddApprovedUserFunc func(user approved.UserInfo) error

        // ApprovedUsersFunc mocks the ApprovedUsers method.
        ApprovedUsersFunc func() []approved.UserInfo

        // CheckFunc mocks the Check method.
        CheckFunc func(request spamcheck.Request) (bool, []spamcheck.Response)

        // GetLuaPluginNamesFunc mocks the GetLuaPluginNames method.
        GetLuaPluginNamesFunc func() []string

        // IsApprovedUserFunc mocks the IsApprovedUser method.
        IsApprovedUserFunc func(userID string) bool

        // LoadSamplesFunc mocks the LoadSamples method.
        LoadSamplesFunc func(exclReader io.Reader, spamReaders []io.Reader, hamReaders []io.Reader) (tgspam.LoadResult, error)

        // LoadStopWordsFunc mocks the LoadStopWords method.
        LoadStopWordsFunc func(readers ...io.Reader) (tgspam.LoadResult, error)

        // RemoveApprovedUserFunc mocks the RemoveApprovedUser method.
        RemoveApprovedUserFunc func(id string) error

        // RemoveHamFunc mocks the RemoveHam method.
        RemoveHamFunc func(msg string) error

        // RemoveSpamFunc mocks the RemoveSpam method.
        RemoveSpamFunc func(msg string) error

        // UpdateHamFunc mocks the UpdateHam method.
        UpdateHamFunc func(msg string) error

        // UpdateSpamFunc mocks the UpdateSpam method.
        UpdateSpamFunc func(msg string) error

        // calls tracks calls to the methods.
        calls struct {
                // AddApprovedUser holds details about calls to the AddApprovedUser method.
                AddApprovedUser []struct {
                        // User is the user argument value.
                        User approved.UserInfo
                }
                // ApprovedUsers holds details about calls to the ApprovedUsers method.
                ApprovedUsers []struct {
                }
                // Check holds details about calls to the Check method.
                Check []struct {
                        // Request is the request argument value.
                        Request spamcheck.Request
                }
                // GetLuaPluginNames holds details about calls to the GetLuaPluginNames method.
                GetLuaPluginNames []struct {
                }
                // IsApprovedUser holds details about calls to the IsApprovedUser method.
                IsApprovedUser []struct {
                        // UserID is the userID argument value.
                        UserID string
                }
                // LoadSamples holds details about calls to the LoadSamples method.
                LoadSamples []struct {
                        // ExclReader is the exclReader argument value.
                        ExclReader io.Reader
                        // SpamReaders is the spamReaders argument value.
                        SpamReaders []io.Reader
                        // HamReaders is the hamReaders argument value.
                        HamReaders []io.Reader
                }
                // LoadStopWords holds details about calls to the LoadStopWords method.
                LoadStopWords []struct {
                        // Readers is the readers argument value.
                        Readers []io.Reader
                }
                // RemoveApprovedUser holds details about calls to the RemoveApprovedUser method.
                RemoveApprovedUser []struct {
                        // ID is the id argument value.
                        ID string
                }
                // RemoveHam holds details about calls to the RemoveHam method.
                RemoveHam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // RemoveSpam holds details about calls to the RemoveSpam method.
                RemoveSpam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // UpdateHam holds details about calls to the UpdateHam method.
                UpdateHam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // UpdateSpam holds details about calls to the UpdateSpam method.
                UpdateSpam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
        }
        lockAddApprovedUser    sync.RWMutex
        lockApprovedUsers      sync.RWMutex
        lockCheck              sync.RWMutex
        lockGetLuaPluginNames  sync.RWMutex
        lockIsApprovedUser     sync.RWMutex
        lockLoadSamples        sync.RWMutex
        lockLoadStopWords      sync.RWMutex
        lockRemoveApprovedUser sync.RWMutex
        lockRemoveHam          sync.RWMutex
        lockRemoveSpam         sync.RWMutex
        lockUpdateHam          sync.RWMutex
        lockUpdateSpam         sync.RWMutex
}

// AddApprovedUser calls AddApprovedUserFunc.
func (mock *DetectorMock) AddApprovedUser(user approved.UserInfo) error <span class="cov0" title="0">{
        if mock.AddApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.AddApprovedUserFunc: method is nil but Detector.AddApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                User approved.UserInfo
        }{
                User: user,
        }
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = append(mock.calls.AddApprovedUser, callInfo)
        mock.lockAddApprovedUser.Unlock()
        return mock.AddApprovedUserFunc(user)</span>
}

// AddApprovedUserCalls gets all the calls that were made to AddApprovedUser.
// Check the length with:
//
//        len(mockedDetector.AddApprovedUserCalls())
func (mock *DetectorMock) AddApprovedUserCalls() []struct {
        User approved.UserInfo
} <span class="cov0" title="0">{
        var calls []struct {
                User approved.UserInfo
        }
        mock.lockAddApprovedUser.RLock()
        calls = mock.calls.AddApprovedUser
        mock.lockAddApprovedUser.RUnlock()
        return calls
}</span>

// ResetAddApprovedUserCalls reset all the calls that were made to AddApprovedUser.
func (mock *DetectorMock) ResetAddApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = nil
        mock.lockAddApprovedUser.Unlock()
}</span>

// ApprovedUsers calls ApprovedUsersFunc.
func (mock *DetectorMock) ApprovedUsers() []approved.UserInfo <span class="cov0" title="0">{
        if mock.ApprovedUsersFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.ApprovedUsersFunc: method is nil but Detector.ApprovedUsers was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockApprovedUsers.Lock()
        mock.calls.ApprovedUsers = append(mock.calls.ApprovedUsers, callInfo)
        mock.lockApprovedUsers.Unlock()
        return mock.ApprovedUsersFunc()</span>
}

// ApprovedUsersCalls gets all the calls that were made to ApprovedUsers.
// Check the length with:
//
//        len(mockedDetector.ApprovedUsersCalls())
func (mock *DetectorMock) ApprovedUsersCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockApprovedUsers.RLock()
        calls = mock.calls.ApprovedUsers
        mock.lockApprovedUsers.RUnlock()
        return calls
}</span>

// ResetApprovedUsersCalls reset all the calls that were made to ApprovedUsers.
func (mock *DetectorMock) ResetApprovedUsersCalls() <span class="cov0" title="0">{
        mock.lockApprovedUsers.Lock()
        mock.calls.ApprovedUsers = nil
        mock.lockApprovedUsers.Unlock()
}</span>

// Check calls CheckFunc.
func (mock *DetectorMock) Check(request spamcheck.Request) (bool, []spamcheck.Response) <span class="cov0" title="0">{
        if mock.CheckFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.CheckFunc: method is nil but Detector.Check was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Request spamcheck.Request
        }{
                Request: request,
        }
        mock.lockCheck.Lock()
        mock.calls.Check = append(mock.calls.Check, callInfo)
        mock.lockCheck.Unlock()
        return mock.CheckFunc(request)</span>
}

// CheckCalls gets all the calls that were made to Check.
// Check the length with:
//
//        len(mockedDetector.CheckCalls())
func (mock *DetectorMock) CheckCalls() []struct {
        Request spamcheck.Request
} <span class="cov0" title="0">{
        var calls []struct {
                Request spamcheck.Request
        }
        mock.lockCheck.RLock()
        calls = mock.calls.Check
        mock.lockCheck.RUnlock()
        return calls
}</span>

// ResetCheckCalls reset all the calls that were made to Check.
func (mock *DetectorMock) ResetCheckCalls() <span class="cov0" title="0">{
        mock.lockCheck.Lock()
        mock.calls.Check = nil
        mock.lockCheck.Unlock()
}</span>

// GetLuaPluginNames calls GetLuaPluginNamesFunc.
func (mock *DetectorMock) GetLuaPluginNames() []string <span class="cov0" title="0">{
        if mock.GetLuaPluginNamesFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.GetLuaPluginNamesFunc: method is nil but Detector.GetLuaPluginNames was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockGetLuaPluginNames.Lock()
        mock.calls.GetLuaPluginNames = append(mock.calls.GetLuaPluginNames, callInfo)
        mock.lockGetLuaPluginNames.Unlock()
        return mock.GetLuaPluginNamesFunc()</span>
}

// GetLuaPluginNamesCalls gets all the calls that were made to GetLuaPluginNames.
// Check the length with:
//
//        len(mockedDetector.GetLuaPluginNamesCalls())
func (mock *DetectorMock) GetLuaPluginNamesCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockGetLuaPluginNames.RLock()
        calls = mock.calls.GetLuaPluginNames
        mock.lockGetLuaPluginNames.RUnlock()
        return calls
}</span>

// ResetGetLuaPluginNamesCalls reset all the calls that were made to GetLuaPluginNames.
func (mock *DetectorMock) ResetGetLuaPluginNamesCalls() <span class="cov0" title="0">{
        mock.lockGetLuaPluginNames.Lock()
        mock.calls.GetLuaPluginNames = nil
        mock.lockGetLuaPluginNames.Unlock()
}</span>

// IsApprovedUser calls IsApprovedUserFunc.
func (mock *DetectorMock) IsApprovedUser(userID string) bool <span class="cov0" title="0">{
        if mock.IsApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.IsApprovedUserFunc: method is nil but Detector.IsApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                UserID string
        }{
                UserID: userID,
        }
        mock.lockIsApprovedUser.Lock()
        mock.calls.IsApprovedUser = append(mock.calls.IsApprovedUser, callInfo)
        mock.lockIsApprovedUser.Unlock()
        return mock.IsApprovedUserFunc(userID)</span>
}

// IsApprovedUserCalls gets all the calls that were made to IsApprovedUser.
// Check the length with:
//
//        len(mockedDetector.IsApprovedUserCalls())
func (mock *DetectorMock) IsApprovedUserCalls() []struct {
        UserID string
} <span class="cov0" title="0">{
        var calls []struct {
                UserID string
        }
        mock.lockIsApprovedUser.RLock()
        calls = mock.calls.IsApprovedUser
        mock.lockIsApprovedUser.RUnlock()
        return calls
}</span>

// ResetIsApprovedUserCalls reset all the calls that were made to IsApprovedUser.
func (mock *DetectorMock) ResetIsApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockIsApprovedUser.Lock()
        mock.calls.IsApprovedUser = nil
        mock.lockIsApprovedUser.Unlock()
}</span>

// LoadSamples calls LoadSamplesFunc.
func (mock *DetectorMock) LoadSamples(exclReader io.Reader, spamReaders []io.Reader, hamReaders []io.Reader) (tgspam.LoadResult, error) <span class="cov0" title="0">{
        if mock.LoadSamplesFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.LoadSamplesFunc: method is nil but Detector.LoadSamples was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                ExclReader  io.Reader
                SpamReaders []io.Reader
                HamReaders  []io.Reader
        }{
                ExclReader:  exclReader,
                SpamReaders: spamReaders,
                HamReaders:  hamReaders,
        }
        mock.lockLoadSamples.Lock()
        mock.calls.LoadSamples = append(mock.calls.LoadSamples, callInfo)
        mock.lockLoadSamples.Unlock()
        return mock.LoadSamplesFunc(exclReader, spamReaders, hamReaders)</span>
}

// LoadSamplesCalls gets all the calls that were made to LoadSamples.
// Check the length with:
//
//        len(mockedDetector.LoadSamplesCalls())
func (mock *DetectorMock) LoadSamplesCalls() []struct {
        ExclReader  io.Reader
        SpamReaders []io.Reader
        HamReaders  []io.Reader
} <span class="cov0" title="0">{
        var calls []struct {
                ExclReader  io.Reader
                SpamReaders []io.Reader
                HamReaders  []io.Reader
        }
        mock.lockLoadSamples.RLock()
        calls = mock.calls.LoadSamples
        mock.lockLoadSamples.RUnlock()
        return calls
}</span>

// ResetLoadSamplesCalls reset all the calls that were made to LoadSamples.
func (mock *DetectorMock) ResetLoadSamplesCalls() <span class="cov0" title="0">{
        mock.lockLoadSamples.Lock()
        mock.calls.LoadSamples = nil
        mock.lockLoadSamples.Unlock()
}</span>

// LoadStopWords calls LoadStopWordsFunc.
func (mock *DetectorMock) LoadStopWords(readers ...io.Reader) (tgspam.LoadResult, error) <span class="cov0" title="0">{
        if mock.LoadStopWordsFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.LoadStopWordsFunc: method is nil but Detector.LoadStopWords was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Readers []io.Reader
        }{
                Readers: readers,
        }
        mock.lockLoadStopWords.Lock()
        mock.calls.LoadStopWords = append(mock.calls.LoadStopWords, callInfo)
        mock.lockLoadStopWords.Unlock()
        return mock.LoadStopWordsFunc(readers...)</span>
}

// LoadStopWordsCalls gets all the calls that were made to LoadStopWords.
// Check the length with:
//
//        len(mockedDetector.LoadStopWordsCalls())
func (mock *DetectorMock) LoadStopWordsCalls() []struct {
        Readers []io.Reader
} <span class="cov0" title="0">{
        var calls []struct {
                Readers []io.Reader
        }
        mock.lockLoadStopWords.RLock()
        calls = mock.calls.LoadStopWords
        mock.lockLoadStopWords.RUnlock()
        return calls
}</span>

// ResetLoadStopWordsCalls reset all the calls that were made to LoadStopWords.
func (mock *DetectorMock) ResetLoadStopWordsCalls() <span class="cov0" title="0">{
        mock.lockLoadStopWords.Lock()
        mock.calls.LoadStopWords = nil
        mock.lockLoadStopWords.Unlock()
}</span>

// RemoveApprovedUser calls RemoveApprovedUserFunc.
func (mock *DetectorMock) RemoveApprovedUser(id string) error <span class="cov0" title="0">{
        if mock.RemoveApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.RemoveApprovedUserFunc: method is nil but Detector.RemoveApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                ID string
        }{
                ID: id,
        }
        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = append(mock.calls.RemoveApprovedUser, callInfo)
        mock.lockRemoveApprovedUser.Unlock()
        return mock.RemoveApprovedUserFunc(id)</span>
}

// RemoveApprovedUserCalls gets all the calls that were made to RemoveApprovedUser.
// Check the length with:
//
//        len(mockedDetector.RemoveApprovedUserCalls())
func (mock *DetectorMock) RemoveApprovedUserCalls() []struct {
        ID string
} <span class="cov0" title="0">{
        var calls []struct {
                ID string
        }
        mock.lockRemoveApprovedUser.RLock()
        calls = mock.calls.RemoveApprovedUser
        mock.lockRemoveApprovedUser.RUnlock()
        return calls
}</span>

// ResetRemoveApprovedUserCalls reset all the calls that were made to RemoveApprovedUser.
func (mock *DetectorMock) ResetRemoveApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = nil
        mock.lockRemoveApprovedUser.Unlock()
}</span>

// RemoveHam calls RemoveHamFunc.
func (mock *DetectorMock) RemoveHam(msg string) error <span class="cov0" title="0">{
        if mock.RemoveHamFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.RemoveHamFunc: method is nil but Detector.RemoveHam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockRemoveHam.Lock()
        mock.calls.RemoveHam = append(mock.calls.RemoveHam, callInfo)
        mock.lockRemoveHam.Unlock()
        return mock.RemoveHamFunc(msg)</span>
}

// RemoveHamCalls gets all the calls that were made to RemoveHam.
// Check the length with:
//
//        len(mockedDetector.RemoveHamCalls())
func (mock *DetectorMock) RemoveHamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockRemoveHam.RLock()
        calls = mock.calls.RemoveHam
        mock.lockRemoveHam.RUnlock()
        return calls
}</span>

// ResetRemoveHamCalls reset all the calls that were made to RemoveHam.
func (mock *DetectorMock) ResetRemoveHamCalls() <span class="cov0" title="0">{
        mock.lockRemoveHam.Lock()
        mock.calls.RemoveHam = nil
        mock.lockRemoveHam.Unlock()
}</span>

// RemoveSpam calls RemoveSpamFunc.
func (mock *DetectorMock) RemoveSpam(msg string) error <span class="cov0" title="0">{
        if mock.RemoveSpamFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.RemoveSpamFunc: method is nil but Detector.RemoveSpam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockRemoveSpam.Lock()
        mock.calls.RemoveSpam = append(mock.calls.RemoveSpam, callInfo)
        mock.lockRemoveSpam.Unlock()
        return mock.RemoveSpamFunc(msg)</span>
}

// RemoveSpamCalls gets all the calls that were made to RemoveSpam.
// Check the length with:
//
//        len(mockedDetector.RemoveSpamCalls())
func (mock *DetectorMock) RemoveSpamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockRemoveSpam.RLock()
        calls = mock.calls.RemoveSpam
        mock.lockRemoveSpam.RUnlock()
        return calls
}</span>

// ResetRemoveSpamCalls reset all the calls that were made to RemoveSpam.
func (mock *DetectorMock) ResetRemoveSpamCalls() <span class="cov0" title="0">{
        mock.lockRemoveSpam.Lock()
        mock.calls.RemoveSpam = nil
        mock.lockRemoveSpam.Unlock()
}</span>

// UpdateHam calls UpdateHamFunc.
func (mock *DetectorMock) UpdateHam(msg string) error <span class="cov0" title="0">{
        if mock.UpdateHamFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.UpdateHamFunc: method is nil but Detector.UpdateHam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = append(mock.calls.UpdateHam, callInfo)
        mock.lockUpdateHam.Unlock()
        return mock.UpdateHamFunc(msg)</span>
}

// UpdateHamCalls gets all the calls that were made to UpdateHam.
// Check the length with:
//
//        len(mockedDetector.UpdateHamCalls())
func (mock *DetectorMock) UpdateHamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockUpdateHam.RLock()
        calls = mock.calls.UpdateHam
        mock.lockUpdateHam.RUnlock()
        return calls
}</span>

// ResetUpdateHamCalls reset all the calls that were made to UpdateHam.
func (mock *DetectorMock) ResetUpdateHamCalls() <span class="cov0" title="0">{
        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = nil
        mock.lockUpdateHam.Unlock()
}</span>

// UpdateSpam calls UpdateSpamFunc.
func (mock *DetectorMock) UpdateSpam(msg string) error <span class="cov0" title="0">{
        if mock.UpdateSpamFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.UpdateSpamFunc: method is nil but Detector.UpdateSpam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = append(mock.calls.UpdateSpam, callInfo)
        mock.lockUpdateSpam.Unlock()
        return mock.UpdateSpamFunc(msg)</span>
}

// UpdateSpamCalls gets all the calls that were made to UpdateSpam.
// Check the length with:
//
//        len(mockedDetector.UpdateSpamCalls())
func (mock *DetectorMock) UpdateSpamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockUpdateSpam.RLock()
        calls = mock.calls.UpdateSpam
        mock.lockUpdateSpam.RUnlock()
        return calls
}</span>

// ResetUpdateSpamCalls reset all the calls that were made to UpdateSpam.
func (mock *DetectorMock) ResetUpdateSpamCalls() <span class="cov0" title="0">{
        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = nil
        mock.lockUpdateSpam.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *DetectorMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = nil
        mock.lockAddApprovedUser.Unlock()

        mock.lockApprovedUsers.Lock()
        mock.calls.ApprovedUsers = nil
        mock.lockApprovedUsers.Unlock()

        mock.lockCheck.Lock()
        mock.calls.Check = nil
        mock.lockCheck.Unlock()

        mock.lockGetLuaPluginNames.Lock()
        mock.calls.GetLuaPluginNames = nil
        mock.lockGetLuaPluginNames.Unlock()

        mock.lockIsApprovedUser.Lock()
        mock.calls.IsApprovedUser = nil
        mock.lockIsApprovedUser.Unlock()

        mock.lockLoadSamples.Lock()
        mock.calls.LoadSamples = nil
        mock.lockLoadSamples.Unlock()

        mock.lockLoadStopWords.Lock()
        mock.calls.LoadStopWords = nil
        mock.lockLoadStopWords.Unlock()

        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = nil
        mock.lockRemoveApprovedUser.Unlock()

        mock.lockRemoveHam.Lock()
        mock.calls.RemoveHam = nil
        mock.lockRemoveHam.Unlock()

        mock.lockRemoveSpam.Lock()
        mock.calls.RemoveSpam = nil
        mock.lockRemoveSpam.Unlock()

        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = nil
        mock.lockUpdateHam.Unlock()

        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = nil
        mock.lockUpdateSpam.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/umputun/tg-spam/app/storage"
        "io"
        "sync"
)

// DictStoreMock is a mock implementation of bot.DictStore.
//
//        func TestSomethingThatUsesDictStore(t *testing.T) {
//
//                // make and configure a mocked bot.DictStore
//                mockedDictStore := &amp;DictStoreMock{
//                        ReaderFunc: func(ctx context.Context, t storage.DictionaryType) (io.ReadCloser, error) {
//                                panic("mock out the Reader method")
//                        },
//                }
//
//                // use mockedDictStore in code that requires bot.DictStore
//                // and then make assertions.
//
//        }
type DictStoreMock struct {
        // ReaderFunc mocks the Reader method.
        ReaderFunc func(ctx context.Context, t storage.DictionaryType) (io.ReadCloser, error)

        // calls tracks calls to the methods.
        calls struct {
                // Reader holds details about calls to the Reader method.
                Reader []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // T is the t argument value.
                        T storage.DictionaryType
                }
        }
        lockReader sync.RWMutex
}

// Reader calls ReaderFunc.
func (mock *DictStoreMock) Reader(ctx context.Context, t storage.DictionaryType) (io.ReadCloser, error) <span class="cov0" title="0">{
        if mock.ReaderFunc == nil </span><span class="cov0" title="0">{
                panic("DictStoreMock.ReaderFunc: method is nil but DictStore.Reader was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                T   storage.DictionaryType
        }{
                Ctx: ctx,
                T:   t,
        }
        mock.lockReader.Lock()
        mock.calls.Reader = append(mock.calls.Reader, callInfo)
        mock.lockReader.Unlock()
        return mock.ReaderFunc(ctx, t)</span>
}

// ReaderCalls gets all the calls that were made to Reader.
// Check the length with:
//
//        len(mockedDictStore.ReaderCalls())
func (mock *DictStoreMock) ReaderCalls() []struct {
        Ctx context.Context
        T   storage.DictionaryType
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                T   storage.DictionaryType
        }
        mock.lockReader.RLock()
        calls = mock.calls.Reader
        mock.lockReader.RUnlock()
        return calls
}</span>

// ResetReaderCalls reset all the calls that were made to Reader.
func (mock *DictStoreMock) ResetReaderCalls() <span class="cov0" title="0">{
        mock.lockReader.Lock()
        mock.calls.Reader = nil
        mock.lockReader.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *DictStoreMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockReader.Lock()
        mock.calls.Reader = nil
        mock.lockReader.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/umputun/tg-spam/app/storage"
        "io"
        "sync"
)

// SamplesStoreMock is a mock implementation of bot.SamplesStore.
//
//        func TestSomethingThatUsesSamplesStore(t *testing.T) {
//
//                // make and configure a mocked bot.SamplesStore
//                mockedSamplesStore := &amp;SamplesStoreMock{
//                        ReadFunc: func(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) ([]string, error) {
//                                panic("mock out the Read method")
//                        },
//                        ReaderFunc: func(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) (io.ReadCloser, error) {
//                                panic("mock out the Reader method")
//                        },
//                        StatsFunc: func(ctx context.Context) (*storage.SamplesStats, error) {
//                                panic("mock out the Stats method")
//                        },
//                }
//
//                // use mockedSamplesStore in code that requires bot.SamplesStore
//                // and then make assertions.
//
//        }
type SamplesStoreMock struct {
        // ReadFunc mocks the Read method.
        ReadFunc func(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) ([]string, error)

        // ReaderFunc mocks the Reader method.
        ReaderFunc func(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) (io.ReadCloser, error)

        // StatsFunc mocks the Stats method.
        StatsFunc func(ctx context.Context) (*storage.SamplesStats, error)

        // calls tracks calls to the methods.
        calls struct {
                // Read holds details about calls to the Read method.
                Read []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // T is the t argument value.
                        T storage.SampleType
                        // O is the o argument value.
                        O storage.SampleOrigin
                }
                // Reader holds details about calls to the Reader method.
                Reader []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // T is the t argument value.
                        T storage.SampleType
                        // O is the o argument value.
                        O storage.SampleOrigin
                }
                // Stats holds details about calls to the Stats method.
                Stats []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
        }
        lockRead   sync.RWMutex
        lockReader sync.RWMutex
        lockStats  sync.RWMutex
}

// Read calls ReadFunc.
func (mock *SamplesStoreMock) Read(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) ([]string, error) <span class="cov0" title="0">{
        if mock.ReadFunc == nil </span><span class="cov0" title="0">{
                panic("SamplesStoreMock.ReadFunc: method is nil but SamplesStore.Read was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                T   storage.SampleType
                O   storage.SampleOrigin
        }{
                Ctx: ctx,
                T:   t,
                O:   o,
        }
        mock.lockRead.Lock()
        mock.calls.Read = append(mock.calls.Read, callInfo)
        mock.lockRead.Unlock()
        return mock.ReadFunc(ctx, t, o)</span>
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//        len(mockedSamplesStore.ReadCalls())
func (mock *SamplesStoreMock) ReadCalls() []struct {
        Ctx context.Context
        T   storage.SampleType
        O   storage.SampleOrigin
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                T   storage.SampleType
                O   storage.SampleOrigin
        }
        mock.lockRead.RLock()
        calls = mock.calls.Read
        mock.lockRead.RUnlock()
        return calls
}</span>

// ResetReadCalls reset all the calls that were made to Read.
func (mock *SamplesStoreMock) ResetReadCalls() <span class="cov0" title="0">{
        mock.lockRead.Lock()
        mock.calls.Read = nil
        mock.lockRead.Unlock()
}</span>

// Reader calls ReaderFunc.
func (mock *SamplesStoreMock) Reader(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) (io.ReadCloser, error) <span class="cov0" title="0">{
        if mock.ReaderFunc == nil </span><span class="cov0" title="0">{
                panic("SamplesStoreMock.ReaderFunc: method is nil but SamplesStore.Reader was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                T   storage.SampleType
                O   storage.SampleOrigin
        }{
                Ctx: ctx,
                T:   t,
                O:   o,
        }
        mock.lockReader.Lock()
        mock.calls.Reader = append(mock.calls.Reader, callInfo)
        mock.lockReader.Unlock()
        return mock.ReaderFunc(ctx, t, o)</span>
}

// ReaderCalls gets all the calls that were made to Reader.
// Check the length with:
//
//        len(mockedSamplesStore.ReaderCalls())
func (mock *SamplesStoreMock) ReaderCalls() []struct {
        Ctx context.Context
        T   storage.SampleType
        O   storage.SampleOrigin
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                T   storage.SampleType
                O   storage.SampleOrigin
        }
        mock.lockReader.RLock()
        calls = mock.calls.Reader
        mock.lockReader.RUnlock()
        return calls
}</span>

// ResetReaderCalls reset all the calls that were made to Reader.
func (mock *SamplesStoreMock) ResetReaderCalls() <span class="cov0" title="0">{
        mock.lockReader.Lock()
        mock.calls.Reader = nil
        mock.lockReader.Unlock()
}</span>

// Stats calls StatsFunc.
func (mock *SamplesStoreMock) Stats(ctx context.Context) (*storage.SamplesStats, error) <span class="cov0" title="0">{
        if mock.StatsFunc == nil </span><span class="cov0" title="0">{
                panic("SamplesStoreMock.StatsFunc: method is nil but SamplesStore.Stats was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockStats.Lock()
        mock.calls.Stats = append(mock.calls.Stats, callInfo)
        mock.lockStats.Unlock()
        return mock.StatsFunc(ctx)</span>
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//        len(mockedSamplesStore.StatsCalls())
func (mock *SamplesStoreMock) StatsCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockStats.RLock()
        calls = mock.calls.Stats
        mock.lockStats.RUnlock()
        return calls
}</span>

// ResetStatsCalls reset all the calls that were made to Stats.
func (mock *SamplesStoreMock) ResetStatsCalls() <span class="cov0" title="0">{
        mock.lockStats.Lock()
        mock.calls.Stats = nil
        mock.lockStats.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SamplesStoreMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockRead.Lock()
        mock.calls.Read = nil
        mock.lockRead.Unlock()

        mock.lockReader.Lock()
        mock.calls.Reader = nil
        mock.lockReader.Unlock()

        mock.lockStats.Lock()
        mock.calls.Stats = nil
        mock.lockStats.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package bot

import (
        "context"
        "fmt"
        "io"
        "log"
        "strconv"
        "strings"

        "github.com/hashicorp/go-multierror"

        "github.com/umputun/tg-spam/app/storage"
        "github.com/umputun/tg-spam/lib/approved"
        "github.com/umputun/tg-spam/lib/spamcheck"
        "github.com/umputun/tg-spam/lib/tgspam"
)

//go:generate moq --out mocks/detector.go --pkg mocks --skip-ensure --with-resets . Detector
//go:generate moq --out mocks/samples.go --pkg mocks --skip-ensure --with-resets . SamplesStore
//go:generate moq --out mocks/dictionary.go --pkg mocks --skip-ensure --with-resets . DictStore

// SpamFilter bot checks if a user is a spammer using lib.Detector
// Reloads spam samples, stop words and excluded tokens on file change.
type SpamFilter struct {
        Detector
        params SpamConfig
}

// SpamConfig is a full set of parameters for spam bot
type SpamConfig struct {
        SamplesStore SamplesStore // storage for spam samples
        DictStore    DictStore    // storage for stop words and excluded tokens

        SpamMsg    string
        SpamDryMsg string
        GroupID    string
        Dry        bool
}

// Detector is a spam detector interface
type Detector interface {
        Check(request spamcheck.Request) (spam bool, cr []spamcheck.Response)
        LoadSamples(exclReader io.Reader, spamReaders, hamReaders []io.Reader) (tgspam.LoadResult, error)
        LoadStopWords(readers ...io.Reader) (tgspam.LoadResult, error)
        UpdateSpam(msg string) error
        UpdateHam(msg string) error
        RemoveHam(msg string) error
        RemoveSpam(msg string) error
        AddApprovedUser(user approved.UserInfo) error
        RemoveApprovedUser(id string) error
        ApprovedUsers() (res []approved.UserInfo)
        IsApprovedUser(userID string) bool
        GetLuaPluginNames() []string // Returns the list of available Lua plugin names
}

// SamplesStore is a storage for spam samples
type SamplesStore interface {
        Read(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) ([]string, error)
        Reader(ctx context.Context, t storage.SampleType, o storage.SampleOrigin) (io.ReadCloser, error)
        Stats(ctx context.Context) (*storage.SamplesStats, error)
}

// DictStore is a storage for dictionaries, i.e. stop words and ignored words
type DictStore interface {
        Reader(ctx context.Context, t storage.DictionaryType) (io.ReadCloser, error)
}

// NewSpamFilter creates new spam filter
func NewSpamFilter(detector Detector, params SpamConfig) *SpamFilter <span class="cov10" title="34">{
        return &amp;SpamFilter{Detector: detector, params: params}
}</span>

// OnMessage checks if user already approved and if not checks if user is a spammer
func (s *SpamFilter) OnMessage(msg Message, checkOnly bool) (response Response) <span class="cov6" title="9">{
        if msg.From.ID == 0 </span><span class="cov2" title="2">{ // don't check system messages
                return Response{}
        }</span>
        <span class="cov5" title="7">displayUsername := DisplayName(msg)

        spamReq := spamcheck.Request{Msg: msg.Text, CheckOnly: checkOnly,
                UserID: strconv.FormatInt(msg.From.ID, 10), UserName: msg.From.Username}
        if msg.Image != nil </span><span class="cov1" title="1">{
                spamReq.Meta.Images = 1
        }</span>
        <span class="cov5" title="7">if msg.WithVideo || msg.WithVideoNote </span><span class="cov2" title="2">{
                spamReq.Meta.HasVideo = true
        }</span>
        <span class="cov5" title="7">if msg.WithAudio </span><span class="cov0" title="0">{
                spamReq.Meta.HasAudio = true
        }</span>
        <span class="cov5" title="7">if msg.WithForward </span><span class="cov1" title="1">{
                spamReq.Meta.HasForward = true
        }</span>
        <span class="cov5" title="7">if msg.WithKeyboard </span><span class="cov0" title="0">{
                spamReq.Meta.HasKeyboard = true
        }</span>
        <span class="cov5" title="7">spamReq.Meta.Links = strings.Count(msg.Text, "http://") + strings.Count(msg.Text, "https://")

        // count mentions from entities
        if msg.Entities != nil </span><span class="cov0" title="0">{
                for _, entity := range *msg.Entities </span><span class="cov0" title="0">{
                        if entity.Type == "mention" || entity.Type == "text_mention" </span><span class="cov0" title="0">{
                                spamReq.Meta.Mentions++
                        }</span>
                }
        }
        <span class="cov5" title="7">isSpam, checkResults := s.Check(spamReq)
        crs := []string{}
        for _, cr := range checkResults </span><span class="cov5" title="7">{
                crs = append(crs, fmt.Sprintf("{name: %s, spam: %v, details: %s}", cr.Name, cr.Spam, cr.Details))
        }</span>
        <span class="cov5" title="7">checkResultStr := strings.Join(crs, ", ")
        if isSpam </span><span class="cov5" title="6">{
                log.Printf("[INFO] user %s detected as spammer: %s, %q", displayUsername, checkResultStr, msg.Text)
                msgPrefix := s.params.SpamMsg
                if s.params.Dry </span><span class="cov1" title="1">{
                        msgPrefix = s.params.SpamDryMsg
                }</span>
                <span class="cov5" title="6">spamRespMsg := fmt.Sprintf("%s: %q (%d)", msgPrefix, displayUsername, msg.From.ID)
                return Response{Text: spamRespMsg, Send: true, ReplyTo: msg.ID, BanInterval: PermanentBanDuration, CheckResults: checkResults,
                        DeleteReplyTo: true, User: User{Username: msg.From.Username, ID: msg.From.ID, DisplayName: msg.From.DisplayName},
                }</span>
        }
        <span class="cov1" title="1">log.Printf("[DEBUG] user %s is not a spammer, %s", displayUsername, checkResultStr)
        return Response{CheckResults: checkResults}</span> // not a spam
}

// UpdateSpam appends a message to the spam samples file and updates the classifier
func (s *SpamFilter) UpdateSpam(msg string) error <span class="cov2" title="2">{
        cleanMsg := strings.ReplaceAll(msg, "\n", " ")
        log.Printf("[DEBUG] update spam samples with %q", cleanMsg)
        if err := s.Detector.UpdateSpam(cleanMsg); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("can't update spam samples: %w", err)
        }</span>
        <span class="cov1" title="1">log.Printf("[INFO] updated spam samples with %q", cleanMsg)
        return nil</span>
}

// UpdateHam appends a message to the ham samples file and updates the classifier
func (s *SpamFilter) UpdateHam(msg string) error <span class="cov2" title="2">{
        cleanMsg := strings.ReplaceAll(msg, "\n", " ")
        log.Printf("[DEBUG] update ham samples with %q", cleanMsg)
        if err := s.Detector.UpdateHam(cleanMsg); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("can't update ham samples: %w", err)
        }</span>
        <span class="cov1" title="1">log.Printf("[INFO] updated ham samples with %q", cleanMsg)
        return nil</span>
}

// IsApprovedUser checks if user is in the list of approved users
func (s *SpamFilter) IsApprovedUser(userID int64) bool <span class="cov4" title="4">{
        return s.Detector.IsApprovedUser(fmt.Sprintf("%d", userID))
}</span>

// AddApprovedUser adds users to the list of approved users, to both the detector and the storage
func (s *SpamFilter) AddApprovedUser(id int64, name string) error <span class="cov2" title="2">{
        log.Printf("[INFO] add aproved user: id:%d, name:%q", id, name)
        if err := s.Detector.AddApprovedUser(approved.UserInfo{UserID: fmt.Sprintf("%d", id), UserName: name}); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to write approved user to storage: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// RemoveApprovedUser removes users from the list of approved users in both the detector and the storage
func (s *SpamFilter) RemoveApprovedUser(id int64) error <span class="cov2" title="2">{
        log.Printf("[INFO] remove aproved user: %d", id)
        if err := s.Detector.RemoveApprovedUser(fmt.Sprintf("%d", id)); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete approved user from storage: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ReloadSamples reloads samples and stop-words
func (s *SpamFilter) ReloadSamples() (err error) <span class="cov5" title="6">{
        log.Printf("[DEBUG] reloading samples")

        var exclReader, spamReader, hamReader, stopWordsReader, spamDynamicReader, hamDynamicReader io.ReadCloser
        ctx := context.TODO()

        // check mandatory data presence
        st, err := s.params.SamplesStore.Stats(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get samples store stats: %w", err)
        }</span>
        <span class="cov5" title="5">if st.PresetSpam == 0 || st.PresetHam == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no pesistent spam or ham samples found in the store")
        }</span>

        <span class="cov4" title="4">if spamReader, err = s.params.SamplesStore.Reader(ctx, storage.SampleTypeSpam, storage.SampleOriginPreset); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get persistent spam samples: %w", err)
        }</span>
        <span class="cov3" title="3">defer spamReader.Close()

        if hamReader, err = s.params.SamplesStore.Reader(ctx, storage.SampleTypeHam, storage.SampleOriginPreset); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get persistent ham samples: %w", err)
        }</span>
        <span class="cov3" title="3">defer hamReader.Close()

        if spamDynamicReader, err = s.params.SamplesStore.Reader(ctx, storage.SampleTypeSpam, storage.SampleOriginUser); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dynamic spam samples: %w", err)
        }</span>
        <span class="cov3" title="3">defer spamDynamicReader.Close()

        if hamDynamicReader, err = s.params.SamplesStore.Reader(ctx, storage.SampleTypeHam, storage.SampleOriginUser); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dynamic ham samples: %w", err)
        }</span>
        <span class="cov3" title="3">defer hamDynamicReader.Close()

        // stop-words are optional
        if stopWordsReader, err = s.params.DictStore.Reader(ctx, storage.DictionaryTypeStopPhrase); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get stop words: %w", err)
        }</span>
        <span class="cov3" title="3">defer stopWordsReader.Close()

        // excluded tokens are optional
        if exclReader, err = s.params.DictStore.Reader(ctx, storage.DictionaryTypeIgnoredWord); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get excluded tokens: %w", err)
        }</span>
        <span class="cov3" title="3">defer exclReader.Close()

        // reload samples and stop-words. note: we don't need reset as LoadSamples and LoadStopWords clear the state first
        lr, err := s.LoadSamples(exclReader, []io.Reader{spamReader, spamDynamicReader},
                []io.Reader{hamReader, hamDynamicReader})
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to reload samples: %w", err)
        }</span>

        <span class="cov2" title="2">ls, err := s.LoadStopWords(stopWordsReader)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to reload stop words: %w", err)
        }</span>

        <span class="cov1" title="1">log.Printf("[INFO] loaded samples - spam: %d, ham: %d, excluded tokens: %d, stop-words: %d",
                lr.SpamSamples, lr.HamSamples, lr.ExcludedTokens, ls.StopWords)

        return nil</span>
}

// DynamicSamples returns dynamic spam and ham samples. both are optional
func (s *SpamFilter) DynamicSamples() (spam, ham []string, err error) <span class="cov3" title="3">{
        errs := new(multierror.Error)

        if spam, err = s.params.SamplesStore.Read(context.TODO(), storage.SampleTypeSpam, storage.SampleOriginUser); err != nil </span><span class="cov1" title="1">{
                errs = multierror.Append(errs, fmt.Errorf("failed to read dynamic spam samples: %w", err))
        }</span>

        <span class="cov3" title="3">if ham, err = s.params.SamplesStore.Read(context.TODO(), storage.SampleTypeHam, storage.SampleOriginUser); err != nil </span><span class="cov1" title="1">{
                errs = multierror.Append(errs, fmt.Errorf("failed to read dynamic ham samples: %w", err))
        }</span>

        <span class="cov3" title="3">if err := errs.ErrorOrNil(); err != nil </span><span class="cov1" title="1">{
                return spam, ham, fmt.Errorf("failed to read dynamic samples: %w", err)
        }</span>
        <span class="cov2" title="2">return spam, ham, nil</span>
}

// RemoveDynamicSpamSample removes a sample from the spam dynamic samples file and reloads samples after this
func (s *SpamFilter) RemoveDynamicSpamSample(sample string) error <span class="cov4" title="4">{
        cleanMsg := strings.ReplaceAll(sample, "\n", " ")
        log.Printf("[INFO] remove dynamic spam sample: %q", sample)
        if err := s.RemoveSpam(cleanMsg); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("can't remove spam sample %q: %w", sample, err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// RemoveDynamicHamSample removes a sample from the ham dynamic samples file and reloads samples after this
func (s *SpamFilter) RemoveDynamicHamSample(sample string) error <span class="cov2" title="2">{
        cleanMsg := strings.ReplaceAll(sample, "\n", " ")
        log.Printf("[INFO] remove dynamic ham sample: %q", sample)
        if err := s.RemoveHam(cleanMsg); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("can't remove hma sample %q: %w", sample, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "log"
        "strings"

        "golang.org/x/crypto/argon2"
)

// EncryptPrefix is added to encrypted values to identify them
const EncryptPrefix = "ENC:"

// Sensitive field name constants
const (
        FieldTelegramToken  = "telegram.token"
        FieldOpenAIToken    = "openai.token"
        FieldServerAuthHash = "server.auth_hash"
        FieldServerAuthUser = "server.auth_user"
)

// MinKeyLength defines the minimum acceptable length for an encryption key
const MinKeyLength = 20

// Crypter handles encryption and decryption of sensitive fields
type Crypter struct {
        key []byte
        gid string // instance ID for salt generation
}

// Argon2 parameters for key derivation
const (
        argon2Time    = 3         // number of iterations (OWASP recommends at least 3)
        argon2Memory  = 64 * 1024 // memory usage in KiB (64MB)
        argon2Threads = 4         // number of threads
        argon2KeyLen  = 32        // output key length (for AES-256)
)

// NewCrypter creates a new encryption manager with the given key and instance ID
func NewCrypter(masterKey, instanceID string) (*Crypter, error) <span class="cov6" title="13">{
        if masterKey == "" </span><span class="cov1" title="1">{
                return nil, errors.New("empty master key")
        }</span>

        <span class="cov6" title="12">if len(masterKey) &lt; MinKeyLength </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("encryption key too short, minimum length is %d characters (use a high-entropy random value)", MinKeyLength)
        }</span>

        <span class="cov6" title="11">if instanceID == "" </span><span class="cov1" title="1">{
                return nil, errors.New("empty instance ID")
        }</span>

        // create a salt based on instance ID for consistency across restarts
        // this ensures different instances use different keys even with the same master key
        <span class="cov6" title="10">salt := []byte("tg-spam-config-encryption-salt-" + instanceID)

        // derive a proper cryptographic key using Argon2id
        key := argon2.IDKey(
                []byte(masterKey),
                salt,
                argon2Time,
                argon2Memory,
                argon2Threads,
                argon2KeyLen,
        )

        return &amp;Crypter{key: key, gid: instanceID}, nil</span>
}

// Encrypt encrypts a string value
func (c *Crypter) Encrypt(plaintext string) (string, error) <span class="cov7" title="18">{
        if plaintext == "" </span><span class="cov1" title="1">{
                return "", nil
        }</span>

        // create a new AES cipher block
        <span class="cov7" title="17">block, err := aes.NewCipher(c.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // create the GCM mode with the default nonce size
        <span class="cov7" title="17">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // create a nonce
        <span class="cov7" title="17">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // encrypt and append the nonce
        <span class="cov7" title="17">ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)

        // encode to base64 and add prefix
        return EncryptPrefix + base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// Decrypt decrypts a string value
func (c *Crypter) Decrypt(ciphertext string) (string, error) <span class="cov7" title="21">{
        // if not encrypted or empty, return as is
        if ciphertext == "" || !strings.HasPrefix(ciphertext, EncryptPrefix) </span><span class="cov1" title="1">{
                return ciphertext, nil
        }</span>

        // remove prefix and decode from base64
        <span class="cov7" title="20">data, err := base64.StdEncoding.DecodeString(strings.TrimPrefix(ciphertext, EncryptPrefix))
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode base64 data: %w", err)
        }</span>

        // create a new AES cipher block
        <span class="cov7" title="19">block, err := aes.NewCipher(c.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cipher for decryption: %w", err)
        }</span>

        // create the GCM mode
        <span class="cov7" title="19">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create GCM for decryption: %w", err)
        }</span>

        // the nonce is at the beginning of the ciphertext
        <span class="cov7" title="19">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov0" title="0">{
                return "", errors.New("ciphertext too short")
        }</span>

        <span class="cov7" title="19">nonce, ciphertextBytes := data[:nonceSize], data[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, ciphertextBytes, nil)
        if err != nil </span><span class="cov2" title="2">{
                return "", fmt.Errorf("failed to decrypt data: %w", err)
        }</span>

        <span class="cov7" title="17">return string(plaintext), nil</span>
}

// IsEncrypted checks if a value is encrypted
func IsEncrypted(value string) bool <span class="cov10" title="54">{
        return strings.HasPrefix(value, EncryptPrefix)
}</span>

// EncryptSensitiveFields encrypts sensitive fields in a Settings object
// It can encrypt default fields or custom fields specified in sensitiveFields
func (c *Crypter) EncryptSensitiveFields(settings *Settings, sensitiveFields ...string) error <span class="cov4" title="5">{
        if settings == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // if no custom fields provided, use the defaults
        <span class="cov4" title="5">fieldsToEncrypt := sensitiveFields
        if len(fieldsToEncrypt) == 0 </span><span class="cov1" title="1">{
                fieldsToEncrypt = defaultSensitiveFields()
        }</span>

        // process each sensitive field
        <span class="cov4" title="5">for _, field := range fieldsToEncrypt </span><span class="cov6" title="13">{
                switch field </span>{
                case FieldTelegramToken:<span class="cov4" title="5">
                        if settings.Telegram.Token != "" &amp;&amp; !IsEncrypted(settings.Telegram.Token) </span><span class="cov4" title="5">{
                                encrypted, err := c.Encrypt(settings.Telegram.Token)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to encrypt Telegram token: %w", err)
                                }</span>
                                <span class="cov4" title="5">settings.Telegram.Token = encrypted</span>
                        }
                case FieldOpenAIToken:<span class="cov3" title="3">
                        if settings.OpenAI.Token != "" &amp;&amp; !IsEncrypted(settings.OpenAI.Token) </span><span class="cov3" title="3">{
                                encrypted, err := c.Encrypt(settings.OpenAI.Token)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to encrypt OpenAI token: %w", err)
                                }</span>
                                <span class="cov3" title="3">settings.OpenAI.Token = encrypted</span>
                        }
                case FieldServerAuthHash:<span class="cov3" title="3">
                        if settings.Server.AuthHash != "" &amp;&amp; !IsEncrypted(settings.Server.AuthHash) </span><span class="cov3" title="3">{
                                encrypted, err := c.Encrypt(settings.Server.AuthHash)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to encrypt Server auth hash: %w", err)
                                }</span>
                                <span class="cov3" title="3">settings.Server.AuthHash = encrypted</span>
                        }
                case FieldServerAuthUser:<span class="cov2" title="2">
                        if settings.Server.AuthUser != "" &amp;&amp; !IsEncrypted(settings.Server.AuthUser) </span><span class="cov2" title="2">{
                                encrypted, err := c.Encrypt(settings.Server.AuthUser)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to encrypt Server auth user: %w", err)
                                }</span>
                                <span class="cov2" title="2">settings.Server.AuthUser = encrypted</span>
                        }
                default:<span class="cov0" title="0">
                        log.Printf("[WARN] unknown sensitive field: %s", field)</span>
                }
        }

        <span class="cov4" title="5">return nil</span>
}

// DecryptSensitiveFields decrypts sensitive fields in a Settings object
// It can decrypt default fields or custom fields specified in sensitiveFields
func (c *Crypter) DecryptSensitiveFields(settings *Settings, sensitiveFields ...string) error <span class="cov4" title="5">{
        if settings == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // if no custom fields provided, use the defaults
        <span class="cov4" title="5">fieldsToDecrypt := sensitiveFields
        if len(fieldsToDecrypt) == 0 </span><span class="cov1" title="1">{
                fieldsToDecrypt = defaultSensitiveFields()
        }</span>

        // process each sensitive field
        <span class="cov4" title="5">var decryptErrs []error

        for _, field := range fieldsToDecrypt </span><span class="cov6" title="13">{
                switch field </span>{
                case FieldTelegramToken:<span class="cov4" title="5">
                        if IsEncrypted(settings.Telegram.Token) </span><span class="cov4" title="5">{
                                decrypted, err := c.Decrypt(settings.Telegram.Token)
                                if err != nil </span><span class="cov0" title="0">{
                                        decryptErrs = append(decryptErrs, fmt.Errorf("failed to decrypt Telegram token: %w", err))
                                        log.Printf("[WARN] failed to decrypt Telegram token: %v", err)
                                }</span> else<span class="cov4" title="5"> {
                                        settings.Telegram.Token = decrypted
                                }</span>
                        }
                case FieldOpenAIToken:<span class="cov3" title="3">
                        if IsEncrypted(settings.OpenAI.Token) </span><span class="cov3" title="3">{
                                decrypted, err := c.Decrypt(settings.OpenAI.Token)
                                if err != nil </span><span class="cov0" title="0">{
                                        decryptErrs = append(decryptErrs, fmt.Errorf("failed to decrypt OpenAI token: %w", err))
                                        log.Printf("[WARN] failed to decrypt OpenAI token: %v", err)
                                }</span> else<span class="cov3" title="3"> {
                                        settings.OpenAI.Token = decrypted
                                }</span>
                        }
                case FieldServerAuthHash:<span class="cov3" title="3">
                        if IsEncrypted(settings.Server.AuthHash) </span><span class="cov3" title="3">{
                                decrypted, err := c.Decrypt(settings.Server.AuthHash)
                                if err != nil </span><span class="cov0" title="0">{
                                        decryptErrs = append(decryptErrs, fmt.Errorf("failed to decrypt Server auth hash: %w", err))
                                        log.Printf("[WARN] failed to decrypt Server auth hash: %v", err)
                                }</span> else<span class="cov3" title="3"> {
                                        settings.Server.AuthHash = decrypted
                                }</span>
                        }
                case FieldServerAuthUser:<span class="cov2" title="2">
                        if IsEncrypted(settings.Server.AuthUser) </span><span class="cov2" title="2">{
                                decrypted, err := c.Decrypt(settings.Server.AuthUser)
                                if err != nil </span><span class="cov0" title="0">{
                                        decryptErrs = append(decryptErrs, fmt.Errorf("failed to decrypt Server auth user: %w", err))
                                        log.Printf("[WARN] failed to decrypt Server auth user: %v", err)
                                }</span> else<span class="cov2" title="2"> {
                                        settings.Server.AuthUser = decrypted
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        log.Printf("[WARN] unknown sensitive field: %s", field)</span>
                }
        }

        // return a combined error if any decryption failures occurred
        <span class="cov4" title="5">if len(decryptErrs) &gt; 0 </span><span class="cov0" title="0">{
                var combinedErr error
                for _, err := range decryptErrs </span><span class="cov0" title="0">{
                        if combinedErr == nil </span><span class="cov0" title="0">{
                                combinedErr = err
                        }</span> else<span class="cov0" title="0"> {
                                combinedErr = fmt.Errorf("%v; %w", combinedErr, err)
                        }</span>
                }
                <span class="cov0" title="0">return combinedErr</span>
        }

        <span class="cov4" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "time"
)

// Settings represents application configuration independent of source (CLI, DB, etc)
type Settings struct {
        // core settings
        InstanceID string `json:"instance_id" yaml:"instance_id" db:"instance_id"`

        // group settings by domain
        Telegram      TelegramSettings      `json:"telegram" yaml:"telegram" db:"telegram"`
        Admin         AdminSettings         `json:"admin" yaml:"admin" db:"admin"`
        History       HistorySettings       `json:"history" yaml:"history" db:"history"`
        Logger        LoggerSettings        `json:"logger" yaml:"logger" db:"logger"`
        CAS           CASSettings           `json:"cas" yaml:"cas" db:"cas"`
        Meta          MetaSettings          `json:"meta" yaml:"meta" db:"meta"`
        OpenAI        OpenAISettings        `json:"openai" yaml:"openai" db:"openai"`
        LuaPlugins    LuaPluginsSettings    `json:"lua_plugins" yaml:"lua_plugins" db:"lua_plugins"`
        AbnormalSpace AbnormalSpaceSettings `json:"abnormal_spacing" yaml:"abnormal_spacing" db:"abnormal_spacing"`
        Files         FilesSettings         `json:"files" yaml:"files" db:"files"`
        Message       MessageSettings       `json:"message" yaml:"message" db:"message"`
        Server        ServerSettings        `json:"server" yaml:"server" db:"server"`

        // spam detection settings
        SimilarityThreshold float64 `json:"similarity_threshold" yaml:"similarity_threshold" db:"similarity_threshold"`
        MinMsgLen           int     `json:"min_msg_len" yaml:"min_msg_len" db:"min_msg_len"`
        MaxEmoji            int     `json:"max_emoji" yaml:"max_emoji" db:"max_emoji"`
        MinSpamProbability  float64 `json:"min_spam_probability" yaml:"min_spam_probability" db:"min_spam_probability"`
        MultiLangWords      int     `json:"multi_lang_words" yaml:"multi_lang_words" db:"multi_lang_words"`

        // bot behavior settings
        NoSpamReply         bool `json:"no_spam_reply" yaml:"no_spam_reply" db:"no_spam_reply"`
        SuppressJoinMessage bool `json:"suppress_join_message" yaml:"suppress_join_message" db:"suppress_join_message"`

        // detection mode settings
        ParanoidMode       bool `json:"paranoid_mode" yaml:"paranoid_mode" db:"paranoid_mode"`
        FirstMessagesCount int  `json:"first_messages_count" yaml:"first_messages_count" db:"first_messages_count"`

        // operation mode settings
        Training   bool   `json:"training" yaml:"training" db:"training_mode"`
        SoftBan    bool   `json:"soft_ban" yaml:"soft_ban" db:"soft_ban_mode"`
        Convert    string `json:"convert" yaml:"convert" db:"convert_mode"`
        MaxBackups int    `json:"max_backups" yaml:"max_backups" db:"max_backups"`
        Dry        bool   `json:"dry" yaml:"dry" db:"dry_mode"`

        // transient fields that should never be stored
        Transient TransientSettings `json:"-" yaml:"-"`
}

// TelegramSettings contains Telegram-specific settings
type TelegramSettings struct {
        Group        string        `json:"group" yaml:"group" db:"telegram_group"`
        IdleDuration time.Duration `json:"idle_duration" yaml:"idle_duration" db:"telegram_idle_duration"`
        Timeout      time.Duration `json:"timeout" yaml:"timeout" db:"telegram_timeout"`
        Token        string        `json:"token" yaml:"token" db:"telegram_token"`
}

// AdminSettings contains admin-related settings
type AdminSettings struct {
        AdminGroup              string   `json:"admin_group" yaml:"admin_group" db:"admin_group"`
        DisableAdminSpamForward bool     `json:"disable_admin_spam_forward" yaml:"disable_admin_spam_forward" db:"disable_admin_spam_forward"`
        TestingIDs              []int64  `json:"testing_ids" yaml:"testing_ids" db:"testing_ids"`
        SuperUsers              []string `json:"super_users" yaml:"super_users" db:"super_users"`
}

// HistorySettings contains history-related settings
type HistorySettings struct {
        Duration time.Duration `json:"duration" yaml:"duration" db:"history_duration"`
        MinSize  int           `json:"min_size" yaml:"min_size" db:"history_min_size"`
        Size     int           `json:"size" yaml:"size" db:"history_size"`
}

// LoggerSettings contains logging-related settings
type LoggerSettings struct {
        Enabled    bool   `json:"enabled" yaml:"enabled" db:"logger_enabled"`
        FileName   string `json:"file_name" yaml:"file_name" db:"logger_file_name"`
        MaxSize    string `json:"max_size" yaml:"max_size" db:"logger_max_size"`
        MaxBackups int    `json:"max_backups" yaml:"max_backups" db:"logger_max_backups"`
}

// CASSettings contains Combot Anti-Spam System settings
type CASSettings struct {
        API       string        `json:"api" yaml:"api" db:"cas_api"`
        Timeout   time.Duration `json:"timeout" yaml:"timeout" db:"cas_timeout"`
        UserAgent string        `json:"user_agent" yaml:"user_agent" db:"cas_user_agent"`
}

// MetaSettings contains message metadata check settings
type MetaSettings struct {
        LinksLimit      int    `json:"links_limit" yaml:"links_limit" db:"meta_links_limit"`
        MentionsLimit   int    `json:"mentions_limit" yaml:"mentions_limit" db:"meta_mentions_limit"`
        ImageOnly       bool   `json:"image_only" yaml:"image_only" db:"meta_image_only"`
        LinksOnly       bool   `json:"links_only" yaml:"links_only" db:"meta_links_only"`
        VideosOnly      bool   `json:"videos_only" yaml:"videos_only" db:"meta_videos_only"`
        AudiosOnly      bool   `json:"audios_only" yaml:"audios_only" db:"meta_audios_only"`
        Forward         bool   `json:"forward" yaml:"forward" db:"meta_forward"`
        Keyboard        bool   `json:"keyboard" yaml:"keyboard" db:"meta_keyboard"`
        UsernameSymbols string `json:"username_symbols" yaml:"username_symbols" db:"meta_username_symbols"`
}

// OpenAISettings contains OpenAI integration settings
type OpenAISettings struct {
        APIBase           string   `json:"api_base" yaml:"api_base" db:"openai_api_base"`
        Veto              bool     `json:"veto" yaml:"veto" db:"openai_veto"`
        Prompt            string   `json:"prompt" yaml:"prompt" db:"openai_prompt"`
        CustomPrompts     []string `json:"custom_prompts" yaml:"custom_prompts" db:"openai_custom_prompts"`
        Model             string   `json:"model" yaml:"model" db:"openai_model"`
        Token             string   `json:"token" yaml:"token" db:"openai_token"`
        MaxTokensResponse int      `json:"max_tokens_response" yaml:"max_tokens_response" db:"openai_max_tokens_response"`
        MaxTokensRequest  int      `json:"max_tokens_request" yaml:"max_tokens_request" db:"openai_max_tokens_request"`
        MaxSymbolsRequest int      `json:"max_symbols_request" yaml:"max_symbols_request" db:"openai_max_symbols_request"`
        RetryCount        int      `json:"retry_count" yaml:"retry_count" db:"openai_retry_count"`
        HistorySize       int      `json:"history_size" yaml:"history_size" db:"openai_history_size"`
        ReasoningEffort   string   `json:"reasoning_effort" yaml:"reasoning_effort" db:"openai_reasoning_effort"`
}

// LuaPluginsSettings contains Lua plugins settings
type LuaPluginsSettings struct {
        Enabled        bool     `json:"enabled" yaml:"enabled" db:"lua_plugins_enabled"`
        PluginsDir     string   `json:"plugins_dir" yaml:"plugins_dir" db:"lua_plugins_dir"`
        EnabledPlugins []string `json:"enabled_plugins" yaml:"enabled_plugins" db:"lua_enabled_plugins"`
        DynamicReload  bool     `json:"dynamic_reload" yaml:"dynamic_reload" db:"lua_dynamic_reload"`
}

// AbnormalSpaceSettings contains abnormal spacing detection settings
type AbnormalSpaceSettings struct {
        Enabled                 bool    `json:"enabled" yaml:"enabled" db:"abnormal_spacing_enabled"`
        SpaceRatioThreshold     float64 `json:"space_ratio_threshold" yaml:"space_ratio_threshold" db:"abnormal_spacing_ratio"`
        ShortWordRatioThreshold float64 `json:"short_word_ratio_threshold" yaml:"short_word_ratio_threshold" db:"abnormal_spacing_short_ratio"`
        ShortWordLen            int     `json:"short_word_len" yaml:"short_word_len" db:"abnormal_spacing_short_word"`
        MinWords                int     `json:"min_words" yaml:"min_words" db:"abnormal_spacing_min_words"`
}

// FilesSettings contains file location settings
type FilesSettings struct {
        SamplesDataPath string `json:"samples_data_path" yaml:"samples_data_path" db:"files_samples_path"`
        DynamicDataPath string `json:"dynamic_data_path" yaml:"dynamic_data_path" db:"files_dynamic_path"`
        WatchInterval   int    `json:"watch_interval_secs" yaml:"watch_interval_secs" db:"files_watch_interval_secs"`
}

// MessageSettings contains message customization settings
type MessageSettings struct {
        Startup string `json:"startup" yaml:"startup" db:"message_startup"`
        Spam    string `json:"spam" yaml:"spam" db:"message_spam"`
        Dry     string `json:"dry" yaml:"dry" db:"message_dry"`
        Warn    string `json:"warn" yaml:"warn" db:"message_warn"`
}

// ServerSettings contains web server settings
type ServerSettings struct {
        Enabled    bool   `json:"enabled" yaml:"enabled" db:"server_enabled"`
        ListenAddr string `json:"listen_addr" yaml:"listen_addr" db:"server_listen_addr"`
        AuthUser   string `json:"auth_user" yaml:"auth_user" db:"server_auth_user"`
        AuthHash   string `json:"auth_hash" yaml:"auth_hash" db:"server_auth_hash"`
}

// TransientSettings contains settings that should never be persisted
type TransientSettings struct {
        // connection parameters
        DataBaseURL    string        `json:"-" yaml:"-"`
        StorageTimeout time.Duration `json:"-" yaml:"-"`

        // control flags
        ConfigDB bool `json:"-" yaml:"-"`
        Dbg      bool `json:"-" yaml:"-"`
        TGDbg    bool `json:"-" yaml:"-"`

        // encryption for database stored configuration
        ConfigDBEncryptKey string `json:"-" yaml:"-"`

        // temporary auth password (used only to generate hash)
        WebAuthPasswd string `json:"-" yaml:"-"`
}

// New creates a new settings instance
func New() *Settings <span class="cov10" title="48">{
        return &amp;Settings{}
}</span>

// IsOpenAIEnabled returns true if OpenAI integration is enabled
func (s *Settings) IsOpenAIEnabled() bool <span class="cov4" title="4">{
        return s.OpenAI.APIBase != "" || s.OpenAI.Token != ""
}</span>

// IsMetaEnabled returns true if any meta check is enabled
func (s *Settings) IsMetaEnabled() bool <span class="cov6" title="11">{
        return s.Meta.ImageOnly ||
                s.Meta.LinksLimit &gt;= 0 ||
                s.Meta.MentionsLimit &gt;= 0 ||
                s.Meta.LinksOnly ||
                s.Meta.VideosOnly ||
                s.Meta.AudiosOnly ||
                s.Meta.Forward ||
                s.Meta.Keyboard ||
                s.Meta.UsernameSymbols != ""
}</span>

// IsCASEnabled returns true if CAS integration is enabled
func (s *Settings) IsCASEnabled() bool <span class="cov2" title="2">{
        return s.CAS.API != ""
}</span>

// IsStartupMessageEnabled returns true if a startup message is configured
func (s *Settings) IsStartupMessageEnabled() bool <span class="cov2" title="2">{
        return s.Message.Startup != ""
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "github.com/jmoiron/sqlx"

        "github.com/umputun/tg-spam/app/storage/engine"
)

// Store provides access to settings stored in database
type Store struct {
        *engine.SQL
        engine.RWLocker
        crypter         *Crypter
        sensitiveFields []string
}

// all config queries
const (
        CmdCreateConfigTable engine.DBCmd = iota + 1000
        CmdCreateConfigIndexes
        CmdUpsertConfig
        CmdSelectConfig
        CmdDeleteConfig
        CmdSelectConfigUpdatedAt
        CmdCountConfig
)

// queries holds all config queries
var configQueries = engine.NewQueryMap().
        Add(CmdCreateConfigTable, engine.Query{
                Sqlite: `CREATE TABLE IF NOT EXISTS config (
                        id INTEGER PRIMARY KEY,
                        gid TEXT NOT NULL,
                        data TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(gid)
                )`,
                Postgres: `CREATE TABLE IF NOT EXISTS config (
                        id SERIAL PRIMARY KEY,
                        gid TEXT NOT NULL,
                        data TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(gid)
                )`,
        }).
        AddSame(CmdCreateConfigIndexes, `CREATE INDEX IF NOT EXISTS idx_config_gid ON config(gid)`).
        Add(CmdUpsertConfig, engine.Query{
                Sqlite: `INSERT INTO config (gid, data, updated_at) 
                        VALUES (?, ?, ?) 
                        ON CONFLICT (gid) DO UPDATE 
                        SET data = excluded.data, updated_at = excluded.updated_at`,
                Postgres: `INSERT INTO config (gid, data, updated_at) 
                        VALUES ($1, $2, $3) 
                        ON CONFLICT (gid) DO UPDATE 
                        SET data = EXCLUDED.data, updated_at = EXCLUDED.updated_at`,
        }).
        AddSame(CmdSelectConfig, `SELECT data FROM config WHERE gid = ?`).
        AddSame(CmdDeleteConfig, `DELETE FROM config WHERE gid = ?`).
        AddSame(CmdSelectConfigUpdatedAt, `SELECT updated_at FROM config WHERE gid = ?`).
        AddSame(CmdCountConfig, `SELECT COUNT(*) FROM config WHERE gid = ?`)

// NewStore creates a new settings store
func NewStore(ctx context.Context, db *engine.SQL, opts ...StoreOption) (*Store, error) <span class="cov9" title="21">{
        if db == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no db provided")
        }</span>

        // create store with default options
        <span class="cov9" title="20">res := &amp;Store{
                SQL:             db,
                RWLocker:        db.MakeLock(),
                sensitiveFields: defaultSensitiveFields(),
        }

        // apply options
        for _, opt := range opts </span><span class="cov6" title="6">{
                opt(res)
        }</span>

        // initialize the database table using the TableConfig pattern
        <span class="cov9" title="20">cfg := engine.TableConfig{
                Name:          "config",
                CreateTable:   CmdCreateConfigTable,
                CreateIndexes: CmdCreateConfigIndexes,
                MigrateFunc:   noopMigrate, // no migration needed for config table
                QueriesMap:    configQueries,
        }

        if err := engine.InitTable(ctx, db, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init config table: %w", err)
        }</span>

        <span class="cov9" title="20">return res, nil</span>
}

// StoreOption defines functional options for Store
type StoreOption func(*Store)

// WithCrypter adds a crypter to the store for field encryption
func WithCrypter(crypter *Crypter) StoreOption <span class="cov5" title="4">{
        return func(s *Store) </span><span class="cov5" title="4">{
                s.crypter = crypter
        }</span>
}

// WithSensitiveFields sets the list of sensitive fields to encrypt/decrypt
func WithSensitiveFields(fields []string) StoreOption <span class="cov3" title="2">{
        return func(s *Store) </span><span class="cov3" title="2">{
                s.sensitiveFields = fields
        }</span>
}

// defaultSensitiveFields returns the default list of sensitive fields
func defaultSensitiveFields() []string <span class="cov10" title="22">{
        return []string{
                FieldTelegramToken,  // telegram bot token
                FieldOpenAIToken,    // openAI API token
                FieldServerAuthHash, // server auth hash
        }
}</span>

// Load retrieves the settings from the database
func (s *Store) Load(ctx context.Context) (*Settings, error) <span class="cov9" title="18">{
        s.RLock()
        defer s.RUnlock()

        var record struct {
                Data string `db:"data"`
        }

        query, err := configQueries.Pick(s.Type(), CmdSelectConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get select query: %w", err)
        }</span>

        <span class="cov9" title="18">query = s.Adopt(query)
        err = s.GetContext(ctx, &amp;record, query, s.GID())
        if err != nil </span><span class="cov5" title="4">{
                if err.Error() == "sql: no rows in result set" </span><span class="cov5" title="4">{
                        return nil, fmt.Errorf("no settings found in database")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get settings: %w", err)</span>
        }

        <span class="cov8" title="14">result := New()
        if err := json.Unmarshal([]byte(record.Data), result); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to unmarshal settings: %w", err)
        }</span>

        // decrypt sensitive fields if crypter is configured
        <span class="cov8" title="12">if s.crypter != nil </span><span class="cov5" title="4">{
                if err := s.crypter.DecryptSensitiveFields(result, s.sensitiveFields...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decrypt sensitive fields: %w", err)
                }</span>
        }

        <span class="cov8" title="12">return result, nil</span>
}

// Save stores the settings to the database
func (s *Store) Save(ctx context.Context, settings *Settings) error <span class="cov9" title="16">{
        if s == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("store is nil")
        }</span>
        <span class="cov9" title="16">if settings == nil </span><span class="cov3" title="2">{
                return fmt.Errorf("nil settings")
        }</span>

        <span class="cov8" title="14">s.Lock()
        defer s.Unlock()

        // create a safe copy without sensitive information
        safeCopy := *settings // make a shallow copy

        // clear transient fields that shouldn't be persisted
        safeCopy.Transient = TransientSettings{}

        // ensure credentials are properly saved in domain models
        // they are already stored in the proper domain fields like:
        // - Telegram.Token
        // - OpenAI.Token
        // - Server.AuthHash

        // marshal the settings to JSON
        data, err := json.Marshal(&amp;safeCopy)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal settings: %w", err)
        }</span>

        // encrypt sensitive fields if crypter is configured
        <span class="cov8" title="14">if s.crypter != nil </span><span class="cov5" title="4">{
                if encErr := s.crypter.EncryptSensitiveFields(&amp;safeCopy, s.sensitiveFields...); encErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt sensitive fields: %w", encErr)
                }</span>

                // re-marshal after encryption
                <span class="cov5" title="4">data, err = json.Marshal(&amp;safeCopy)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal settings after encryption: %w", err)
                }</span>
        }

        <span class="cov8" title="14">query, err := configQueries.Pick(s.Type(), CmdUpsertConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get upsert query: %w", err)
        }</span>

        <span class="cov8" title="14">query = s.Adopt(query)
        _, err = s.ExecContext(ctx, query, s.GID(), string(data), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save settings: %w", err)
        }</span>

        <span class="cov8" title="14">return nil</span>
}

// Delete removes the settings from the database
func (s *Store) Delete(ctx context.Context) error <span class="cov3" title="2">{
        if s == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("store is nil")
        }</span>
        <span class="cov3" title="2">s.Lock()
        defer s.Unlock()

        query, err := configQueries.Pick(s.Type(), CmdDeleteConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get delete query: %w", err)
        }</span>

        <span class="cov3" title="2">query = s.Adopt(query)
        _, err = s.ExecContext(ctx, query, s.GID())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete settings: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// LastUpdated returns the last update time of the settings
func (s *Store) LastUpdated(ctx context.Context) (time.Time, error) <span class="cov7" title="8">{
        if s == nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("store is nil")
        }</span>
        <span class="cov7" title="8">s.RLock()
        defer s.RUnlock()

        var record struct {
                UpdatedAt time.Time `db:"updated_at"`
        }

        query, err := configQueries.Pick(s.Type(), CmdSelectConfigUpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to get updated_at query: %w", err)
        }</span>

        <span class="cov7" title="8">query = s.Adopt(query)
        err = s.GetContext(ctx, &amp;record, query, s.GID())
        if err != nil </span><span class="cov3" title="2">{
                if err.Error() == "sql: no rows in result set" </span><span class="cov3" title="2">{
                        return time.Time{}, fmt.Errorf("no settings found in database")
                }</span>
                <span class="cov0" title="0">return time.Time{}, fmt.Errorf("failed to get settings update time: %w", err)</span>
        }

        <span class="cov6" title="6">return record.UpdatedAt, nil</span>
}

// Exists checks if settings exist in the database
func (s *Store) Exists(ctx context.Context) (bool, error) <span class="cov5" title="4">{
        if s == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("store is nil")
        }</span>
        <span class="cov5" title="4">s.RLock()
        defer s.RUnlock()

        var count int
        query, err := configQueries.Pick(s.Type(), CmdCountConfig)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get count query: %w", err)
        }</span>

        <span class="cov5" title="4">query = s.Adopt(query)
        err = s.GetContext(ctx, &amp;count, query, s.GID())
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check if settings exist: %w", err)
        }</span>

        <span class="cov5" title="4">return count &gt; 0, nil</span>
}

// noopMigrate is a no-op migration function for the config table
// since there's no need for migrations currently
func noopMigrate(_ context.Context, _ *sqlx.Tx, _ string) error <span class="cov9" title="20">{
        log.Printf("[DEBUG] no migration needed for config table")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package events

import (
        "context"
        "errors"
        "fmt"
        "log"
        "regexp"
        "strconv"
        "strings"
        "time"
        "unicode/utf8"

        tbapi "github.com/OvyFlash/telegram-bot-api"
        "github.com/hashicorp/go-multierror"

        "github.com/umputun/tg-spam/app/bot"
)

// admin is a helper to handle all admin-group related stuff, created by listener
// public methods kept public (on a private struct) to be able to recognize the api
type admin struct {
        tbAPI        TbAPI
        bot          Bot
        locator      Locator
        superUsers   SuperUsers
        primChatID   int64
        adminChatID  int64
        trainingMode bool
        softBan      bool // if true, the user not banned automatically, but only restricted
        dry          bool
        warnMsg      string
}

const (
        confirmationPrefix = "?"
        banPrefix          = "+"
        infoPrefix         = "!"
)

// ReportBan a ban message to admin chat with a button to unban the user
func (a *admin) ReportBan(banUserStr string, msg *bot.Message) <span class="cov3" title="3">{
        log.Printf("[DEBUG] report to admin chat, ban msgsData for %s, group: %d", banUserStr, a.adminChatID)
        text := strings.ReplaceAll(escapeMarkDownV1Text(msg.Text), "\n", " ")
        would := ""
        if a.dry </span><span class="cov1" title="1">{
                would = "would have "
        }</span>

        <span class="cov3" title="3">forwardMsg := fmt.Sprintf("**%spermanently banned [%s](tg://user?id=%d)**\n\n%s\n\n",
                would, escapeMarkDownV1Text(banUserStr), msg.From.ID, text)
        if err := a.sendWithUnbanMarkup(forwardMsg, "change ban", msg.From, msg.ID, a.adminChatID); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] failed to send admin message, %v", err)
        }</span>
}

// MsgHandler handles messages received on admin chat. this is usually forwarded spam failed
// to be detected by the bot. we need to update spam filter with this message and ban the user.
// the user will be baned even in training mode, but not in the dry mode.
func (a *admin) MsgHandler(update tbapi.Update) error <span class="cov6" title="10">{
        shrink := func(inp string, maxLen int) string </span><span class="cov1" title="1">{
                if utf8.RuneCountInString(inp) &lt;= maxLen </span><span class="cov1" title="1">{
                        return inp
                }</span>
                <span class="cov0" title="0">return string([]rune(inp)[:maxLen]) + "..."</span>
        }

        // try to get the forwarded user ID, this is just for logging
        <span class="cov6" title="10">fwdID, username := a.getForwardUsernameAndID(update)

        log.Printf("[DEBUG] message from admin chat: msg id: %d, update id: %d, from: %s, sender: %q (%d)",
                update.Message.MessageID, update.UpdateID, update.Message.From.UserName,
                username, fwdID)

        if username == "" &amp;&amp; update.Message.ForwardOrigin == nil </span><span class="cov1" title="1">{
                // this is a regular message from admin chat, not the forwarded one, ignore it
                return nil
        }</span>

        // this is a forwarded message from super to admin chat, it is an example of missed spam
        // we need to update spam filter with this message
        <span class="cov5" title="9">msgTxt := update.Message.Text
        if msgTxt == "" </span><span class="cov3" title="3">{ // if no text, try to get it from the transformed message
                m := transform(update.Message)
                msgTxt = m.Text
        }</span>

        <span class="cov5" title="9">if msgTxt == "" </span><span class="cov3" title="3">{
                return errors.New("empty message text")
        }</span>

        <span class="cov5" title="6">log.Printf("[DEBUG] forwarded message from superuser %q (%d) to admin chat %d: %q",
                update.Message.From.UserName, update.Message.From.ID, a.adminChatID, msgTxt)

        // it would be nice to ban this user right away, but we don't have forwarded user ID here due to tg privacy limitation.
        // it is empty in update.Message. to ban this user, we need to get the match on the message from the locator and ban from there.
        info, ok := a.locator.Message(context.TODO(), msgTxt)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("not found %q in locator", shrink(msgTxt, 50))
        }</span>

        <span class="cov4" title="5">log.Printf("[DEBUG] locator found message %s", info)
        errs := new(multierror.Error)

        // check if the forwarded message will ban a super-user and ignore it
        if info.UserName != "" &amp;&amp; a.superUsers.IsSuper(info.UserName, info.UserID) </span><span class="cov1" title="1">{
                return fmt.Errorf("forwarded message is about super-user %s (%d), ignored", info.UserName, info.UserID)
        }</span>

        // remove user from the approved list and from storage
        <span class="cov4" title="4">if err := a.bot.RemoveApprovedUser(info.UserID); err != nil </span><span class="cov1" title="1">{
                errs = multierror.Append(errs, fmt.Errorf("failed to remove user %d from approved list: %w", info.UserID, err))
        }</span>

        // make a message with spam info and send to admin chat
        <span class="cov4" title="4">spamInfo := []string{}
        // check only, don't update the storage, as all we care here is to get checks results.
        // without checkOnly flag, it may add approved user to the storage after we removed it above.
        resp := a.bot.OnMessage(bot.Message{Text: update.Message.Text, From: bot.User{ID: info.UserID}}, true)
        spamInfoText := "**can't get spam info**"
        for _, check := range resp.CheckResults </span><span class="cov3" title="3">{
                spamInfo = append(spamInfo, "- "+escapeMarkDownV1Text(check.String()))
        }</span>
        <span class="cov4" title="4">if len(spamInfo) &gt; 0 </span><span class="cov3" title="3">{
                spamInfoText = strings.Join(spamInfo, "\n")
        }</span>
        <span class="cov4" title="4">newMsgText := fmt.Sprintf("**original detection results for %q (%d)**\n\n%s\n\n\n*the user banned and message deleted*",
                escapeMarkDownV1Text(info.UserName), info.UserID, spamInfoText)
        if err := send(tbapi.NewMessage(a.adminChatID, newMsgText), a.tbAPI); err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to send spap detection results to admin chat: %w", err))
        }</span>

        <span class="cov4" title="4">if a.dry </span><span class="cov1" title="1">{
                if err := errs.ErrorOrNil(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dry run errors: %w", err)
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        // update spam samples
        <span class="cov3" title="3">if err := a.bot.UpdateSpam(msgTxt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update spam for %q: %w", msgTxt, err)
        }</span>

        // delete message
        <span class="cov3" title="3">_, err := a.tbAPI.Request(tbapi.DeleteMessageConfig{
                BaseChatMessage: tbapi.BaseChatMessage{
                        MessageID:  info.MsgID,
                        ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID},
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to delete message %d: %w", info.MsgID, err))
        }</span> else<span class="cov3" title="3"> {
                log.Printf("[INFO] message %d deleted", info.MsgID)
        }</span>

        // ban user
        <span class="cov3" title="3">banReq := banRequest{duration: bot.PermanentBanDuration, userID: info.UserID, chatID: a.primChatID,
                tbAPI: a.tbAPI, dry: a.dry, training: a.trainingMode, userName: username}

        if err := banUserOrChannel(banReq); err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to ban user %d: %w", info.UserID, err))
        }</span>

        <span class="cov3" title="3">if err := errs.ErrorOrNil(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("spam notification failed: %w", err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// DirectSpamReport handles messages replayed with "/spam" or "spam" by admin
func (a *admin) DirectSpamReport(update tbapi.Update) error <span class="cov3" title="3">{
        return a.directReport(update, true)
}</span>

// DirectBanReport handles messages replayed with "/ban" or "ban" by admin. doing all the same as DirectSpamReport
// but without updating spam samples
func (a *admin) DirectBanReport(update tbapi.Update) error <span class="cov1" title="1">{
        return a.directReport(update, false)
}</span>

// DirectWarnReport handles messages replayed with "/warn" or "warn" by admin.
// it is removing the original message and posting a warning to the main chat as well as recording the warning th admin chat
func (a *admin) DirectWarnReport(update tbapi.Update) error <span class="cov3" title="3">{
        log.Printf("[DEBUG] direct warn by admin %q: msg id: %d, from: %q (%d)",
                update.Message.From.UserName, update.Message.ReplyToMessage.MessageID,
                update.Message.ReplyToMessage.From.UserName, update.Message.ReplyToMessage.From.ID)
        origMsg := update.Message.ReplyToMessage

        // this is a replayed message, it is an example of something we didn't like and want to issue a warning
        msgTxt := origMsg.Text
        if msgTxt == "" </span><span class="cov0" title="0">{ // if no text, try to get it from the transformed message
                m := transform(origMsg)
                msgTxt = m.Text
        }</span>
        <span class="cov3" title="3">log.Printf("[DEBUG] reported warn message from superuser %q (%d): %q", update.Message.From.UserName, update.Message.From.ID, msgTxt)
        // check if the reply message will ban a super-user and ignore it
        if origMsg.From.UserName != "" &amp;&amp; a.superUsers.IsSuper(origMsg.From.UserName, origMsg.From.ID) </span><span class="cov1" title="1">{
                return fmt.Errorf("warn message is from super-user %s (%d), ignored", origMsg.From.UserName, origMsg.From.ID)
        }</span>
        <span class="cov2" title="2">errs := new(multierror.Error)
        // delete original message
        _, err := a.tbAPI.Request(tbapi.DeleteMessageConfig{BaseChatMessage: tbapi.BaseChatMessage{
                MessageID:  origMsg.MessageID,
                ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID},
        }})
        if err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to delete message %d: %w", origMsg.MessageID, err))
        }</span> else<span class="cov2" title="2"> {
                log.Printf("[INFO] warn message %d deleted", origMsg.MessageID)
        }</span>

        // delete reply message
        <span class="cov2" title="2">_, err = a.tbAPI.Request(tbapi.DeleteMessageConfig{BaseChatMessage: tbapi.BaseChatMessage{
                MessageID:  update.Message.MessageID,
                ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID},
        }})
        if err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to delete message %d: %w", update.Message.MessageID, err))
        }</span> else<span class="cov2" title="2"> {
                log.Printf("[INFO] admin warn reprot message %d deleted", update.Message.MessageID)
        }</span>

        // make a warning message and replay to origMsg.MessageID
        <span class="cov2" title="2">warnMsg := fmt.Sprintf("warning from %s\n\n@%s %s", update.Message.From.UserName,
                origMsg.From.UserName, a.warnMsg)
        if err := send(tbapi.NewMessage(a.primChatID, escapeMarkDownV1Text(warnMsg)), a.tbAPI); err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to send warning to main chat: %w", err))
        }</span>

        <span class="cov2" title="2">if err := errs.ErrorOrNil(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("direct warn report failed: %w", err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// returns the user ID and username from the tg update if's forwarded message,
// or just username in case sender is hidden user
func (a *admin) getForwardUsernameAndID(update tbapi.Update) (fwdID int64, username string) <span class="cov6" title="13">{
        if update.Message.ForwardOrigin != nil </span><span class="cov5" title="9">{
                if update.Message.ForwardOrigin.IsUser() </span><span class="cov5" title="8">{
                        return update.Message.ForwardOrigin.SenderUser.ID, update.Message.ForwardOrigin.SenderUser.UserName
                }</span>
                <span class="cov1" title="1">if update.Message.ForwardOrigin.IsHiddenUser() </span><span class="cov0" title="0">{
                        return 0, update.Message.ForwardOrigin.SenderUserName
                }</span>
        }
        <span class="cov4" title="5">return 0, ""</span>
}

// directReport handles messages replayed with "/spam" or "spam", or "/ban" or "ban" by admin
func (a *admin) directReport(update tbapi.Update, updateSamples bool) error <span class="cov4" title="4">{
        log.Printf("[DEBUG] direct ban by admin %q: msg id: %d, from: %q (%d)",
                update.Message.From.UserName, update.Message.ReplyToMessage.MessageID,
                update.Message.ReplyToMessage.From.UserName, update.Message.ReplyToMessage.From.ID)

        origMsg := update.Message.ReplyToMessage

        // this is a replayed message, it is an example of missed spam
        // we need to update spam filter with this message
        msgTxt := origMsg.Text
        if msgTxt == "" </span><span class="cov0" title="0">{ // if no text, try to get it from the transformed message
                m := transform(origMsg)
                msgTxt = m.Text
        }</span>
        <span class="cov4" title="4">log.Printf("[DEBUG] reported spam message from superuser %q (%d): %q", update.Message.From.UserName, update.Message.From.ID, msgTxt)

        // check if the reply message will ban a super-user and ignore it
        if origMsg.From.UserName != "" &amp;&amp; a.superUsers.IsSuper(origMsg.From.UserName, origMsg.From.ID) </span><span class="cov0" title="0">{
                return fmt.Errorf("banned message is from super-user %s (%d), ignored", origMsg.From.UserName, origMsg.From.ID)
        }</span>

        <span class="cov4" title="4">errs := new(multierror.Error)
        // remove user from the approved list and from storage
        if err := a.bot.RemoveApprovedUser(origMsg.From.ID); err != nil </span><span class="cov0" title="0">{
                // error here is not critical, user may not be in the approved list if we run in paranoid mode or
                // if not reached the threshold for approval yet
                log.Printf("[DEBUG] can't remove user %d from approved list: %v", origMsg.From.ID, err)
        }</span>

        // make a message with spam info and send to admin chat
        <span class="cov4" title="4">spamInfo := []string{}
        // check only, don't update the storage with the new approved user as all we care here is to get checks results
        resp := a.bot.OnMessage(bot.Message{Text: msgTxt, From: bot.User{ID: origMsg.From.ID}}, true)
        spamInfoText := "**can't get spam info**"
        for _, check := range resp.CheckResults </span><span class="cov3" title="3">{
                spamInfo = append(spamInfo, "- "+escapeMarkDownV1Text(check.String()))
        }</span>
        <span class="cov4" title="4">if len(spamInfo) &gt; 0 </span><span class="cov3" title="3">{
                spamInfoText = strings.Join(spamInfo, "\n")
        }</span>
        <span class="cov4" title="4">newMsgText := fmt.Sprintf("**original detection results for %s (%d)**\n\n%s\n\n%s\n\n\n*the user banned by %q and message deleted*",
                escapeMarkDownV1Text(origMsg.From.UserName), origMsg.From.ID, msgTxt, escapeMarkDownV1Text(spamInfoText),
                escapeMarkDownV1Text(update.Message.From.UserName))
        if err := send(tbapi.NewMessage(a.adminChatID, newMsgText), a.tbAPI); err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to send spam detection results to admin chat: %w", err))
        }</span>

        <span class="cov4" title="4">if a.dry </span><span class="cov1" title="1">{
                if err := errs.ErrorOrNil(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dry run errors: %w", err)
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        // update spam samples
        <span class="cov3" title="3">if updateSamples </span><span class="cov2" title="2">{
                if err := a.bot.UpdateSpam(msgTxt); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update spam for %q: %w", msgTxt, err)
                }</span>
        }

        // delete original message
        <span class="cov3" title="3">_, err := a.tbAPI.Request(tbapi.DeleteMessageConfig{BaseChatMessage: tbapi.BaseChatMessage{
                MessageID:  origMsg.MessageID,
                ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID},
        }})
        if err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to delete message %d: %w", origMsg.MessageID, err))
        }</span> else<span class="cov3" title="3"> {
                log.Printf("[INFO] spam message %d deleted", origMsg.MessageID)
        }</span>

        // delete reply message
        <span class="cov3" title="3">_, err = a.tbAPI.Request(tbapi.DeleteMessageConfig{BaseChatMessage: tbapi.BaseChatMessage{
                MessageID:  update.Message.MessageID,
                ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID},
        }})
        if err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to delete message %d: %w", update.Message.MessageID, err))
        }</span> else<span class="cov3" title="3"> {
                log.Printf("[INFO] admin spam reprot message %d deleted", update.Message.MessageID)
        }</span>

        <span class="cov3" title="3">_, username := a.getForwardUsernameAndID(update)

        // ban user
        banReq := banRequest{duration: bot.PermanentBanDuration, userID: origMsg.From.ID, chatID: a.primChatID,
                tbAPI: a.tbAPI, dry: a.dry, training: a.trainingMode, userName: username}

        if err := banUserOrChannel(banReq); err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to ban user %d: %w", origMsg.From.ID, err))
        }</span>

        <span class="cov3" title="3">if err := errs.ErrorOrNil(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("spam notification failed: %w", err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

// InlineCallbackHandler handles a callback from Telegram, which is a response to a message with inline keyboard.
// The callback contains user info, which is used to unban the user.
func (a *admin) InlineCallbackHandler(query *tbapi.CallbackQuery) error <span class="cov5" title="8">{
        callbackData := query.Data
        chatID := query.Message.Chat.ID // this is ID of admin chat
        if chatID != a.adminChatID </span><span class="cov0" title="0">{    // ignore callbacks from other chats, only admin chat is allowed
                return nil
        }</span>

        // if callback msgsData starts with "?", we should show a confirmation message
        <span class="cov5" title="8">if strings.HasPrefix(callbackData, confirmationPrefix) </span><span class="cov1" title="1">{
                if err := a.callbackAskBanConfirmation(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to make ban confirmation dialog: %w", err)
                }</span>
                <span class="cov1" title="1">log.Printf("[DEBUG] unban confirmation request sent, chatID: %d, userID: %s, orig: %q",
                        chatID, callbackData[1:], query.Message.Text)
                return nil</span>
        }

        // if callback msgsData starts with "+", we should not unban the user, but rather clear the keyboard and add to spam samples
        <span class="cov5" title="7">if strings.HasPrefix(callbackData, banPrefix) </span><span class="cov2" title="2">{
                if err := a.callbackBanConfirmed(query); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed confirmation ban: %w", err)
                }</span>
                <span class="cov1" title="1">log.Printf("[DEBUG] ban confirmed, chatID: %d, userID: %s, orig: %q", chatID, callbackData, query.Message.Text)
                return nil</span>
        }

        // if callback msgsData starts with "!", we should show a spam info details
        <span class="cov4" title="5">if strings.HasPrefix(callbackData, infoPrefix) </span><span class="cov1" title="1">{
                if err := a.callbackShowInfo(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to show spam info: %w", err)
                }</span>
                <span class="cov1" title="1">log.Printf("[DEBUG] spam info sent, chatID: %d, userID: %s, orig: %q", chatID, callbackData, query.Message.Text)
                return nil</span>
        }

        // no prefix, callback msgsData here is userID, we should unban the user
        <span class="cov4" title="4">log.Printf("[DEBUG] unban action activated, chatID: %d, userID: %s, orig: %q", chatID, callbackData, query.Message.Text)
        if err := a.callbackUnbanConfirmed(query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unban user: %w", err)
        }</span>
        <span class="cov4" title="4">log.Printf("[INFO] user unbanned, chatID: %d, userID: %s, orig: %q", chatID, callbackData, query.Message.Text)

        return nil</span>
}

// callbackAskBanConfirmation sends a confirmation message to admin chat with two buttons: "unban" and "keep it banned"
// callback data: ?userID:msgID
func (a *admin) callbackAskBanConfirmation(query *tbapi.CallbackQuery) error <span class="cov1" title="1">{
        callbackData := query.Data

        keepBanned := "Keep it banned"
        if a.trainingMode </span><span class="cov0" title="0">{
                keepBanned = "Confirm ban"
        }</span>

        // replace button with confirmation/rejection buttons
        <span class="cov1" title="1">confirmationKeyboard := tbapi.NewInlineKeyboardMarkup(
                tbapi.NewInlineKeyboardRow(
                        tbapi.NewInlineKeyboardButtonData("Unban for real", callbackData[1:]),     // remove "?" prefix
                        tbapi.NewInlineKeyboardButtonData(keepBanned, banPrefix+callbackData[1:]), // set "+" prefix
                ),
        )
        editMsg := tbapi.NewEditMessageReplyMarkup(query.Message.Chat.ID, query.Message.MessageID, confirmationKeyboard)
        if err := send(editMsg, a.tbAPI); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make confiramtion, chatID:%d, msgID:%d, %w", query.Message.Chat.ID, query.Message.MessageID, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// callbackBanConfirmed handles the callback when user kept banned
// it clears the keyboard and updates the message text with confirmation of ban kept in place.
// it also updates spam samples with the original message
// callback data: +userID:msgID
func (a *admin) callbackBanConfirmed(query *tbapi.CallbackQuery) error <span class="cov4" title="5">{
        // clear keyboard and update message text with confirmation
        updText := query.Message.Text + fmt.Sprintf("\n\n_ban confirmed by %s in %v_", query.From.UserName, a.sinceQuery(query))
        editMsg := tbapi.NewEditMessageText(query.Message.Chat.ID, query.Message.MessageID, updText)
        editMsg.ReplyMarkup = &amp;tbapi.InlineKeyboardMarkup{InlineKeyboard: [][]tbapi.InlineKeyboardButton{}}
        if err := send(editMsg, a.tbAPI); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear confirmation, chatID:%d, msgID:%d, %w", query.Message.Chat.ID, query.Message.MessageID, err)
        }</span>

        <span class="cov4" title="5">if cleanMsg, err := a.getCleanMessage(query.Message.Text); err == nil &amp;&amp; cleanMsg != "" </span><span class="cov4" title="5">{
                if err = a.bot.UpdateSpam(cleanMsg); err != nil </span><span class="cov0" title="0">{ // update spam samples
                        return fmt.Errorf("failed to update spam for %q: %w", cleanMsg, err)
                }</span>
        } else<span class="cov0" title="0"> {
                // we don't want to fail on this error, as lack of a clean message should not prevent deleteAndBan
                // for soft and training modes, we just don't need to update spam samples with empty messages.
                log.Printf("[DEBUG] failed to get clean message: %v", err)
        }</span>

        <span class="cov4" title="5">userID, msgID, parseErr := a.parseCallbackData(query.Data)
        if parseErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse callback's userID %q: %w", query.Data, parseErr)
        }</span>

        <span class="cov4" title="5">if a.trainingMode </span><span class="cov2" title="2">{
                // in training mode, the user is not banned automatically, here we do the real ban &amp; delete the message
                if err := a.deleteAndBan(query, userID, msgID); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to ban user %d: %w", userID, err)
                }</span>
        }

        // for soft ban we need to ban user for real on confirmation
        <span class="cov4" title="4">if a.softBan &amp;&amp; !a.trainingMode </span><span class="cov1" title="1">{
                userName, err := a.extractUsername(query.Message.Text) // try to extract username from the message
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] failed to extract username from %q: %v", query.Message.Text, err)
                        userName = ""
                }</span>
                <span class="cov1" title="1">banReq := banRequest{duration: bot.PermanentBanDuration, userID: userID, chatID: a.primChatID,
                        tbAPI: a.tbAPI, dry: a.dry, training: a.trainingMode, userName: userName, restrict: false}
                if err := banUserOrChannel(banReq); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to ban user %d: %w", userID, err)
                }</span>
        }

        <span class="cov4" title="4">return nil</span>
}

// callbackUnbanConfirmed handles the callback when user unbanned.
// it clears the keyboard and updates the message text with confirmation of unban.
// also it unbans the user, adds it to the approved list and updates ham samples with the original message.
// callback data: userID:msgID
func (a *admin) callbackUnbanConfirmed(query *tbapi.CallbackQuery) error <span class="cov4" title="4">{
        callbackData := query.Data
        chatID := query.Message.Chat.ID // this is ID of admin chat
        log.Printf("[DEBUG] unban action activated, chatID: %d, userID: %s", chatID, callbackData)
        // callback msgsData here is userID, we should unban the user
        callbackResponse := tbapi.NewCallback(query.ID, "accepted")
        if _, err := a.tbAPI.Request(callbackResponse); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send callback response: %w", err)
        }</span>

        <span class="cov4" title="4">userID, _, err := a.parseCallbackData(callbackData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse callback msgsData %q: %w", callbackData, err)
        }</span>

        // get the original spam message to update ham samples
        <span class="cov4" title="4">if cleanMsg, cleanErr := a.getCleanMessage(query.Message.Text); cleanErr == nil &amp;&amp; cleanMsg != "" </span><span class="cov3" title="3">{
                // update ham samples if we have a clean message
                if upErr := a.bot.UpdateHam(cleanMsg); upErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update ham for %q: %w", cleanMsg, upErr)
                }</span>
        } else<span class="cov1" title="1"> {
                // we don't want to fail on this error, as lack of a clean message should not prevent unban action
                log.Printf("[DEBUG] failed to get clean message: %v", cleanErr)
        }</span>

        // unban user if not in training mode (in training mode, the user is not banned automatically)
        <span class="cov4" title="4">if !a.trainingMode </span><span class="cov3" title="3">{
                if uerr := a.unban(userID); uerr != nil </span><span class="cov0" title="0">{
                        return uerr
                }</span>
        }

        // add user to the approved list
        <span class="cov4" title="4">name, err := a.extractUsername(query.Message.Text) // try to extract username from the message
        if err != nil </span><span class="cov4" title="4">{
                log.Printf("[DEBUG] failed to extract username from %q: %v", query.Message.Text, err)
                name = ""
        }</span>
        <span class="cov4" title="4">if err := a.bot.AddApprovedUser(userID, name); err != nil </span><span class="cov0" title="0">{ // name is not available here
                return fmt.Errorf("failed to add user %d to approved list: %w", userID, err)
        }</span>

        // create the original forwarded message with new indication of "unbanned" and an empty keyboard
        <span class="cov4" title="4">updText := query.Message.Text + fmt.Sprintf("\n\n_unbanned by %s in %v_", query.From.UserName, a.sinceQuery(query))

        // add spam info to the message
        if !strings.Contains(query.Message.Text, "spam detection results") &amp;&amp; userID != 0 </span><span class="cov4" title="4">{
                spamInfoText := []string{"\n\n**original detection results**\n"}

                info, found := a.locator.Spam(context.TODO(), userID)
                if found </span><span class="cov0" title="0">{
                        for _, check := range info.Checks </span><span class="cov0" title="0">{
                                spamInfoText = append(spamInfoText, "- "+escapeMarkDownV1Text(check.String()))
                        }</span>
                }

                <span class="cov4" title="4">if len(spamInfoText) &gt; 1 </span><span class="cov0" title="0">{
                        updText += strings.Join(spamInfoText, "\n")
                }</span>
        }

        <span class="cov4" title="4">editMsg := tbapi.NewEditMessageText(chatID, query.Message.MessageID, updText)
        editMsg.ReplyMarkup = &amp;tbapi.InlineKeyboardMarkup{InlineKeyboard: [][]tbapi.InlineKeyboardButton{}}
        if err := send(editMsg, a.tbAPI); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to edit message, chatID:%d, msgID:%d, %w", chatID, query.Message.MessageID, err)
        }</span>
        <span class="cov4" title="4">return nil</span>
}

func (a *admin) unban(userID int64) error <span class="cov3" title="3">{
        if a.softBan </span><span class="cov2" title="2">{ // soft ban, just drop restrictions
                _, err := a.tbAPI.Request(tbapi.RestrictChatMemberConfig{
                        ChatMemberConfig: tbapi.ChatMemberConfig{UserID: userID, ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID}},
                        Permissions: &amp;tbapi.ChatPermissions{
                                CanSendMessages:      true,
                                CanSendAudios:        true,
                                CanSendDocuments:     true,
                                CanSendPhotos:        true,
                                CanSendVideos:        true,
                                CanSendVideoNotes:    true,
                                CanSendVoiceNotes:    true,
                                CanSendOtherMessages: true,
                                CanChangeInfo:        true,
                                CanInviteUsers:       true,
                                CanPinMessages:       true,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to drop restrictions for user %d: %w", userID, err)
                }</span>
                <span class="cov2" title="2">return nil</span>
        }

        // hard ban, unban the user for real
        <span class="cov1" title="1">_, err := a.tbAPI.Request(tbapi.UnbanChatMemberConfig{
                ChatMemberConfig: tbapi.ChatMemberConfig{UserID: userID, ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID}}, OnlyIfBanned: true})
        // onlyIfBanned seems to prevent user from being removed from the chat according to this confusing doc:
        // https://core.telegram.org/bots/api#unbanchatmember
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unban user %d: %w", userID, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// callbackShowInfo handles the callback when user asks for spam detection details for the ban.
// callback data: !userID:msgID
func (a *admin) callbackShowInfo(query *tbapi.CallbackQuery) error <span class="cov2" title="2">{
        callbackData := query.Data
        spamInfoText := "**can't get spam info**"
        spamInfo := []string{}
        userID, _, err := a.parseCallbackData(callbackData)
        if err != nil </span><span class="cov0" title="0">{
                spamInfo = append(spamInfo, fmt.Sprintf("**failed to parse userID from %q: %v**", callbackData[1:], err))
        }</span>

        // collect spam detection details
        <span class="cov2" title="2">if userID != 0 </span><span class="cov2" title="2">{
                info, found := a.locator.Spam(context.TODO(), userID)
                if found </span><span class="cov2" title="2">{
                        for _, check := range info.Checks </span><span class="cov3" title="3">{
                                spamInfo = append(spamInfo, "- "+escapeMarkDownV1Text(check.String()))
                        }</span>
                }
                <span class="cov2" title="2">if len(spamInfo) &gt; 0 </span><span class="cov2" title="2">{
                        spamInfoText = strings.Join(spamInfo, "\n")
                }</span>
        }

        <span class="cov2" title="2">updText := query.Message.Text + "\n\n**spam detection results**\n" + spamInfoText
        confirmationKeyboard := [][]tbapi.InlineKeyboardButton{}
        if query.Message.ReplyMarkup != nil &amp;&amp; len(query.Message.ReplyMarkup.InlineKeyboard) &gt; 0 </span><span class="cov0" title="0">{
                confirmationKeyboard = query.Message.ReplyMarkup.InlineKeyboard
                confirmationKeyboard[0] = confirmationKeyboard[0][:1] // remove second button (info)
        }</span>
        <span class="cov2" title="2">editMsg := tbapi.NewEditMessageText(query.Message.Chat.ID, query.Message.MessageID, updText)
        editMsg.ReplyMarkup = &amp;tbapi.InlineKeyboardMarkup{InlineKeyboard: confirmationKeyboard}
        editMsg.ParseMode = tbapi.ModeMarkdown
        if err := send(editMsg, a.tbAPI); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send spam info, chatID:%d, msgID:%d, %w", query.Message.Chat.ID, query.Message.MessageID, err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// deleteAndBan deletes the message and bans the user
func (a *admin) deleteAndBan(query *tbapi.CallbackQuery, userID int64, msgID int) error <span class="cov2" title="2">{
        errs := new(multierror.Error)
        userName := a.locator.UserNameByID(context.TODO(), userID)
        banReq := banRequest{
                duration: bot.PermanentBanDuration,
                userID:   userID,
                chatID:   a.primChatID,
                tbAPI:    a.tbAPI,
                dry:      a.dry,
                training: false, // reset training flag, ban for real
                userName: userName,
        }

        // check if user is super and don't ban if so
        msgFromSuper := userName != "" &amp;&amp; a.superUsers.IsSuper(userName, userID)
        if !msgFromSuper </span><span class="cov2" title="2">{
                if err := banUserOrChannel(banReq); err != nil </span><span class="cov1" title="1">{
                        errs = multierror.Append(errs, fmt.Errorf("failed to ban user %d: %w", userID, err))
                }</span>
        }

        // we allow deleting messages from supers. This can be useful if super is training the bot by adding spam messages
        <span class="cov2" title="2">_, err := a.tbAPI.Request(tbapi.DeleteMessageConfig{BaseChatMessage: tbapi.BaseChatMessage{
                MessageID:  msgID,
                ChatConfig: tbapi.ChatConfig{ChatID: a.primChatID},
        }})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete message %d: %w", query.Message.MessageID, err)
        }</span>

        // any errors happened above will be returned
        <span class="cov2" title="2">if errs.ErrorOrNil() != nil </span><span class="cov1" title="1">{
                errMsgs := []string{}
                for _, err := range errs.Errors </span><span class="cov1" title="1">{
                        errStr := err.Error()
                        errMsgs = append(errMsgs, errStr)
                }</span>
                <span class="cov1" title="1">return errors.New(strings.Join(errMsgs, "\n"))</span> // reformat to be md friendly
        }

        <span class="cov1" title="1">if msgFromSuper </span><span class="cov0" title="0">{
                log.Printf("[INFO] message %d deleted, user %q (%d) is super, not banned", msgID, userName, userID)
        }</span> else<span class="cov1" title="1"> {
                log.Printf("[INFO] message %d deleted, user %q (%d) banned", msgID, userName, userID)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// getCleanMessage returns the original message without spam info and buttons
// the messages in admin chat look like this:
//
//        permanently banned {6762723796 VladimirSokolov24 Владимир Соколов}
//
//        the original message is here
//        another line of the original message
//
// spam detection results
func (a *admin) getCleanMessage(msg string) (string, error) <span class="cov7" title="16">{
        // the original message is from the second line, remove newlines and spaces
        msgLines := strings.Split(msg, "\n")
        if len(msgLines) &lt; 2 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("unexpected message from callback msgsData: %q", msg)
        }</span>

        <span class="cov7" title="15">spamInfoLine := len(msgLines)
        for i, line := range msgLines </span><span class="cov10" title="53">{
                if strings.HasPrefix(line, "spam detection results") || strings.HasPrefix(line, "**spam detection results**") </span><span class="cov4" title="4">{
                        spamInfoLine = i
                        break</span>
                }
        }

        // ensure we have at least one line of content
        <span class="cov7" title="15">if spamInfoLine &lt;= 2 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no original message found in callback msgsData: %q", msg)
        }</span>

        <span class="cov6" title="14">cleanMsg := strings.Join(msgLines[2:spamInfoLine], "\n")
        return strings.TrimSpace(cleanMsg), nil</span>
}

// sendWithUnbanMarkup sends a message to admin chat and adds buttons to ui.
// text is message with details and action it for the button label to unban, which is user id prefixed with "?" for confirmation;
// the second button is to show info about the spam analysis.
func (a *admin) sendWithUnbanMarkup(text, action string, user bot.User, msgID int, chatID int64) error <span class="cov3" title="3">{
        log.Printf("[DEBUG] action response %q: user %+v, msgID:%d, text: %q", action, user, msgID, strings.ReplaceAll(text, "\n", "\\n"))
        tbMsg := tbapi.NewMessage(chatID, text)
        tbMsg.ParseMode = tbapi.ModeMarkdown
        tbMsg.LinkPreviewOptions = tbapi.LinkPreviewOptions{IsDisabled: true}

        tbMsg.ReplyMarkup = tbapi.NewInlineKeyboardMarkup(
                tbapi.NewInlineKeyboardRow(
                        // ?userID to request confirmation
                        tbapi.NewInlineKeyboardButtonData("⛔︎ "+action, fmt.Sprintf("%s%d:%d", confirmationPrefix, user.ID, msgID)),
                        // !userID to request info
                        tbapi.NewInlineKeyboardButtonData("️⚑ info", fmt.Sprintf("%s%d:%d", infoPrefix, user.ID, msgID)),
                ),
        )

        if _, err := a.tbAPI.Send(tbMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't send message to telegram %q: %w", text, err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

// callbackData is a string with userID and msgID separated by ":"
func (a *admin) parseCallbackData(data string) (userID int64, msgID int, err error) <span class="cov7" title="20">{
        if len(data) &lt; 3 </span><span class="cov1" title="1">{
                return 0, 0, fmt.Errorf("unexpected callback data, too short %q", data)
        }</span>

        // remove prefix if present from the parsed data
        <span class="cov7" title="19">if data[:1] == confirmationPrefix || data[:1] == banPrefix || data[:1] == infoPrefix </span><span class="cov6" title="10">{
                data = data[1:]
        }</span>

        <span class="cov7" title="19">parts := strings.Split(data, ":")
        if len(parts) != 2 </span><span class="cov1" title="1">{
                return 0, 0, fmt.Errorf("unexpected callback data, should have both ids %q", data)
        }</span>
        <span class="cov7" title="18">if userID, err = strconv.ParseInt(parts[0], 10, 64); err != nil </span><span class="cov2" title="2">{
                return 0, 0, fmt.Errorf("failed to parse userID %q: %w", parts[0], err)
        }</span>
        <span class="cov7" title="16">if msgID, err = strconv.Atoi(parts[1]); err != nil </span><span class="cov1" title="1">{
                return 0, 0, fmt.Errorf("failed to parse msgID %q: %w", parts[1], err)
        }</span>

        <span class="cov7" title="15">return userID, msgID, nil</span>
}

// extractUsername tries to extract the username from a ban message
func (a *admin) extractUsername(text string) (string, error) <span class="cov5" title="8">{
        // regex for markdown format: [username](tg://user?id=123456)
        markdownRegex := regexp.MustCompile(`\[(.*?)\]\(tg://user\?id=\d+\)`)
        matches := markdownRegex.FindStringSubmatch(text)
        if len(matches) &gt; 1 </span><span class="cov2" title="2">{
                return matches[1], nil
        }</span>

        // regex for plain format: {200312168 umputun Umputun U}
        <span class="cov5" title="6">plainRegex := regexp.MustCompile(`\{\d+ (\S+) .+?\}`)
        matches = plainRegex.FindStringSubmatch(text)
        if len(matches) &gt; 1 </span><span class="cov1" title="1">{
                return matches[1], nil
        }</span>

        <span class="cov4" title="5">return "", errors.New("username not found")</span>
}

// sinceQuery calculates the time elapsed since the message of the query was sent
func (a *admin) sinceQuery(query *tbapi.CallbackQuery) time.Duration <span class="cov5" title="9">{
        res := time.Since(time.Unix(int64(query.Message.Date), 0)).Round(time.Second)
        if res &lt; 0 </span><span class="cov0" title="0">{ // negative duration possible if clock is not in sync with tg times and a message is from the future
                res = 0
        }</span>
        <span class="cov5" title="9">return res</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package events

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        tbapi "github.com/OvyFlash/telegram-bot-api"

        "github.com/umputun/tg-spam/app/bot"
        "github.com/umputun/tg-spam/app/storage"
        "github.com/umputun/tg-spam/lib/spamcheck"
)

//go:generate moq --out mocks/tb_api.go --pkg mocks --with-resets --skip-ensure . TbAPI
//go:generate moq --out mocks/spam_logger.go --pkg mocks --with-resets --skip-ensure . SpamLogger
//go:generate moq --out mocks/bot.go --pkg mocks --with-resets --skip-ensure . Bot
//go:generate moq --out mocks/locator.go --pkg mocks --with-resets --skip-ensure . Locator

// TbAPI is an interface for telegram bot API, only subset of methods used
type TbAPI interface {
        GetUpdatesChan(config tbapi.UpdateConfig) tbapi.UpdatesChannel
        Send(c tbapi.Chattable) (tbapi.Message, error)
        Request(c tbapi.Chattable) (*tbapi.APIResponse, error)
        GetChat(config tbapi.ChatInfoConfig) (tbapi.ChatFullInfo, error)
        GetChatAdministrators(config tbapi.ChatAdministratorsConfig) ([]tbapi.ChatMember, error)
}

// SpamLogger is an interface for spam logger
type SpamLogger interface {
        Save(msg *bot.Message, response *bot.Response)
}

// SpamLoggerFunc is a function that implements SpamLogger interface
type SpamLoggerFunc func(msg *bot.Message, response *bot.Response)

// Save is a function that implements SpamLogger interface
func (f SpamLoggerFunc) Save(msg *bot.Message, response *bot.Response) <span class="cov1" title="1">{
        f(msg, response)
}</span>

// Locator is an interface for message locator
type Locator interface {
        AddMessage(ctx context.Context, msg string, chatID, userID int64, userName string, msgID int) error
        AddSpam(ctx context.Context, userID int64, checks []spamcheck.Response) error
        Message(ctx context.Context, msg string) (storage.MsgMeta, bool)
        Spam(ctx context.Context, userID int64) (storage.SpamData, bool)
        MsgHash(msg string) string
        UserNameByID(ctx context.Context, userID int64) string
}

// Bot is an interface for bot events.
type Bot interface {
        OnMessage(msg bot.Message, checkOnly bool) (response bot.Response)
        UpdateSpam(msg string) error
        UpdateHam(msg string) error
        AddApprovedUser(id int64, name string) error
        RemoveApprovedUser(id int64) error
        IsApprovedUser(userID int64) bool
}

func escapeMarkDownV1Text(text string) string <span class="cov7" title="36">{
        escSymbols := []string{"_", "*", "`", "["}
        for _, esc := range escSymbols </span><span class="cov10" title="144">{
                text = strings.ReplaceAll(text, esc, "\\"+esc)
        }</span>
        <span class="cov7" title="36">return text</span>
}

// send a message to the telegram as markdown first and if failed - as plain text
func send(tbMsg tbapi.Chattable, tbAPI TbAPI) error <span class="cov7" title="37">{
        withParseMode := func(tbMsg tbapi.Chattable, parseMode string) tbapi.Chattable </span><span class="cov7" title="39">{
                switch msg := tbMsg.(type) </span>{
                case tbapi.MessageConfig:<span class="cov6" title="26">
                        msg.ParseMode = parseMode
                        msg.LinkPreviewOptions = tbapi.LinkPreviewOptions{IsDisabled: true}
                        return msg</span>
                case tbapi.EditMessageTextConfig:<span class="cov5" title="12">
                        msg.ParseMode = parseMode
                        msg.LinkPreviewOptions = tbapi.LinkPreviewOptions{IsDisabled: true}
                        return msg</span>
                case tbapi.EditMessageReplyMarkupConfig:<span class="cov1" title="1">
                        return msg</span>
                }
                <span class="cov0" title="0">return tbMsg</span> // don't touch other types
        }

        // for issue #223: Special handling for messages containing profile links with usernames that have underscores
        // these often fail in markdown mode because underscores are used for formatting, but we need to preserve the links
        <span class="cov7" title="37">hasTelegramProfileLink := false
        switch v := tbMsg.(type) </span>{
        case tbapi.EditMessageTextConfig:<span class="cov5" title="11">
                // check if this message contains a Telegram user link, which we want to preserve
                hasTelegramProfileLink = strings.Contains(v.Text, "tg://user?id=")</span>
        }

        // try markdown first, as it's the nicer rendering
        <span class="cov7" title="37">msg := withParseMode(tbMsg, tbapi.ModeMarkdown)
        if _, err := tbAPI.Send(msg); err != nil </span><span class="cov2" title="2">{
                log.Printf("[WARN] failed to send message as markdown, %v", err)

                // for messages with Telegram profile links, we need to ensure the links are preserved
                // when falling back to plain text, even if markdown fails
                if hasTelegramProfileLink </span><span class="cov1" title="1">{
                        // use HTML mode as a fallback, which better handles usernames with special characters
                        htmlMsg := withParseMode(tbMsg, tbapi.ModeHTML)
                        if _, err := tbAPI.Send(htmlMsg); err != nil </span><span class="cov0" title="0">{
                                // if HTML also fails, fall back to plain text
                                log.Printf("[WARN] failed to send message as HTML, %v", err)
                                plainMsg := withParseMode(tbMsg, "") // plain text
                                if _, err := tbAPI.Send(plainMsg); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("can't send message to telegram: %w", err)
                                }</span>
                        }
                        <span class="cov1" title="1">return nil</span>
                }

                // for regular messages, just fall back to plain text
                <span class="cov1" title="1">msg = withParseMode(tbMsg, "")
                if _, err := tbAPI.Send(msg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't send message to telegram: %w", err)
                }</span>
        }
        <span class="cov7" title="36">return nil</span>
}

type banRequest struct {
        tbAPI TbAPI

        userID    int64
        channelID int64
        chatID    int64
        duration  time.Duration
        userName  string

        dry      bool
        training bool // training mode, do not do the actual ban
        restrict bool // restrict instead of ban
}

// The bot must be an administrator in the supergroup for this to work
// and must have the appropriate admin rights.
// If channel is provided, it is banned instead of provided user, permanently.
func banUserOrChannel(r banRequest) error <span class="cov6" title="16">{
        // from Telegram Bot API documentation:
        // &gt; If user is restricted for more than 366 days or less than 30 seconds from the current time,
        // &gt; they are considered to be restricted forever
        // because the API query uses unix timestamp rather than "ban duration",
        // you do not want to accidentally get into this 30-second window of a lifetime ban.
        // in practice BanDuration is equal to ten minutes,
        // so this `if` statement is unlikely to be evaluated to true.

        bannedEntity := fmt.Sprintf("user %d", r.userID)
        if r.channelID != 0 </span><span class="cov2" title="3">{
                bannedEntity = fmt.Sprintf("channel %d", r.channelID)
        }</span>
        <span class="cov6" title="16">if r.dry </span><span class="cov0" title="0">{
                log.Printf("[INFO] dry run: ban %s for %v", bannedEntity, r.duration)
                return nil
        }</span>

        <span class="cov6" title="16">if r.training </span><span class="cov1" title="1">{
                log.Printf("[INFO] training mode: ban %s for %v", bannedEntity, r.duration)
                return nil
        }</span>

        <span class="cov5" title="15">if r.duration &lt; 30*time.Second </span><span class="cov0" title="0">{
                r.duration = 1 * time.Minute
        }</span>

        <span class="cov5" title="15">if r.restrict </span><span class="cov1" title="1">{ // soft ban mode
                resp, err := r.tbAPI.Request(tbapi.RestrictChatMemberConfig{
                        ChatMemberConfig: tbapi.ChatMemberConfig{
                                ChatConfig: tbapi.ChatConfig{ChatID: r.chatID},
                                UserID:     r.userID,
                        },
                        UntilDate: time.Now().Add(r.duration).Unix(),
                        Permissions: &amp;tbapi.ChatPermissions{
                                CanSendMessages:      false,
                                CanSendAudios:        false,
                                CanSendDocuments:     false,
                                CanSendPhotos:        false,
                                CanSendVideos:        false,
                                CanSendVideoNotes:    false,
                                CanSendVoiceNotes:    false,
                                CanSendOtherMessages: false,
                                CanChangeInfo:        false,
                                CanInviteUsers:       false,
                                CanPinMessages:       false,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to restrict user: %w", err)
                }</span>
                <span class="cov1" title="1">if !resp.Ok </span><span class="cov1" title="1">{
                        return fmt.Errorf("response is not Ok: %v", string(resp.Result))
                }</span>
                <span class="cov0" title="0">log.Printf("[INFO] %s restricted by bot for %v", r.userName, r.duration)
                return nil</span>
        }

        <span class="cov5" title="14">if r.channelID != 0 </span><span class="cov2" title="2">{
                resp, err := r.tbAPI.Request(tbapi.BanChatSenderChatConfig{
                        ChatConfig:   tbapi.ChatConfig{ChatID: r.chatID},
                        SenderChatID: r.channelID,
                        UntilDate:    int(time.Now().Add(r.duration).Unix()),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to ban channel: %w", err)
                }</span>
                <span class="cov2" title="2">if !resp.Ok </span><span class="cov1" title="1">{
                        return fmt.Errorf("response is not Ok: %v", string(resp.Result))
                }</span>
                <span class="cov1" title="1">log.Printf("[INFO] channel %s banned by bot for %v", r.userName, r.duration)
                return nil</span>
        }

        <span class="cov5" title="12">resp, err := r.tbAPI.Request(tbapi.BanChatMemberConfig{
                ChatMemberConfig: tbapi.ChatMemberConfig{
                        ChatConfig: tbapi.ChatConfig{ChatID: r.chatID},
                        UserID:     r.userID,
                },
                UntilDate: time.Now().Add(r.duration).Unix(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ban user: %w", err)
        }</span>
        <span class="cov5" title="12">if !resp.Ok </span><span class="cov2" title="3">{
                return fmt.Errorf("response is not Ok: %v", string(resp.Result))
        }</span>

        <span class="cov4" title="9">log.Printf("[INFO] user %s banned by bot for %v", r.userName, r.duration)
        return nil</span>
}

// transform converts telegram message to internal message format.
// properly handles all message types - text, photo, video, etc, and their combinations.
// also handles forwarded messages, replies, and message entities like links and mentions.
func transform(msg *tbapi.Message) *bot.Message <span class="cov7" title="28">{
        // helper function to convert telegram entities to internal format
        transformEntities := func(entities []tbapi.MessageEntity) *[]bot.Entity </span><span class="cov3" title="5">{
                if len(entities) == 0 </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov3" title="4">result := make([]bot.Entity, 0, len(entities))
                for _, entity := range entities </span><span class="cov3" title="5">{
                        e := bot.Entity{
                                Type:   entity.Type,
                                Offset: entity.Offset,
                                Length: entity.Length,
                                URL:    entity.URL,
                        }
                        if entity.User != nil </span><span class="cov1" title="1">{
                                e.User = &amp;bot.User{
                                        ID:          entity.User.ID,
                                        Username:    entity.User.UserName,
                                        DisplayName: entity.User.FirstName + " " + entity.User.LastName,
                                }
                        }</span>
                        <span class="cov3" title="5">result = append(result, e)</span>
                }
                <span class="cov3" title="4">return &amp;result</span>
        }

        // initialize message with basic fields
        <span class="cov7" title="28">message := bot.Message{
                ID:     msg.MessageID,
                Sent:   msg.Time(),
                Text:   msg.Text,
                ChatID: msg.Chat.ID,
        }

        // set sender info
        if msg.From != nil </span><span class="cov6" title="22">{
                message.From = bot.User{
                        ID:       msg.From.ID,
                        Username: msg.From.UserName,
                }
                // combine first and last name for display name if present
                if firstName := strings.TrimSpace(msg.From.FirstName); firstName != "" </span><span class="cov4" title="6">{
                        message.From.DisplayName = firstName
                }</span>
                <span class="cov6" title="22">if lastName := strings.TrimSpace(msg.From.LastName); lastName != "" </span><span class="cov3" title="5">{
                        message.From.DisplayName += " " + lastName
                }</span>
        }

        // set sender chat for messages sent on behalf of a channel
        <span class="cov7" title="28">if msg.SenderChat != nil </span><span class="cov3" title="4">{
                message.SenderChat = bot.SenderChat{
                        ID:       msg.SenderChat.ID,
                        UserName: msg.SenderChat.UserName,
                }
        }</span>

        // handle message content and type flags independently
        <span class="cov7" title="28">if len(msg.Entities) &gt; 0 </span><span class="cov2" title="3">{
                message.Entities = transformEntities(msg.Entities)
        }</span>

        <span class="cov7" title="28">if len(msg.Photo) &gt; 0 </span><span class="cov2" title="2">{
                sizes := msg.Photo
                lastSize := sizes[len(sizes)-1] // use the highest quality photo
                message.Image = &amp;bot.Image{
                        FileID:   lastSize.FileID,
                        Width:    lastSize.Width,
                        Height:   lastSize.Height,
                        Caption:  msg.Caption,
                        Entities: transformEntities(msg.CaptionEntities),
                }
        }</span>

        // set media type flags
        <span class="cov7" title="28">if msg.Video != nil </span><span class="cov2" title="2">{
                message.WithVideo = true
        }</span>
        <span class="cov7" title="28">if msg.VideoNote != nil </span><span class="cov0" title="0">{
                message.WithVideoNote = true
        }</span>
        <span class="cov7" title="28">if msg.Story != nil </span><span class="cov1" title="1">{ // telegram story is treated as video
                message.WithVideo = true
        }</span>
        <span class="cov7" title="28">if msg.Audio != nil </span><span class="cov2" title="2">{
                message.WithAudio = true
        }</span>
        <span class="cov7" title="28">if msg.ForwardOrigin != nil </span><span class="cov4" title="8">{
                message.WithForward = true
        }</span>
        <span class="cov7" title="28">if msg.ReplyMarkup != nil </span><span class="cov0" title="0">{ // detect attached keyboards/buttons
                message.WithKeyboard = true
        }</span>

        // handle reply-to message if present
        <span class="cov7" title="28">if msg.ReplyToMessage != nil </span><span class="cov3" title="5">{
                message.ReplyTo.Text = msg.ReplyToMessage.Text
                message.ReplyTo.Sent = msg.ReplyToMessage.Time()
                if msg.ReplyToMessage.From != nil </span><span class="cov2" title="3">{
                        message.ReplyTo.From = bot.User{
                                ID:          msg.ReplyToMessage.From.ID,
                                Username:    msg.ReplyToMessage.From.UserName,
                                DisplayName: msg.ReplyToMessage.From.FirstName + " " + msg.ReplyToMessage.From.LastName,
                        }
                }</span>
                <span class="cov3" title="5">if msg.ReplyToMessage.SenderChat != nil </span><span class="cov2" title="2">{
                        message.ReplyTo.SenderChat = bot.SenderChat{
                                ID:       msg.ReplyToMessage.SenderChat.ID,
                                UserName: msg.ReplyToMessage.SenderChat.UserName,
                        }
                }</span>
        }

        // handle caption - either as main text if no text present, or append to existing text
        <span class="cov7" title="28">if msg.Caption != "" </span><span class="cov2" title="2">{
                if message.Text == "" </span><span class="cov2" title="2">{
                        log.Printf("[DEBUG] caption only message: %q", msg.Caption)
                        message.Text = msg.Caption
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] caption appended to message: %q", msg.Caption)
                        message.Text += "\n" + msg.Caption
                }</span>
        }

        <span class="cov7" title="28">return &amp;message</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package events provide event handlers for telegram bot and all the high-level event handlers.
// It parses messages, sends them to the spam detector and handles the results. It can also ban users
// and send messages to the admin.
//
// In addition to that, it provides support for admin chat handling allowing to unban users via the web service and
// update the list of spam samples.
package events

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strconv"
        "strings"
        "sync"
        "time"

        tbapi "github.com/OvyFlash/telegram-bot-api"
        "github.com/hashicorp/go-multierror"

        "github.com/umputun/tg-spam/app/bot"
)

// TelegramListener listens to tg update, forward to bots and send back responses
// Not thread safe
type TelegramListener struct {
        TbAPI                   TbAPI         // telegram bot API
        SpamLogger              SpamLogger    // logger to save spam to files and db
        Bot                     Bot           // bot to handle messages
        Group                   string        // can be int64 or public group username (without "@" prefix)
        AdminGroup              string        // can be int64 or public group username (without "@" prefix)
        IdleDuration            time.Duration // idle timeout to send "idle" message to bots
        SuperUsers              SuperUsers    // list of superusers, can ban and report spam, can't be banned
        TestingIDs              []int64       // list of chat IDs to test the bot
        StartupMsg              string        // message to send on startup to the primary chat
        WarnMsg                 string        // message to send on warning
        NoSpamReply             bool          // do not reply on spam messages in the primary chat
        SuppressJoinMessage     bool          // delete join message when kick out user
        TrainingMode            bool          // do not ban users, just report and train spam detector
        SoftBanMode             bool          // do not ban users, but restrict their actions
        Locator                 Locator       // message locator to get info about messages
        DisableAdminSpamForward bool          // disable forwarding spam reports to admin chat support
        Dry                     bool          // dry run, do not ban or send messages

        adminHandler *admin
        chatID       int64
        adminChatID  int64

        msgs struct {
                once sync.Once
                ch   chan bot.Response
        }
}

// Do process all events, blocked call
func (l *TelegramListener) Do(ctx context.Context) error <span class="cov8" title="25">{
        log.Printf("[INFO] start telegram listener for %q", l.Group)

        if l.TrainingMode </span><span class="cov3" title="3">{
                log.Printf("[WARN] training mode, no bans")
        }</span>

        <span class="cov8" title="25">if l.SoftBanMode </span><span class="cov3" title="3">{
                log.Printf("[INFO] soft ban mode, no bans but restrictions")
        }</span>

        // get chat ID for the group we are monitoring
        <span class="cov8" title="25">var getChatErr error
        if l.chatID, getChatErr = l.getChatID(l.Group); getChatErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get chat ID for group %q: %w", l.Group, getChatErr)
        }</span>
        <span class="cov8" title="25">log.Printf("[INFO] primary chat ID: %d", l.chatID)

        if err := l.updateSupers(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] failed to update superusers: %v", err)
        }</span>

        <span class="cov8" title="25">if l.AdminGroup != "" </span><span class="cov6" title="10">{
                // get chat ID for the admin group
                if l.adminChatID, getChatErr = l.getChatID(l.AdminGroup); getChatErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get chat ID for admin group %q: %w", l.AdminGroup, getChatErr)
                }</span>
                <span class="cov6" title="10">log.Printf("[INFO] admin chat ID: %d", l.adminChatID)</span>
        }

        <span class="cov8" title="25">l.msgs.once.Do(func() </span><span class="cov7" title="18">{
                l.msgs.ch = make(chan bot.Response, 100)
                if l.IdleDuration == 0 </span><span class="cov7" title="18">{
                        l.IdleDuration = 30 * time.Second
                }</span>
        })

        // send startup message if any set
        <span class="cov8" title="25">if l.StartupMsg != "" &amp;&amp; !l.TrainingMode &amp;&amp; !l.Dry </span><span class="cov4" title="4">{
                if err := l.sendBotResponse(bot.Response{Send: true, Text: l.StartupMsg}, l.chatID, NotificationSilent); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to send startup message, %v", err)
                }</span> else<span class="cov4" title="4"> {
                        log.Printf("[DEBUG] startup message sent")
                }</span>
        }

        <span class="cov8" title="25">l.adminHandler = &amp;admin{tbAPI: l.TbAPI, bot: l.Bot, locator: l.Locator, primChatID: l.chatID, adminChatID: l.adminChatID,
                superUsers: l.SuperUsers, trainingMode: l.TrainingMode, softBan: l.SoftBanMode, dry: l.Dry, warnMsg: l.WarnMsg}

        adminForwardStatus := "enabled"
        if l.DisableAdminSpamForward </span><span class="cov0" title="0">{
                adminForwardStatus = "disabled"
        }</span>
        <span class="cov8" title="25">log.Printf("[DEBUG] admin handler created, spam forwarding %s, %+v", adminForwardStatus, l.adminHandler)

        u := tbapi.NewUpdate(0)
        u.Timeout = 60

        updates := l.TbAPI.GetUpdatesChan(u)
        log.Printf("[DEBUG] start listening for updates")
        for </span><span class="cov10" title="50">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("listener context canceled: %w", ctx.Err())</span>

                case update, ok := &lt;-updates:<span class="cov10" title="50">
                        if !ok </span><span class="cov8" title="25">{
                                return fmt.Errorf("telegram update chan closed")
                        }</span>

                        // handle admin chat messages. can be just messages (MsgHandler will ignore those)
                        // or forwards of undetected spam by admins to admin's chat (in this case MsgHandler will process them and ban/train)
                        <span class="cov8" title="25">if update.Message != nil &amp;&amp; l.isAdminChat(update.Message.Chat.ID, update.Message.From.UserName, update.Message.From.ID) </span><span class="cov1" title="1">{
                                if l.DisableAdminSpamForward </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov1" title="1">if err := l.adminHandler.MsgHandler(update); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[WARN] failed to process admin chat message: %v", err)
                                        errResp := l.sendBotResponse(bot.Response{Send: true, Text: "error: " + err.Error()}, l.adminChatID, NotificationDefault)
                                        if errResp != nil </span><span class="cov0" title="0">{
                                                log.Printf("[WARN] failed to respond on error, %v", errResp)
                                        }</span>
                                }
                                <span class="cov1" title="1">continue</span>
                        }

                        // handle admin chat inline buttons
                        <span class="cov8" title="24">if update.CallbackQuery != nil </span><span class="cov5" title="8">{
                                if err := l.adminHandler.InlineCallbackHandler(update.CallbackQuery); err != nil </span><span class="cov1" title="1">{
                                        log.Printf("[WARN] failed to process callback: %v", err)
                                        errResp := l.sendBotResponse(bot.Response{Send: true, Text: "error: " + err.Error()}, l.adminChatID, NotificationDefault)
                                        if errResp != nil </span><span class="cov0" title="0">{
                                                log.Printf("[WARN] failed to respond on error, %v", errResp)
                                        }</span>
                                }
                                <span class="cov5" title="8">continue</span>
                        }

                        <span class="cov7" title="16">if update.Message == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // save join messages to locator even if SuppressJoinMessage is set to false
                        <span class="cov7" title="16">if update.Message.NewChatMembers != nil </span><span class="cov1" title="1">{
                                err := l.procNewChatMemberMessage(update)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[WARN] failed to process new chat member: %v", err)
                                }</span>
                                <span class="cov1" title="1">continue</span>
                        }

                        // handle left member messages, i.e. "blah blah removed from the chat"
                        <span class="cov7" title="15">if update.Message.LeftChatMember != nil </span><span class="cov4" title="5">{
                                if l.SuppressJoinMessage </span><span class="cov4" title="4">{
                                        err := l.procLeftChatMemberMessage(update)
                                        if err != nil </span><span class="cov1" title="1">{
                                                log.Printf("[WARN] failed to process left chat member: %v", err)
                                        }</span>
                                }
                                <span class="cov4" title="5">continue</span>
                        }

                        // handle spam reports from superusers
                        <span class="cov6" title="10">fromSuper := l.SuperUsers.IsSuper(update.Message.From.UserName, update.Message.From.ID)
                        if update.Message.ReplyToMessage != nil &amp;&amp; fromSuper </span><span class="cov3" title="3">{
                                if l.procSuperReply(update) </span><span class="cov2" title="2">{
                                        // superuser command processed, skip the rest
                                        continue</span>
                                }
                        }

                        // process regular messages, the main part of the bot
                        <span class="cov5" title="8">if err := l.procEvents(update); err != nil </span><span class="cov4" title="4">{
                                log.Printf("[WARN] failed to process update: %v", err)
                                continue</span>
                        }

                case &lt;-time.After(l.IdleDuration):<span class="cov0" title="0"> // hit bots on idle timeout
                        resp := l.Bot.OnMessage(bot.Message{Text: "idle"}, false)
                        if err := l.sendBotResponse(resp, l.chatID, NotificationSilent); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[WARN] failed to respond on idle, %v", err)
                        }</span>
                }
        }
}

func (l *TelegramListener) procEvents(update tbapi.Update) error <span class="cov6" title="9">{
        msgJSON, errJSON := json.Marshal(update.Message)
        if errJSON != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal update.Message to json: %w", errJSON)
        }</span>
        <span class="cov6" title="9">fromChat := update.Message.Chat.ID
        // ignore messages from other chats except the one we are monitor and ones from the test list
        if !l.isChatAllowed(fromChat) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="9">log.Printf("[DEBUG] %s", string(msgJSON))
        msg := transform(update.Message)

        // ignore messages with empty text, no media, no video, no video note, no forward
        if strings.TrimSpace(msg.Text) == "" &amp;&amp; msg.Image == nil &amp;&amp; !msg.WithVideoNote &amp;&amp; !msg.WithVideo &amp;&amp; !msg.WithForward </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov6" title="9">ctx := context.TODO()
        log.Printf("[DEBUG] incoming msg: %+v", strings.ReplaceAll(msg.Text, "\n", " "))
        log.Printf("[DEBUG] incoming msg details: %+v", msg)
        if err := l.Locator.AddMessage(ctx, msg.Text, fromChat, msg.From.ID, msg.From.Username, msg.ID); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] failed to add message to locator: %v", err)
        }</span>
        <span class="cov6" title="9">resp := l.Bot.OnMessage(*msg, false)

        if !resp.Send </span><span class="cov0" title="0">{ // not spam
                return nil
        }</span>

        // send response to the channel if allowed
        <span class="cov6" title="9">if resp.Send &amp;&amp; !l.NoSpamReply &amp;&amp; !l.TrainingMode </span><span class="cov5" title="8">{
                if err := l.sendBotResponse(resp, fromChat, NotificationSilent); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to respond on update, %v", err)
                }</span>
        }

        <span class="cov6" title="9">errs := new(multierror.Error)

        // ban user if requested by bot
        if resp.Send &amp;&amp; resp.BanInterval &gt; 0 </span><span class="cov5" title="8">{
                log.Printf("[DEBUG] ban initiated for %+v", resp)
                l.SpamLogger.Save(msg, &amp;resp)
                if err := l.Locator.AddSpam(ctx, msg.From.ID, resp.CheckResults); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to add spam to locator: %v", err)
                }</span>
                <span class="cov5" title="8">banUserStr := l.getBanUsername(resp, update)

                if l.SuperUsers.IsSuper(msg.From.Username, msg.From.ID) </span><span class="cov1" title="1">{
                        if l.TrainingMode </span><span class="cov0" title="0">{
                                l.adminHandler.ReportBan(banUserStr, msg)
                        }</span>
                        <span class="cov1" title="1">log.Printf("[DEBUG] superuser %s requested ban, ignored", banUserStr)
                        return nil</span>
                }

                <span class="cov5" title="7">banReq := banRequest{duration: resp.BanInterval, userID: resp.User.ID, channelID: resp.ChannelID, userName: banUserStr,
                        chatID: fromChat, dry: l.Dry, training: l.TrainingMode, tbAPI: l.TbAPI, restrict: l.SoftBanMode}
                if err := banUserOrChannel(banReq); err != nil </span><span class="cov4" title="4">{
                        errs = multierror.Append(errs, fmt.Errorf("failed to ban %s: %w", banUserStr, err))
                }</span> else<span class="cov3" title="3"> if l.adminChatID != 0 &amp;&amp; msg.From.ID != 0 </span><span class="cov0" title="0">{
                        l.adminHandler.ReportBan(banUserStr, msg)
                }</span>
        }

        // delete message if requested by bot
        <span class="cov5" title="8">if resp.DeleteReplyTo &amp;&amp; resp.ReplyTo != 0 &amp;&amp; !l.Dry &amp;&amp; !l.SuperUsers.IsSuper(msg.From.Username, msg.From.ID) &amp;&amp; !l.TrainingMode </span><span class="cov1" title="1">{
                if _, err := l.TbAPI.Request(tbapi.DeleteMessageConfig{BaseChatMessage: tbapi.BaseChatMessage{
                        MessageID:  resp.ReplyTo,
                        ChatConfig: tbapi.ChatConfig{ChatID: l.chatID},
                }}); err != nil </span><span class="cov0" title="0">{
                        errs = multierror.Append(errs, fmt.Errorf("failed to delete message %d: %w", resp.ReplyTo, err))
                }</span>
        }

        <span class="cov5" title="8">if err := errs.ErrorOrNil(); err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("processing events failed: %w", err)
        }</span>
        <span class="cov4" title="4">return nil</span>
}

// procSuperReply processes superuser commands (reply) /spam, /ban, /warn
func (l *TelegramListener) procSuperReply(update tbapi.Update) (handled bool) <span class="cov3" title="3">{
        switch </span>{
        case strings.EqualFold(update.Message.Text, "/spam") || strings.EqualFold(update.Message.Text, "spam"):<span class="cov1" title="1">
                log.Printf("[DEBUG] superuser %s reported spam", update.Message.From.UserName)
                if err := l.adminHandler.DirectSpamReport(update); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to process direct spam report: %v", err)
                }</span>
                <span class="cov1" title="1">return true</span>
        case strings.EqualFold(update.Message.Text, "/ban") || strings.EqualFold(update.Message.Text, "ban"):<span class="cov0" title="0">
                log.Printf("[DEBUG] superuser %s requested ban", update.Message.From.UserName)
                if err := l.adminHandler.DirectBanReport(update); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to process direct ban request: %v", err)
                }</span>
                <span class="cov0" title="0">return true</span>
        case strings.EqualFold(update.Message.Text, "/warn") || strings.EqualFold(update.Message.Text, "warn"):<span class="cov1" title="1">
                log.Printf("[DEBUG] superuser %s requested warning", update.Message.From.UserName)
                if err := l.adminHandler.DirectWarnReport(update); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to process direct warning request: %v", err)
                }</span>
                <span class="cov1" title="1">return true</span>
        }
        <span class="cov1" title="1">return false</span>
}

// procNewChatMemberMessage saves new chat member message to locator. It is used to delete the message if the user kicked out
func (l *TelegramListener) procNewChatMemberMessage(update tbapi.Update) error <span class="cov5" title="6">{
        fromChat := update.Message.Chat.ID
        // ignore messages from other chats except the one we are monitor and ones from the test list
        if !l.isChatAllowed(fromChat) </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="5">if len(update.Message.NewChatMembers) != 1 </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] we are expecting only one new chat member, got %d", len(update.Message.NewChatMembers))
                return nil
        }</span>

        <span class="cov3" title="3">errs := new(multierror.Error)

        member := update.Message.NewChatMembers[0]
        msg := fmt.Sprintf("new_%d_%d", fromChat, member.ID)
        if err := l.Locator.AddMessage(context.TODO(), msg, fromChat, member.ID, "", update.Message.MessageID); err != nil </span><span class="cov0" title="0">{
                errs = multierror.Append(errs, fmt.Errorf("failed to add new chat member message to locator: %w", err))
        }</span>

        <span class="cov3" title="3">if err := errs.ErrorOrNil(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process new chat member: %w", err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

// procLeftChatMemberMessage deletes the message about new chat member if the user kicked out
func (l *TelegramListener) procLeftChatMemberMessage(update tbapi.Update) error <span class="cov6" title="9">{
        fromChat := update.Message.Chat.ID
        // ignore messages from other chats except the one we are monitor and ones from the test list
        if !l.isChatAllowed(fromChat) </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="8">if update.Message.From.ID == update.Message.LeftChatMember.ID </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] left chat member is the same as the message sender, ignored")
                return nil
        }</span>
        <span class="cov5" title="6">msg, found := l.Locator.Message(context.TODO(), fmt.Sprintf("new_%d_%d", fromChat, update.Message.LeftChatMember.ID))
        if !found </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] no new chat member message found for %d in chat %d", update.Message.LeftChatMember.ID, fromChat)
                return nil
        }</span>
        <span class="cov4" title="4">if _, err := l.TbAPI.Request(tbapi.DeleteMessageConfig{
                BaseChatMessage: tbapi.BaseChatMessage{ChatConfig: tbapi.ChatConfig{ChatID: fromChat}, MessageID: msg.MsgID},
        }); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("failed to delete new chat member message %d: %w", msg.MsgID, err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

func (l *TelegramListener) isChatAllowed(fromChat int64) bool <span class="cov8" title="27">{
        if fromChat == l.chatID </span><span class="cov8" title="23">{
                return true
        }</span>
        <span class="cov4" title="4">for _, id := range l.TestingIDs </span><span class="cov2" title="2">{
                if id == fromChat </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

func (l *TelegramListener) isAdminChat(fromChat int64, from string, fromID int64) bool <span class="cov8" title="21">{
        if fromChat == l.adminChatID </span><span class="cov3" title="3">{
                log.Printf("[DEBUG] message in admin chat %d, from %s (%d)", fromChat, from, fromID)
                if !l.SuperUsers.IsSuper(from, fromID) </span><span class="cov1" title="1">{
                        log.Printf("[DEBUG] %s (%d) is not superuser in admin chat, ignored", from, fromID)
                        return false
                }</span>
                <span class="cov2" title="2">return true</span>
        }
        <span class="cov7" title="18">return false</span>
}

func (l *TelegramListener) getBanUsername(resp bot.Response, update tbapi.Update) string <span class="cov5" title="8">{
        if resp.ChannelID == 0 </span><span class="cov4" title="4">{
                return fmt.Sprintf("%v", resp.User)
        }</span>
        <span class="cov4" title="4">botChat := bot.SenderChat{
                ID: resp.ChannelID,
        }
        if update.Message.SenderChat != nil </span><span class="cov3" title="3">{
                botChat.UserName = update.Message.SenderChat.UserName
        }</span>
        // if botChat.UserName not set, that means the ban comes from superuser and username should be taken from ReplyToMessage
        <span class="cov4" title="4">if botChat.UserName == "" &amp;&amp; update.Message.ReplyToMessage.SenderChat != nil </span><span class="cov2" title="2">{
                if update.Message.ReplyToMessage.ForwardOrigin != nil </span><span class="cov0" title="0">{
                        if update.Message.ReplyToMessage.ForwardOrigin.IsUser() </span><span class="cov0" title="0">{
                                botChat.UserName = update.Message.ReplyToMessage.ForwardOrigin.SenderUser.UserName
                        }</span>
                        <span class="cov0" title="0">if update.Message.ReplyToMessage.ForwardOrigin.IsHiddenUser() </span><span class="cov0" title="0">{
                                botChat.UserName = update.Message.ReplyToMessage.ForwardOrigin.SenderUserName
                        }</span>
                }
        }
        <span class="cov4" title="4">return fmt.Sprintf("%v", botChat)</span>
}

// NotificationType defines how a message is delivered to users
type NotificationType int

const (
        // NotificationDefault sends message with standard notification
        NotificationDefault NotificationType = iota
        // NotificationSilent sends message without sound
        NotificationSilent
)

// sendBotResponse sends bot's answer to tg channel
// actionText is a text for the button to unban user, optional
func (l *TelegramListener) sendBotResponse(resp bot.Response, chatID int64, notifyType NotificationType) error <span class="cov6" title="13">{
        if !resp.Send </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="13">log.Printf("[DEBUG] bot response - %+v, reply-to:%d", strings.ReplaceAll(resp.Text, "\n", "\\n"), resp.ReplyTo)
        tbMsg := tbapi.NewMessage(chatID, resp.Text)
        tbMsg.ParseMode = tbapi.ModeMarkdown
        tbMsg.LinkPreviewOptions = tbapi.LinkPreviewOptions{IsDisabled: true}
        tbMsg.ReplyParameters = tbapi.ReplyParameters{MessageID: resp.ReplyTo}
        tbMsg.DisableNotification = notifyType == NotificationSilent

        if err := send(tbMsg, l.TbAPI); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't send message to telegram %q: %w", resp.Text, err)
        }</span>

        <span class="cov6" title="13">return nil</span>
}

func (l *TelegramListener) getChatID(group string) (int64, error) <span class="cov9" title="35">{
        chatID, err := strconv.ParseInt(group, 10, 64)
        if err == nil </span><span class="cov6" title="10">{
                return chatID, nil
        }</span>

        <span class="cov8" title="25">chat, err := l.TbAPI.GetChat(tbapi.ChatInfoConfig{ChatConfig: tbapi.ChatConfig{SuperGroupUsername: "@" + group}})
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("can't get chat for %s: %w", group, err)
        }</span>

        <span class="cov8" title="25">return chat.ID, nil</span>
}

// updateSupers updates the list of super-users based on the chat administrators fetched from the Telegram API.
// it uses the user ID first, but can match by username if set in the list of super-users.
func (l *TelegramListener) updateSupers() error <span class="cov8" title="32">{
        isSuper := func(username string, id int64) bool </span><span class="cov6" title="11">{
                for _, super := range l.SuperUsers </span><span class="cov6" title="9">{
                        if super == fmt.Sprintf("%d", id) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov6" title="9">if username != "" &amp;&amp; super == username </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
                <span class="cov6" title="10">return false</span>
        }

        <span class="cov8" title="32">admins, err := l.TbAPI.GetChatAdministrators(tbapi.ChatAdministratorsConfig{ChatConfig: tbapi.ChatConfig{ChatID: l.chatID}})
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get chat administrators: %w", err)
        }</span>

        <span class="cov8" title="31">for _, admin := range admins </span><span class="cov6" title="12">{
                if admin.User.UserName == "" &amp;&amp; admin.User.ID == 0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov6" title="11">if isSuper(admin.User.UserName, admin.User.ID) </span><span class="cov1" title="1">{
                        continue</span> // already in the list
                }
                <span class="cov6" title="10">l.SuperUsers = append(l.SuperUsers, fmt.Sprintf("%d", admin.User.ID))</span>
        }

        <span class="cov8" title="31">log.Printf("[INFO] added admins, full list of supers: {%s}", strings.Join(l.SuperUsers, ", "))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting chat administrators: %w", err)
        }</span>
        <span class="cov8" title="31">return nil</span>
}

// SuperUsers for moderators. Can be either username or user ID.
type SuperUsers []string

// IsSuper checks if userID or username in the list of superusers
// First it treats super as user ID, then as username
func (s SuperUsers) IsSuper(userName string, userID int64) bool <span class="cov9" title="41">{
        for _, super := range s </span><span class="cov9" title="42">{
                if id, err := strconv.ParseInt(super, 10, 64); err == nil </span><span class="cov3" title="3">{
                        // super is user ID
                        if userID == id </span><span class="cov1" title="1">{
                                return true
                        }</span>
                        <span class="cov2" title="2">continue</span>
                }
                // super is username
                <span class="cov9" title="39">if strings.EqualFold(userName, super) || strings.EqualFold("/"+userName, super) </span><span class="cov6" title="10">{
                        return true
                }</span>
        }
        <span class="cov8" title="30">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "github.com/umputun/tg-spam/app/bot"
        "sync"
)

// BotMock is a mock implementation of events.Bot.
//
//        func TestSomethingThatUsesBot(t *testing.T) {
//
//                // make and configure a mocked events.Bot
//                mockedBot := &amp;BotMock{
//                        AddApprovedUserFunc: func(id int64, name string) error {
//                                panic("mock out the AddApprovedUser method")
//                        },
//                        IsApprovedUserFunc: func(userID int64) bool {
//                                panic("mock out the IsApprovedUser method")
//                        },
//                        OnMessageFunc: func(msg bot.Message, checkOnly bool) bot.Response {
//                                panic("mock out the OnMessage method")
//                        },
//                        RemoveApprovedUserFunc: func(id int64) error {
//                                panic("mock out the RemoveApprovedUser method")
//                        },
//                        UpdateHamFunc: func(msg string) error {
//                                panic("mock out the UpdateHam method")
//                        },
//                        UpdateSpamFunc: func(msg string) error {
//                                panic("mock out the UpdateSpam method")
//                        },
//                }
//
//                // use mockedBot in code that requires events.Bot
//                // and then make assertions.
//
//        }
type BotMock struct {
        // AddApprovedUserFunc mocks the AddApprovedUser method.
        AddApprovedUserFunc func(id int64, name string) error

        // IsApprovedUserFunc mocks the IsApprovedUser method.
        IsApprovedUserFunc func(userID int64) bool

        // OnMessageFunc mocks the OnMessage method.
        OnMessageFunc func(msg bot.Message, checkOnly bool) bot.Response

        // RemoveApprovedUserFunc mocks the RemoveApprovedUser method.
        RemoveApprovedUserFunc func(id int64) error

        // UpdateHamFunc mocks the UpdateHam method.
        UpdateHamFunc func(msg string) error

        // UpdateSpamFunc mocks the UpdateSpam method.
        UpdateSpamFunc func(msg string) error

        // calls tracks calls to the methods.
        calls struct {
                // AddApprovedUser holds details about calls to the AddApprovedUser method.
                AddApprovedUser []struct {
                        // ID is the id argument value.
                        ID int64
                        // Name is the name argument value.
                        Name string
                }
                // IsApprovedUser holds details about calls to the IsApprovedUser method.
                IsApprovedUser []struct {
                        // UserID is the userID argument value.
                        UserID int64
                }
                // OnMessage holds details about calls to the OnMessage method.
                OnMessage []struct {
                        // Msg is the msg argument value.
                        Msg bot.Message
                        // CheckOnly is the checkOnly argument value.
                        CheckOnly bool
                }
                // RemoveApprovedUser holds details about calls to the RemoveApprovedUser method.
                RemoveApprovedUser []struct {
                        // ID is the id argument value.
                        ID int64
                }
                // UpdateHam holds details about calls to the UpdateHam method.
                UpdateHam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // UpdateSpam holds details about calls to the UpdateSpam method.
                UpdateSpam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
        }
        lockAddApprovedUser    sync.RWMutex
        lockIsApprovedUser     sync.RWMutex
        lockOnMessage          sync.RWMutex
        lockRemoveApprovedUser sync.RWMutex
        lockUpdateHam          sync.RWMutex
        lockUpdateSpam         sync.RWMutex
}

// AddApprovedUser calls AddApprovedUserFunc.
func (mock *BotMock) AddApprovedUser(id int64, name string) error <span class="cov0" title="0">{
        if mock.AddApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("BotMock.AddApprovedUserFunc: method is nil but Bot.AddApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                ID   int64
                Name string
        }{
                ID:   id,
                Name: name,
        }
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = append(mock.calls.AddApprovedUser, callInfo)
        mock.lockAddApprovedUser.Unlock()
        return mock.AddApprovedUserFunc(id, name)</span>
}

// AddApprovedUserCalls gets all the calls that were made to AddApprovedUser.
// Check the length with:
//
//        len(mockedBot.AddApprovedUserCalls())
func (mock *BotMock) AddApprovedUserCalls() []struct {
        ID   int64
        Name string
} <span class="cov0" title="0">{
        var calls []struct {
                ID   int64
                Name string
        }
        mock.lockAddApprovedUser.RLock()
        calls = mock.calls.AddApprovedUser
        mock.lockAddApprovedUser.RUnlock()
        return calls
}</span>

// ResetAddApprovedUserCalls reset all the calls that were made to AddApprovedUser.
func (mock *BotMock) ResetAddApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = nil
        mock.lockAddApprovedUser.Unlock()
}</span>

// IsApprovedUser calls IsApprovedUserFunc.
func (mock *BotMock) IsApprovedUser(userID int64) bool <span class="cov0" title="0">{
        if mock.IsApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("BotMock.IsApprovedUserFunc: method is nil but Bot.IsApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                UserID int64
        }{
                UserID: userID,
        }
        mock.lockIsApprovedUser.Lock()
        mock.calls.IsApprovedUser = append(mock.calls.IsApprovedUser, callInfo)
        mock.lockIsApprovedUser.Unlock()
        return mock.IsApprovedUserFunc(userID)</span>
}

// IsApprovedUserCalls gets all the calls that were made to IsApprovedUser.
// Check the length with:
//
//        len(mockedBot.IsApprovedUserCalls())
func (mock *BotMock) IsApprovedUserCalls() []struct {
        UserID int64
} <span class="cov0" title="0">{
        var calls []struct {
                UserID int64
        }
        mock.lockIsApprovedUser.RLock()
        calls = mock.calls.IsApprovedUser
        mock.lockIsApprovedUser.RUnlock()
        return calls
}</span>

// ResetIsApprovedUserCalls reset all the calls that were made to IsApprovedUser.
func (mock *BotMock) ResetIsApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockIsApprovedUser.Lock()
        mock.calls.IsApprovedUser = nil
        mock.lockIsApprovedUser.Unlock()
}</span>

// OnMessage calls OnMessageFunc.
func (mock *BotMock) OnMessage(msg bot.Message, checkOnly bool) bot.Response <span class="cov0" title="0">{
        if mock.OnMessageFunc == nil </span><span class="cov0" title="0">{
                panic("BotMock.OnMessageFunc: method is nil but Bot.OnMessage was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg       bot.Message
                CheckOnly bool
        }{
                Msg:       msg,
                CheckOnly: checkOnly,
        }
        mock.lockOnMessage.Lock()
        mock.calls.OnMessage = append(mock.calls.OnMessage, callInfo)
        mock.lockOnMessage.Unlock()
        return mock.OnMessageFunc(msg, checkOnly)</span>
}

// OnMessageCalls gets all the calls that were made to OnMessage.
// Check the length with:
//
//        len(mockedBot.OnMessageCalls())
func (mock *BotMock) OnMessageCalls() []struct {
        Msg       bot.Message
        CheckOnly bool
} <span class="cov0" title="0">{
        var calls []struct {
                Msg       bot.Message
                CheckOnly bool
        }
        mock.lockOnMessage.RLock()
        calls = mock.calls.OnMessage
        mock.lockOnMessage.RUnlock()
        return calls
}</span>

// ResetOnMessageCalls reset all the calls that were made to OnMessage.
func (mock *BotMock) ResetOnMessageCalls() <span class="cov0" title="0">{
        mock.lockOnMessage.Lock()
        mock.calls.OnMessage = nil
        mock.lockOnMessage.Unlock()
}</span>

// RemoveApprovedUser calls RemoveApprovedUserFunc.
func (mock *BotMock) RemoveApprovedUser(id int64) error <span class="cov0" title="0">{
        if mock.RemoveApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("BotMock.RemoveApprovedUserFunc: method is nil but Bot.RemoveApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                ID int64
        }{
                ID: id,
        }
        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = append(mock.calls.RemoveApprovedUser, callInfo)
        mock.lockRemoveApprovedUser.Unlock()
        return mock.RemoveApprovedUserFunc(id)</span>
}

// RemoveApprovedUserCalls gets all the calls that were made to RemoveApprovedUser.
// Check the length with:
//
//        len(mockedBot.RemoveApprovedUserCalls())
func (mock *BotMock) RemoveApprovedUserCalls() []struct {
        ID int64
} <span class="cov0" title="0">{
        var calls []struct {
                ID int64
        }
        mock.lockRemoveApprovedUser.RLock()
        calls = mock.calls.RemoveApprovedUser
        mock.lockRemoveApprovedUser.RUnlock()
        return calls
}</span>

// ResetRemoveApprovedUserCalls reset all the calls that were made to RemoveApprovedUser.
func (mock *BotMock) ResetRemoveApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = nil
        mock.lockRemoveApprovedUser.Unlock()
}</span>

// UpdateHam calls UpdateHamFunc.
func (mock *BotMock) UpdateHam(msg string) error <span class="cov0" title="0">{
        if mock.UpdateHamFunc == nil </span><span class="cov0" title="0">{
                panic("BotMock.UpdateHamFunc: method is nil but Bot.UpdateHam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = append(mock.calls.UpdateHam, callInfo)
        mock.lockUpdateHam.Unlock()
        return mock.UpdateHamFunc(msg)</span>
}

// UpdateHamCalls gets all the calls that were made to UpdateHam.
// Check the length with:
//
//        len(mockedBot.UpdateHamCalls())
func (mock *BotMock) UpdateHamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockUpdateHam.RLock()
        calls = mock.calls.UpdateHam
        mock.lockUpdateHam.RUnlock()
        return calls
}</span>

// ResetUpdateHamCalls reset all the calls that were made to UpdateHam.
func (mock *BotMock) ResetUpdateHamCalls() <span class="cov0" title="0">{
        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = nil
        mock.lockUpdateHam.Unlock()
}</span>

// UpdateSpam calls UpdateSpamFunc.
func (mock *BotMock) UpdateSpam(msg string) error <span class="cov0" title="0">{
        if mock.UpdateSpamFunc == nil </span><span class="cov0" title="0">{
                panic("BotMock.UpdateSpamFunc: method is nil but Bot.UpdateSpam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = append(mock.calls.UpdateSpam, callInfo)
        mock.lockUpdateSpam.Unlock()
        return mock.UpdateSpamFunc(msg)</span>
}

// UpdateSpamCalls gets all the calls that were made to UpdateSpam.
// Check the length with:
//
//        len(mockedBot.UpdateSpamCalls())
func (mock *BotMock) UpdateSpamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockUpdateSpam.RLock()
        calls = mock.calls.UpdateSpam
        mock.lockUpdateSpam.RUnlock()
        return calls
}</span>

// ResetUpdateSpamCalls reset all the calls that were made to UpdateSpam.
func (mock *BotMock) ResetUpdateSpamCalls() <span class="cov0" title="0">{
        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = nil
        mock.lockUpdateSpam.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *BotMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = nil
        mock.lockAddApprovedUser.Unlock()

        mock.lockIsApprovedUser.Lock()
        mock.calls.IsApprovedUser = nil
        mock.lockIsApprovedUser.Unlock()

        mock.lockOnMessage.Lock()
        mock.calls.OnMessage = nil
        mock.lockOnMessage.Unlock()

        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = nil
        mock.lockRemoveApprovedUser.Unlock()

        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = nil
        mock.lockUpdateHam.Unlock()

        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = nil
        mock.lockUpdateSpam.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/umputun/tg-spam/app/storage"
        "github.com/umputun/tg-spam/lib/spamcheck"
        "sync"
)

// LocatorMock is a mock implementation of events.Locator.
//
//        func TestSomethingThatUsesLocator(t *testing.T) {
//
//                // make and configure a mocked events.Locator
//                mockedLocator := &amp;LocatorMock{
//                        AddMessageFunc: func(ctx context.Context, msg string, chatID int64, userID int64, userName string, msgID int) error {
//                                panic("mock out the AddMessage method")
//                        },
//                        AddSpamFunc: func(ctx context.Context, userID int64, checks []spamcheck.Response) error {
//                                panic("mock out the AddSpam method")
//                        },
//                        MessageFunc: func(ctx context.Context, msg string) (storage.MsgMeta, bool) {
//                                panic("mock out the Message method")
//                        },
//                        MsgHashFunc: func(msg string) string {
//                                panic("mock out the MsgHash method")
//                        },
//                        SpamFunc: func(ctx context.Context, userID int64) (storage.SpamData, bool) {
//                                panic("mock out the Spam method")
//                        },
//                        UserNameByIDFunc: func(ctx context.Context, userID int64) string {
//                                panic("mock out the UserNameByID method")
//                        },
//                }
//
//                // use mockedLocator in code that requires events.Locator
//                // and then make assertions.
//
//        }
type LocatorMock struct {
        // AddMessageFunc mocks the AddMessage method.
        AddMessageFunc func(ctx context.Context, msg string, chatID int64, userID int64, userName string, msgID int) error

        // AddSpamFunc mocks the AddSpam method.
        AddSpamFunc func(ctx context.Context, userID int64, checks []spamcheck.Response) error

        // MessageFunc mocks the Message method.
        MessageFunc func(ctx context.Context, msg string) (storage.MsgMeta, bool)

        // MsgHashFunc mocks the MsgHash method.
        MsgHashFunc func(msg string) string

        // SpamFunc mocks the Spam method.
        SpamFunc func(ctx context.Context, userID int64) (storage.SpamData, bool)

        // UserNameByIDFunc mocks the UserNameByID method.
        UserNameByIDFunc func(ctx context.Context, userID int64) string

        // calls tracks calls to the methods.
        calls struct {
                // AddMessage holds details about calls to the AddMessage method.
                AddMessage []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // Msg is the msg argument value.
                        Msg string
                        // ChatID is the chatID argument value.
                        ChatID int64
                        // UserID is the userID argument value.
                        UserID int64
                        // UserName is the userName argument value.
                        UserName string
                        // MsgID is the msgID argument value.
                        MsgID int
                }
                // AddSpam holds details about calls to the AddSpam method.
                AddSpam []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // UserID is the userID argument value.
                        UserID int64
                        // Checks is the checks argument value.
                        Checks []spamcheck.Response
                }
                // Message holds details about calls to the Message method.
                Message []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // Msg is the msg argument value.
                        Msg string
                }
                // MsgHash holds details about calls to the MsgHash method.
                MsgHash []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // Spam holds details about calls to the Spam method.
                Spam []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // UserID is the userID argument value.
                        UserID int64
                }
                // UserNameByID holds details about calls to the UserNameByID method.
                UserNameByID []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // UserID is the userID argument value.
                        UserID int64
                }
        }
        lockAddMessage   sync.RWMutex
        lockAddSpam      sync.RWMutex
        lockMessage      sync.RWMutex
        lockMsgHash      sync.RWMutex
        lockSpam         sync.RWMutex
        lockUserNameByID sync.RWMutex
}

// AddMessage calls AddMessageFunc.
func (mock *LocatorMock) AddMessage(ctx context.Context, msg string, chatID int64, userID int64, userName string, msgID int) error <span class="cov0" title="0">{
        if mock.AddMessageFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.AddMessageFunc: method is nil but Locator.AddMessage was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx      context.Context
                Msg      string
                ChatID   int64
                UserID   int64
                UserName string
                MsgID    int
        }{
                Ctx:      ctx,
                Msg:      msg,
                ChatID:   chatID,
                UserID:   userID,
                UserName: userName,
                MsgID:    msgID,
        }
        mock.lockAddMessage.Lock()
        mock.calls.AddMessage = append(mock.calls.AddMessage, callInfo)
        mock.lockAddMessage.Unlock()
        return mock.AddMessageFunc(ctx, msg, chatID, userID, userName, msgID)</span>
}

// AddMessageCalls gets all the calls that were made to AddMessage.
// Check the length with:
//
//        len(mockedLocator.AddMessageCalls())
func (mock *LocatorMock) AddMessageCalls() []struct {
        Ctx      context.Context
        Msg      string
        ChatID   int64
        UserID   int64
        UserName string
        MsgID    int
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx      context.Context
                Msg      string
                ChatID   int64
                UserID   int64
                UserName string
                MsgID    int
        }
        mock.lockAddMessage.RLock()
        calls = mock.calls.AddMessage
        mock.lockAddMessage.RUnlock()
        return calls
}</span>

// ResetAddMessageCalls reset all the calls that were made to AddMessage.
func (mock *LocatorMock) ResetAddMessageCalls() <span class="cov0" title="0">{
        mock.lockAddMessage.Lock()
        mock.calls.AddMessage = nil
        mock.lockAddMessage.Unlock()
}</span>

// AddSpam calls AddSpamFunc.
func (mock *LocatorMock) AddSpam(ctx context.Context, userID int64, checks []spamcheck.Response) error <span class="cov0" title="0">{
        if mock.AddSpamFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.AddSpamFunc: method is nil but Locator.AddSpam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx    context.Context
                UserID int64
                Checks []spamcheck.Response
        }{
                Ctx:    ctx,
                UserID: userID,
                Checks: checks,
        }
        mock.lockAddSpam.Lock()
        mock.calls.AddSpam = append(mock.calls.AddSpam, callInfo)
        mock.lockAddSpam.Unlock()
        return mock.AddSpamFunc(ctx, userID, checks)</span>
}

// AddSpamCalls gets all the calls that were made to AddSpam.
// Check the length with:
//
//        len(mockedLocator.AddSpamCalls())
func (mock *LocatorMock) AddSpamCalls() []struct {
        Ctx    context.Context
        UserID int64
        Checks []spamcheck.Response
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx    context.Context
                UserID int64
                Checks []spamcheck.Response
        }
        mock.lockAddSpam.RLock()
        calls = mock.calls.AddSpam
        mock.lockAddSpam.RUnlock()
        return calls
}</span>

// ResetAddSpamCalls reset all the calls that were made to AddSpam.
func (mock *LocatorMock) ResetAddSpamCalls() <span class="cov0" title="0">{
        mock.lockAddSpam.Lock()
        mock.calls.AddSpam = nil
        mock.lockAddSpam.Unlock()
}</span>

// Message calls MessageFunc.
func (mock *LocatorMock) Message(ctx context.Context, msg string) (storage.MsgMeta, bool) <span class="cov0" title="0">{
        if mock.MessageFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.MessageFunc: method is nil but Locator.Message was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                Msg string
        }{
                Ctx: ctx,
                Msg: msg,
        }
        mock.lockMessage.Lock()
        mock.calls.Message = append(mock.calls.Message, callInfo)
        mock.lockMessage.Unlock()
        return mock.MessageFunc(ctx, msg)</span>
}

// MessageCalls gets all the calls that were made to Message.
// Check the length with:
//
//        len(mockedLocator.MessageCalls())
func (mock *LocatorMock) MessageCalls() []struct {
        Ctx context.Context
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                Msg string
        }
        mock.lockMessage.RLock()
        calls = mock.calls.Message
        mock.lockMessage.RUnlock()
        return calls
}</span>

// ResetMessageCalls reset all the calls that were made to Message.
func (mock *LocatorMock) ResetMessageCalls() <span class="cov0" title="0">{
        mock.lockMessage.Lock()
        mock.calls.Message = nil
        mock.lockMessage.Unlock()
}</span>

// MsgHash calls MsgHashFunc.
func (mock *LocatorMock) MsgHash(msg string) string <span class="cov0" title="0">{
        if mock.MsgHashFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.MsgHashFunc: method is nil but Locator.MsgHash was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockMsgHash.Lock()
        mock.calls.MsgHash = append(mock.calls.MsgHash, callInfo)
        mock.lockMsgHash.Unlock()
        return mock.MsgHashFunc(msg)</span>
}

// MsgHashCalls gets all the calls that were made to MsgHash.
// Check the length with:
//
//        len(mockedLocator.MsgHashCalls())
func (mock *LocatorMock) MsgHashCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockMsgHash.RLock()
        calls = mock.calls.MsgHash
        mock.lockMsgHash.RUnlock()
        return calls
}</span>

// ResetMsgHashCalls reset all the calls that were made to MsgHash.
func (mock *LocatorMock) ResetMsgHashCalls() <span class="cov0" title="0">{
        mock.lockMsgHash.Lock()
        mock.calls.MsgHash = nil
        mock.lockMsgHash.Unlock()
}</span>

// Spam calls SpamFunc.
func (mock *LocatorMock) Spam(ctx context.Context, userID int64) (storage.SpamData, bool) <span class="cov0" title="0">{
        if mock.SpamFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.SpamFunc: method is nil but Locator.Spam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx    context.Context
                UserID int64
        }{
                Ctx:    ctx,
                UserID: userID,
        }
        mock.lockSpam.Lock()
        mock.calls.Spam = append(mock.calls.Spam, callInfo)
        mock.lockSpam.Unlock()
        return mock.SpamFunc(ctx, userID)</span>
}

// SpamCalls gets all the calls that were made to Spam.
// Check the length with:
//
//        len(mockedLocator.SpamCalls())
func (mock *LocatorMock) SpamCalls() []struct {
        Ctx    context.Context
        UserID int64
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx    context.Context
                UserID int64
        }
        mock.lockSpam.RLock()
        calls = mock.calls.Spam
        mock.lockSpam.RUnlock()
        return calls
}</span>

// ResetSpamCalls reset all the calls that were made to Spam.
func (mock *LocatorMock) ResetSpamCalls() <span class="cov0" title="0">{
        mock.lockSpam.Lock()
        mock.calls.Spam = nil
        mock.lockSpam.Unlock()
}</span>

// UserNameByID calls UserNameByIDFunc.
func (mock *LocatorMock) UserNameByID(ctx context.Context, userID int64) string <span class="cov0" title="0">{
        if mock.UserNameByIDFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.UserNameByIDFunc: method is nil but Locator.UserNameByID was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx    context.Context
                UserID int64
        }{
                Ctx:    ctx,
                UserID: userID,
        }
        mock.lockUserNameByID.Lock()
        mock.calls.UserNameByID = append(mock.calls.UserNameByID, callInfo)
        mock.lockUserNameByID.Unlock()
        return mock.UserNameByIDFunc(ctx, userID)</span>
}

// UserNameByIDCalls gets all the calls that were made to UserNameByID.
// Check the length with:
//
//        len(mockedLocator.UserNameByIDCalls())
func (mock *LocatorMock) UserNameByIDCalls() []struct {
        Ctx    context.Context
        UserID int64
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx    context.Context
                UserID int64
        }
        mock.lockUserNameByID.RLock()
        calls = mock.calls.UserNameByID
        mock.lockUserNameByID.RUnlock()
        return calls
}</span>

// ResetUserNameByIDCalls reset all the calls that were made to UserNameByID.
func (mock *LocatorMock) ResetUserNameByIDCalls() <span class="cov0" title="0">{
        mock.lockUserNameByID.Lock()
        mock.calls.UserNameByID = nil
        mock.lockUserNameByID.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *LocatorMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockAddMessage.Lock()
        mock.calls.AddMessage = nil
        mock.lockAddMessage.Unlock()

        mock.lockAddSpam.Lock()
        mock.calls.AddSpam = nil
        mock.lockAddSpam.Unlock()

        mock.lockMessage.Lock()
        mock.calls.Message = nil
        mock.lockMessage.Unlock()

        mock.lockMsgHash.Lock()
        mock.calls.MsgHash = nil
        mock.lockMsgHash.Unlock()

        mock.lockSpam.Lock()
        mock.calls.Spam = nil
        mock.lockSpam.Unlock()

        mock.lockUserNameByID.Lock()
        mock.calls.UserNameByID = nil
        mock.lockUserNameByID.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "github.com/umputun/tg-spam/app/bot"
        "sync"
)

// SpamLoggerMock is a mock implementation of events.SpamLogger.
//
//        func TestSomethingThatUsesSpamLogger(t *testing.T) {
//
//                // make and configure a mocked events.SpamLogger
//                mockedSpamLogger := &amp;SpamLoggerMock{
//                        SaveFunc: func(msg *bot.Message, response *bot.Response)  {
//                                panic("mock out the Save method")
//                        },
//                }
//
//                // use mockedSpamLogger in code that requires events.SpamLogger
//                // and then make assertions.
//
//        }
type SpamLoggerMock struct {
        // SaveFunc mocks the Save method.
        SaveFunc func(msg *bot.Message, response *bot.Response)

        // calls tracks calls to the methods.
        calls struct {
                // Save holds details about calls to the Save method.
                Save []struct {
                        // Msg is the msg argument value.
                        Msg *bot.Message
                        // Response is the response argument value.
                        Response *bot.Response
                }
        }
        lockSave sync.RWMutex
}

// Save calls SaveFunc.
func (mock *SpamLoggerMock) Save(msg *bot.Message, response *bot.Response) <span class="cov0" title="0">{
        if mock.SaveFunc == nil </span><span class="cov0" title="0">{
                panic("SpamLoggerMock.SaveFunc: method is nil but SpamLogger.Save was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg      *bot.Message
                Response *bot.Response
        }{
                Msg:      msg,
                Response: response,
        }
        mock.lockSave.Lock()
        mock.calls.Save = append(mock.calls.Save, callInfo)
        mock.lockSave.Unlock()
        mock.SaveFunc(msg, response)</span>
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//        len(mockedSpamLogger.SaveCalls())
func (mock *SpamLoggerMock) SaveCalls() []struct {
        Msg      *bot.Message
        Response *bot.Response
} <span class="cov0" title="0">{
        var calls []struct {
                Msg      *bot.Message
                Response *bot.Response
        }
        mock.lockSave.RLock()
        calls = mock.calls.Save
        mock.lockSave.RUnlock()
        return calls
}</span>

// ResetSaveCalls reset all the calls that were made to Save.
func (mock *SpamLoggerMock) ResetSaveCalls() <span class="cov0" title="0">{
        mock.lockSave.Lock()
        mock.calls.Save = nil
        mock.lockSave.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SpamLoggerMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockSave.Lock()
        mock.calls.Save = nil
        mock.lockSave.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        tbapi "github.com/OvyFlash/telegram-bot-api"
        "sync"
)

// TbAPIMock is a mock implementation of events.TbAPI.
//
//        func TestSomethingThatUsesTbAPI(t *testing.T) {
//
//                // make and configure a mocked events.TbAPI
//                mockedTbAPI := &amp;TbAPIMock{
//                        GetChatFunc: func(config tbapi.ChatInfoConfig) (tbapi.ChatFullInfo, error) {
//                                panic("mock out the GetChat method")
//                        },
//                        GetChatAdministratorsFunc: func(config tbapi.ChatAdministratorsConfig) ([]tbapi.ChatMember, error) {
//                                panic("mock out the GetChatAdministrators method")
//                        },
//                        GetUpdatesChanFunc: func(config tbapi.UpdateConfig) tbapi.UpdatesChannel {
//                                panic("mock out the GetUpdatesChan method")
//                        },
//                        RequestFunc: func(c tbapi.Chattable) (*tbapi.APIResponse, error) {
//                                panic("mock out the Request method")
//                        },
//                        SendFunc: func(c tbapi.Chattable) (tbapi.Message, error) {
//                                panic("mock out the Send method")
//                        },
//                }
//
//                // use mockedTbAPI in code that requires events.TbAPI
//                // and then make assertions.
//
//        }
type TbAPIMock struct {
        // GetChatFunc mocks the GetChat method.
        GetChatFunc func(config tbapi.ChatInfoConfig) (tbapi.ChatFullInfo, error)

        // GetChatAdministratorsFunc mocks the GetChatAdministrators method.
        GetChatAdministratorsFunc func(config tbapi.ChatAdministratorsConfig) ([]tbapi.ChatMember, error)

        // GetUpdatesChanFunc mocks the GetUpdatesChan method.
        GetUpdatesChanFunc func(config tbapi.UpdateConfig) tbapi.UpdatesChannel

        // RequestFunc mocks the Request method.
        RequestFunc func(c tbapi.Chattable) (*tbapi.APIResponse, error)

        // SendFunc mocks the Send method.
        SendFunc func(c tbapi.Chattable) (tbapi.Message, error)

        // calls tracks calls to the methods.
        calls struct {
                // GetChat holds details about calls to the GetChat method.
                GetChat []struct {
                        // Config is the config argument value.
                        Config tbapi.ChatInfoConfig
                }
                // GetChatAdministrators holds details about calls to the GetChatAdministrators method.
                GetChatAdministrators []struct {
                        // Config is the config argument value.
                        Config tbapi.ChatAdministratorsConfig
                }
                // GetUpdatesChan holds details about calls to the GetUpdatesChan method.
                GetUpdatesChan []struct {
                        // Config is the config argument value.
                        Config tbapi.UpdateConfig
                }
                // Request holds details about calls to the Request method.
                Request []struct {
                        // C is the c argument value.
                        C tbapi.Chattable
                }
                // Send holds details about calls to the Send method.
                Send []struct {
                        // C is the c argument value.
                        C tbapi.Chattable
                }
        }
        lockGetChat               sync.RWMutex
        lockGetChatAdministrators sync.RWMutex
        lockGetUpdatesChan        sync.RWMutex
        lockRequest               sync.RWMutex
        lockSend                  sync.RWMutex
}

// GetChat calls GetChatFunc.
func (mock *TbAPIMock) GetChat(config tbapi.ChatInfoConfig) (tbapi.ChatFullInfo, error) <span class="cov0" title="0">{
        if mock.GetChatFunc == nil </span><span class="cov0" title="0">{
                panic("TbAPIMock.GetChatFunc: method is nil but TbAPI.GetChat was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Config tbapi.ChatInfoConfig
        }{
                Config: config,
        }
        mock.lockGetChat.Lock()
        mock.calls.GetChat = append(mock.calls.GetChat, callInfo)
        mock.lockGetChat.Unlock()
        return mock.GetChatFunc(config)</span>
}

// GetChatCalls gets all the calls that were made to GetChat.
// Check the length with:
//
//        len(mockedTbAPI.GetChatCalls())
func (mock *TbAPIMock) GetChatCalls() []struct {
        Config tbapi.ChatInfoConfig
} <span class="cov0" title="0">{
        var calls []struct {
                Config tbapi.ChatInfoConfig
        }
        mock.lockGetChat.RLock()
        calls = mock.calls.GetChat
        mock.lockGetChat.RUnlock()
        return calls
}</span>

// ResetGetChatCalls reset all the calls that were made to GetChat.
func (mock *TbAPIMock) ResetGetChatCalls() <span class="cov0" title="0">{
        mock.lockGetChat.Lock()
        mock.calls.GetChat = nil
        mock.lockGetChat.Unlock()
}</span>

// GetChatAdministrators calls GetChatAdministratorsFunc.
func (mock *TbAPIMock) GetChatAdministrators(config tbapi.ChatAdministratorsConfig) ([]tbapi.ChatMember, error) <span class="cov0" title="0">{
        if mock.GetChatAdministratorsFunc == nil </span><span class="cov0" title="0">{
                panic("TbAPIMock.GetChatAdministratorsFunc: method is nil but TbAPI.GetChatAdministrators was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Config tbapi.ChatAdministratorsConfig
        }{
                Config: config,
        }
        mock.lockGetChatAdministrators.Lock()
        mock.calls.GetChatAdministrators = append(mock.calls.GetChatAdministrators, callInfo)
        mock.lockGetChatAdministrators.Unlock()
        return mock.GetChatAdministratorsFunc(config)</span>
}

// GetChatAdministratorsCalls gets all the calls that were made to GetChatAdministrators.
// Check the length with:
//
//        len(mockedTbAPI.GetChatAdministratorsCalls())
func (mock *TbAPIMock) GetChatAdministratorsCalls() []struct {
        Config tbapi.ChatAdministratorsConfig
} <span class="cov0" title="0">{
        var calls []struct {
                Config tbapi.ChatAdministratorsConfig
        }
        mock.lockGetChatAdministrators.RLock()
        calls = mock.calls.GetChatAdministrators
        mock.lockGetChatAdministrators.RUnlock()
        return calls
}</span>

// ResetGetChatAdministratorsCalls reset all the calls that were made to GetChatAdministrators.
func (mock *TbAPIMock) ResetGetChatAdministratorsCalls() <span class="cov0" title="0">{
        mock.lockGetChatAdministrators.Lock()
        mock.calls.GetChatAdministrators = nil
        mock.lockGetChatAdministrators.Unlock()
}</span>

// GetUpdatesChan calls GetUpdatesChanFunc.
func (mock *TbAPIMock) GetUpdatesChan(config tbapi.UpdateConfig) tbapi.UpdatesChannel <span class="cov0" title="0">{
        if mock.GetUpdatesChanFunc == nil </span><span class="cov0" title="0">{
                panic("TbAPIMock.GetUpdatesChanFunc: method is nil but TbAPI.GetUpdatesChan was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Config tbapi.UpdateConfig
        }{
                Config: config,
        }
        mock.lockGetUpdatesChan.Lock()
        mock.calls.GetUpdatesChan = append(mock.calls.GetUpdatesChan, callInfo)
        mock.lockGetUpdatesChan.Unlock()
        return mock.GetUpdatesChanFunc(config)</span>
}

// GetUpdatesChanCalls gets all the calls that were made to GetUpdatesChan.
// Check the length with:
//
//        len(mockedTbAPI.GetUpdatesChanCalls())
func (mock *TbAPIMock) GetUpdatesChanCalls() []struct {
        Config tbapi.UpdateConfig
} <span class="cov0" title="0">{
        var calls []struct {
                Config tbapi.UpdateConfig
        }
        mock.lockGetUpdatesChan.RLock()
        calls = mock.calls.GetUpdatesChan
        mock.lockGetUpdatesChan.RUnlock()
        return calls
}</span>

// ResetGetUpdatesChanCalls reset all the calls that were made to GetUpdatesChan.
func (mock *TbAPIMock) ResetGetUpdatesChanCalls() <span class="cov0" title="0">{
        mock.lockGetUpdatesChan.Lock()
        mock.calls.GetUpdatesChan = nil
        mock.lockGetUpdatesChan.Unlock()
}</span>

// Request calls RequestFunc.
func (mock *TbAPIMock) Request(c tbapi.Chattable) (*tbapi.APIResponse, error) <span class="cov0" title="0">{
        if mock.RequestFunc == nil </span><span class="cov0" title="0">{
                panic("TbAPIMock.RequestFunc: method is nil but TbAPI.Request was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                C tbapi.Chattable
        }{
                C: c,
        }
        mock.lockRequest.Lock()
        mock.calls.Request = append(mock.calls.Request, callInfo)
        mock.lockRequest.Unlock()
        return mock.RequestFunc(c)</span>
}

// RequestCalls gets all the calls that were made to Request.
// Check the length with:
//
//        len(mockedTbAPI.RequestCalls())
func (mock *TbAPIMock) RequestCalls() []struct {
        C tbapi.Chattable
} <span class="cov0" title="0">{
        var calls []struct {
                C tbapi.Chattable
        }
        mock.lockRequest.RLock()
        calls = mock.calls.Request
        mock.lockRequest.RUnlock()
        return calls
}</span>

// ResetRequestCalls reset all the calls that were made to Request.
func (mock *TbAPIMock) ResetRequestCalls() <span class="cov0" title="0">{
        mock.lockRequest.Lock()
        mock.calls.Request = nil
        mock.lockRequest.Unlock()
}</span>

// Send calls SendFunc.
func (mock *TbAPIMock) Send(c tbapi.Chattable) (tbapi.Message, error) <span class="cov0" title="0">{
        if mock.SendFunc == nil </span><span class="cov0" title="0">{
                panic("TbAPIMock.SendFunc: method is nil but TbAPI.Send was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                C tbapi.Chattable
        }{
                C: c,
        }
        mock.lockSend.Lock()
        mock.calls.Send = append(mock.calls.Send, callInfo)
        mock.lockSend.Unlock()
        return mock.SendFunc(c)</span>
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//
//        len(mockedTbAPI.SendCalls())
func (mock *TbAPIMock) SendCalls() []struct {
        C tbapi.Chattable
} <span class="cov0" title="0">{
        var calls []struct {
                C tbapi.Chattable
        }
        mock.lockSend.RLock()
        calls = mock.calls.Send
        mock.lockSend.RUnlock()
        return calls
}</span>

// ResetSendCalls reset all the calls that were made to Send.
func (mock *TbAPIMock) ResetSendCalls() <span class="cov0" title="0">{
        mock.lockSend.Lock()
        mock.calls.Send = nil
        mock.lockSend.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *TbAPIMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockGetChat.Lock()
        mock.calls.GetChat = nil
        mock.lockGetChat.Unlock()

        mock.lockGetChatAdministrators.Lock()
        mock.calls.GetChatAdministrators = nil
        mock.lockGetChatAdministrators.Unlock()

        mock.lockGetUpdatesChan.Lock()
        mock.calls.GetUpdatesChan = nil
        mock.lockGetUpdatesChan.Unlock()

        mock.lockRequest.Lock()
        mock.calls.Request = nil
        mock.lockRequest.Unlock()

        mock.lockSend.Lock()
        mock.calls.Send = nil
        mock.lockSend.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "math"
        "net/http"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "syscall"
        "time"

        tbapi "github.com/OvyFlash/telegram-bot-api"
        "github.com/fatih/color"
        "github.com/go-pkgz/fileutils"
        "github.com/go-pkgz/lgr"
        "github.com/go-pkgz/rest"
        "github.com/jessevdk/go-flags"
        "github.com/sashabaranov/go-openai"
        "gopkg.in/natefinch/lumberjack.v2"

        "github.com/umputun/tg-spam/app/bot"
        "github.com/umputun/tg-spam/app/config"
        "github.com/umputun/tg-spam/app/events"
        "github.com/umputun/tg-spam/app/storage"
        "github.com/umputun/tg-spam/app/storage/engine"
        "github.com/umputun/tg-spam/app/webapi"
        "github.com/umputun/tg-spam/lib/tgspam"
        "github.com/umputun/tg-spam/lib/tgspam/plugin"
)

type options struct {
        InstanceID         string `long:"instance-id" env:"INSTANCE_ID" default:"tg-spam" description:"instance id"`
        DataBaseURL        string `long:"db" env:"DB" default:"tg-spam.db" description:"database URL, if empty uses sqlite"`
        ConfigDB           bool   `long:"confdb" env:"CONFDB" description:"load configuration from database"`
        ConfigDBEncryptKey string `long:"confdb-encrypt-key" env:"CONFDB_ENCRYPT_KEY" description:"encryption key for sensitive config values in database"`

        Telegram struct {
                Token        string        `long:"token" env:"TOKEN" description:"telegram bot token"`
                Group        string        `long:"group" env:"GROUP" description:"group name/id"`
                Timeout      time.Duration `long:"timeout" env:"TIMEOUT" default:"30s" description:"http client timeout for telegram" `
                IdleDuration time.Duration `long:"idle" env:"IDLE" default:"30s" description:"idle duration"`
        } `group:"telegram" namespace:"telegram" env-namespace:"TELEGRAM"`

        AdminGroup              string `long:"admin.group" env:"ADMIN_GROUP" description:"admin group name, or channel id"`
        DisableAdminSpamForward bool   `long:"disable-admin-spam-forward" env:"DISABLE_ADMIN_SPAM_FORWARD" description:"disable handling messages forwarded to admin group as spam"`

        TestingIDs []int64 `long:"testing-id" env:"TESTING_ID" env-delim:"," description:"testing ids, allow bot to reply to them"`

        HistoryDuration time.Duration `long:"history-duration" env:"HISTORY_DURATION" default:"24h" description:"history duration"`
        HistoryMinSize  int           `long:"history-min-size" env:"HISTORY_MIN_SIZE" default:"1000" description:"history minimal size to keep"`
        StorageTimeout  time.Duration `long:"storage-timeout" env:"STORAGE_TIMEOUT" default:"0s" description:"storage timeout"`

        Logger struct {
                Enabled    bool   `long:"enabled" env:"ENABLED" description:"enable spam rotated logs"`
                FileName   string `long:"file" env:"FILE"  default:"tg-spam.log" description:"location of spam log"`
                MaxSize    string `long:"max-size" env:"MAX_SIZE" default:"100M" description:"maximum size before it gets rotated"`
                MaxBackups int    `long:"max-backups" env:"MAX_BACKUPS" default:"10" description:"maximum number of old log files to retain"`
        } `group:"logger" namespace:"logger" env-namespace:"LOGGER"`

        SuperUsers          events.SuperUsers `long:"super" env:"SUPER_USER" env-delim:"," description:"super-users"`
        NoSpamReply         bool              `long:"no-spam-reply" env:"NO_SPAM_REPLY" description:"do not reply to spam messages"`
        SuppressJoinMessage bool              `long:"suppress-join-message" env:"SUPPRESS_JOIN_MESSAGE" description:"delete join message if user is kicked out"`

        CAS struct {
                API       string        `long:"api" env:"API" default:"https://api.cas.chat" description:"CAS API"`
                Timeout   time.Duration `long:"timeout" env:"TIMEOUT" default:"5s" description:"CAS timeout"`
                UserAgent string        `long:"user-agent" env:"USER_AGENT" description:"User-Agent header for CAS API requests"`
        } `group:"cas" namespace:"cas" env-namespace:"CAS"`

        Meta struct {
                LinksLimit      int    `long:"links-limit" env:"LINKS_LIMIT" default:"-1" description:"max links in message, disabled by default"`
                MentionsLimit   int    `long:"mentions-limit" env:"MENTIONS_LIMIT" default:"-1" description:"max mentions in message, disabled by default"`
                ImageOnly       bool   `long:"image-only" env:"IMAGE_ONLY" description:"enable image only check"`
                LinksOnly       bool   `long:"links-only" env:"LINKS_ONLY" description:"enable links only check"`
                VideosOnly      bool   `long:"video-only" env:"VIDEO_ONLY" description:"enable video only check"`
                AudiosOnly      bool   `long:"audio-only" env:"AUDIO_ONLY" description:"enable audio only check"`
                Forward         bool   `long:"forward" env:"FORWARD" description:"enable forward check"`
                Keyboard        bool   `long:"keyboard" env:"KEYBOARD" description:"enable keyboard check"`
                UsernameSymbols string `long:"username-symbols" env:"USERNAME_SYMBOLS" description:"prohibited symbols in username, disabled by default"`
        } `group:"meta" namespace:"meta" env-namespace:"META"`

        OpenAI struct {
                Token             string   `long:"token" env:"TOKEN" description:"openai token, disabled if not set"`
                APIBase           string   `long:"apibase" env:"API_BASE" description:"custom openai API base, default is https://api.openai.com/v1"`
                Veto              bool     `long:"veto" env:"VETO" description:"veto mode, confirm detected spam"`
                Prompt            string   `long:"prompt" env:"PROMPT" default:"" description:"openai system prompt, if empty uses builtin default"`
                CustomPrompts     []string `long:"custom-prompt" env:"CUSTOM_PROMPTS" env-delim:"," description:"custom prompts for special cases"`
                ReasoningEffort   string   `long:"reasoning-effort" env:"REASONING_EFFORT" default:"" description:"reasoning effort level (low, medium, high)"`
                Model             string   `long:"model" env:"MODEL" default:"gpt-4o-mini" description:"openai model"`
                MaxTokensResponse int      `long:"max-tokens-response" env:"MAX_TOKENS_RESPONSE" default:"1024" description:"openai max tokens in response"`
                MaxTokensRequest  int      `long:"max-tokens-request" env:"MAX_TOKENS_REQUEST" default:"2048" description:"openai max tokens in request"`
                MaxSymbolsRequest int      `long:"max-symbols-request" env:"MAX_SYMBOLS_REQUEST" default:"16000" description:"openai max symbols in request, failback if tokenizer failed"`
                RetryCount        int      `long:"retry-count" env:"RETRY_COUNT" default:"1" description:"openai retry count"`
                HistorySize       int      `long:"history-size" env:"HISTORY_SIZE" default:"0" description:"openai history size"`
        } `group:"openai" namespace:"openai" env-namespace:"OPENAI"`

        LuaPlugins struct {
                Enabled        bool     `long:"enabled" env:"ENABLED" description:"enable Lua plugins"`
                PluginsDir     string   `long:"plugins-dir" env:"PLUGINS_DIR" description:"directory with Lua plugins"`
                EnabledPlugins []string `long:"enabled-plugins" env:"ENABLED_PLUGINS" env-delim:"," description:"list of enabled plugins (by name, without .lua extension)"`
                DynamicReload  bool     `long:"dynamic-reload" env:"DYNAMIC_RELOAD" description:"dynamically reload plugins when they change"`
        } `group:"lua-plugins" namespace:"lua-plugins" env-namespace:"LUA_PLUGINS"`

        AbnormalSpacing struct {
                Enabled                 bool    `long:"enabled" env:"ENABLED" description:"enable abnormal words check"`
                SpaceRatioThreshold     float64 `long:"ratio" env:"RATIO" default:"0.3" description:"the ratio of spaces to all characters in the message"`
                ShortWordRatioThreshold float64 `long:"short-ratio" env:"SHORT_RATIO" default:"0.7" description:"the ratio of short words to all words in the message"`
                ShortWordLen            int     `long:"short-word" env:"SHORT_WORD" default:"3" description:"the length of the word to be considered short"`
                MinWords                int     `long:"min-words" env:"MIN_WORDS" default:"5" description:"the minimum number of words in the message to check"`
        } `group:"space" namespace:"space" env-namespace:"SPACE"`

        Files struct {
                SamplesDataPath string        `long:"samples" env:"SAMPLES" default:"preset" description:"samples data path, deprecated"`
                DynamicDataPath string        `long:"dynamic" env:"DYNAMIC" default:"data" description:"dynamic data path"`
                WatchInterval   time.Duration `long:"watch-interval" env:"WATCH_INTERVAL" default:"5s" description:"watch interval for dynamic files, deprecated"`
        } `group:"files" namespace:"files" env-namespace:"FILES"`

        SimilarityThreshold float64 `long:"similarity-threshold" env:"SIMILARITY_THRESHOLD" default:"0.5" description:"spam threshold"`
        MinMsgLen           int     `long:"min-msg-len" env:"MIN_MSG_LEN" default:"50" description:"min message length to check"`
        MaxEmoji            int     `long:"max-emoji" env:"MAX_EMOJI" default:"2" description:"max emoji count in message, -1 to disable check"`
        MinSpamProbability  float64 `long:"min-probability" env:"MIN_PROBABILITY" default:"50" description:"min spam probability percent to ban"`
        MultiLangWords      int     `long:"multi-lang" env:"MULTI_LANG" default:"0" description:"number of words in different languages to consider as spam"`

        ParanoidMode       bool `long:"paranoid" env:"PARANOID" description:"paranoid mode, check all messages"`
        FirstMessagesCount int  `long:"first-messages-count" env:"FIRST_MESSAGES_COUNT" default:"1" description:"number of first messages to check"`

        Message struct {
                Startup string `long:"startup" env:"STARTUP" default:"" description:"startup message"`
                Spam    string `long:"spam" env:"SPAM" default:"this is spam" description:"spam message"`
                Dry     string `long:"dry" env:"DRY" default:"this is spam (dry mode)" description:"spam dry message"`
                Warn    string `long:"warn" env:"WARN" default:"You've violated our rules and this is your first and last warning. Further violations will lead to permanent access denial. Stay compliant or face the consequences!" description:"warning message"`
        } `group:"message" namespace:"message" env-namespace:"MESSAGE"`

        Server struct {
                Enabled    bool   `long:"enabled" env:"ENABLED" description:"enable web server"`
                ListenAddr string `long:"listen" env:"LISTEN" default:":8080" description:"listen address"`
                AuthUser   string `long:"auth-user" env:"AUTH_USER" default:"tg-spam" description:"basic auth username"`
                AuthPasswd string `long:"auth" env:"AUTH" default:"auto" description:"basic auth password"`
                AuthHash   string `long:"auth-hash" env:"AUTH_HASH" default:"" description:"basic auth password hash"`
        } `group:"server" namespace:"server" env-namespace:"SERVER"`

        Training bool `long:"training" env:"TRAINING" description:"training mode, passive spam detection only"`
        SoftBan  bool `long:"soft-ban" env:"SOFT_BAN" description:"soft ban mode, restrict user actions but not ban"`

        HistorySize int    `long:"history-size" env:"LAST_MSGS_HISTORY_SIZE" default:"100" description:"history size"`
        Convert     string `long:"convert" choice:"only" choice:"enabled" choice:"disabled" default:"enabled" description:"convert mode for txt samples and other storage files to DB"`

        MaxBackups int `long:"max-backups" env:"MAX_BACKUPS" default:"10" description:"maximum number of backups to keep, set 0 to disable"`

        Dry   bool `long:"dry" env:"DRY" description:"dry mode, no bans"`
        Dbg   bool `long:"dbg" env:"DEBUG" description:"debug mode"`
        TGDbg bool `long:"tg-dbg" env:"TG_DEBUG" description:"telegram debug mode"`
}

// default file names
const (
        samplesSpamFile   = "spam-samples.txt"
        samplesHamFile    = "ham-samples.txt"
        excludeTokensFile = "exclude-tokens.txt" //nolint:gosec // false positive
        stopWordsFile     = "stop-words.txt"     //nolint:gosec // false positive
        dynamicSpamFile   = "spam-dynamic.txt"
        dynamicHamFile    = "ham-dynamic.txt"
        dataFile          = "tg-spam.db"
)

var revision = "local"

func main() <span class="cov0" title="0">{
        fmt.Printf("tg-spam %s\n", revision)
        var opts options
        p := flags.NewParser(&amp;opts, flags.PrintErrors|flags.PassDoubleDash|flags.HelpFlag)
        p.SubcommandsOptional = true

        // add save-config command
        if _, err := p.AddCommand("save-config", "Save current configuration to database",
                "Saves all current settings to the database for future use with --confdb",
                &amp;struct{}{}); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to add save-config command: %v", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if _, err := p.Parse(); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err.(*flags.Error).Type, flags.ErrHelp) </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] cli error: %v", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">os.Exit(2)</span>
        }

        // determine configuration source based on --confdb flag
        <span class="cov0" title="0">var appSettings *config.Settings

        if opts.ConfigDB </span><span class="cov0" title="0">{
                // database configuration mode - load from database first
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()

                log.Printf("[INFO] loading configuration from database")

                // create a new settings instance
                appSettings = config.New()

                // set transient values needed for database connection BEFORE loading
                appSettings.Transient.ConfigDB = opts.ConfigDB
                appSettings.Transient.ConfigDBEncryptKey = opts.ConfigDBEncryptKey
                appSettings.Transient.DataBaseURL = opts.DataBaseURL
                appSettings.InstanceID = opts.InstanceID
                // set DynamicDataPath from opts so makeDB can properly construct the database path
                appSettings.Files.DynamicDataPath = opts.Files.DynamicDataPath

                // load settings from database
                if err := loadConfigFromDB(ctx, appSettings); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to load configuration from database: %v", err)
                        cancel()
                        os.Exit(1) //nolint:gocritic // cancel is called before exit
                }</span>

                // apply remaining transient values from CLI (these are never stored in DB)
                <span class="cov0" title="0">appSettings.Transient.Dbg = opts.Dbg
                appSettings.Transient.TGDbg = opts.TGDbg
                appSettings.Dry = opts.Dry

                // apply explicit CLI overrides for non-transient values
                applyCLIOverrides(appSettings, opts)</span>
        } else<span class="cov0" title="0"> {
                // traditional mode - CLI is source of truth
                appSettings = optToSettings(opts)
        }</span>

        // handle save-config command
        <span class="cov0" title="0">if p.Active != nil &amp;&amp; p.Active.Name == "save-config" </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                exitCode := 0
                if err := saveConfigToDB(ctx, appSettings); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to save configuration to database: %v", err)
                        exitCode = 1
                }</span>
                <span class="cov0" title="0">cancel()
                os.Exit(exitCode)</span>
        }

        // setup logger with masked secrets, accessing them directly from domain models
        <span class="cov0" title="0">masked := []string{}

        // add tokens from domain models
        if appSettings.Telegram.Token != "" </span><span class="cov0" title="0">{
                masked = append(masked, appSettings.Telegram.Token)
        }</span>
        <span class="cov0" title="0">if appSettings.OpenAI.Token != "" </span><span class="cov0" title="0">{
                masked = append(masked, appSettings.OpenAI.Token)
        }</span>

        // add temporary web password if not "auto"
        <span class="cov0" title="0">if appSettings.Transient.WebAuthPasswd != "auto" &amp;&amp; appSettings.Transient.WebAuthPasswd != "" </span><span class="cov0" title="0">{
                // auto passwd should not be masked as we print it
                masked = append(masked, appSettings.Transient.WebAuthPasswd)
        }</span>

        // add auth hash
        <span class="cov0" title="0">if appSettings.Server.AuthHash != "" </span><span class="cov0" title="0">{
                masked = append(masked, appSettings.Server.AuthHash)
        }</span>

        <span class="cov0" title="0">setupLog(appSettings.Transient.Dbg, masked...)
        log.Printf("[DEBUG] settings: %+v", appSettings)

        ctx, cancel := context.WithCancel(context.Background())

        go func() </span><span class="cov0" title="0">{
                // catch signal and invoke graceful termination
                stop := make(chan os.Signal, 1)
                signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
                &lt;-stop
                log.Printf("[WARN] interrupt signal")
                cancel()
        }</span>()

        // expand, make absolute paths
        <span class="cov0" title="0">appSettings.Files.DynamicDataPath = expandPath(appSettings.Files.DynamicDataPath)
        appSettings.Files.SamplesDataPath = expandPath(appSettings.Files.SamplesDataPath)

        if err := execute(ctx, appSettings); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] %v", err)
                os.Exit(1)
        }</span>
}

func execute(ctx context.Context, settings *config.Settings) error <span class="cov1" title="1">{
        if settings.Dry </span><span class="cov0" title="0">{
                log.Print("[WARN] dry mode, no actual bans")
        }</span>

        <span class="cov1" title="1">convertOnly := settings.Convert == "only"
        if !settings.Server.Enabled &amp;&amp; !convertOnly &amp;&amp; (settings.Telegram.Token == "" || settings.Telegram.Group == "") </span><span class="cov0" title="0">{
                return errors.New("telegram token and group are required")
        }</span>

        <span class="cov1" title="1">checkVolumeMount(settings) // show warning if dynamic files dir not mounted

        // make samples and dynamic data dirs
        if err := os.MkdirAll(settings.Files.SamplesDataPath, 0o700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make samples dir, %w", err)
        }</span>

        <span class="cov1" title="1">dataDB, err := makeDB(ctx, settings)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make db, %w", err)
        }</span>

        // make detector with all sample files loaded
        <span class="cov1" title="1">detector := makeDetector(settings)

        // make spam bot
        spamBot, err := makeSpamBot(ctx, settings, dataDB, detector)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make spam bot, %w", err)
        }</span>
        <span class="cov1" title="1">if settings.Convert == "only" </span><span class="cov0" title="0">{
                log.Print("[WARN] convert only mode, converting text samples and exit")
                return nil
        }</span>

        // make store and load approved users
        <span class="cov1" title="1">approvedUsersStore, auErr := storage.NewApprovedUsers(ctx, dataDB)
        if auErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make approved users store, %w", auErr)
        }</span>

        <span class="cov1" title="1">count, err := detector.WithUserStorage(approvedUsersStore)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't load approved users, %w", err)
        }</span>
        <span class="cov1" title="1">log.Printf("[DEBUG] approved users loaded: %d", count)

        // make locator
        locator, err := storage.NewLocator(ctx, settings.History.Duration, settings.History.MinSize, dataDB)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make locator, %w", err)
        }</span>

        // activate web server if enabled
        <span class="cov1" title="1">if settings.Server.Enabled </span><span class="cov1" title="1">{
                // server starts in background goroutine
                if srvErr := activateServer(ctx, settings, spamBot, locator, dataDB); srvErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't activate web server, %w", srvErr)
                }</span>
                // if no telegram token and group set, just run the server
                <span class="cov1" title="1">if settings.Telegram.Token == "" || settings.Telegram.Group == "" </span><span class="cov1" title="1">{
                        log.Printf("[WARN] no telegram token and group set, web server only mode")
                        &lt;-ctx.Done()
                        return nil
                }</span>
        }

        // make telegram bot
        <span class="cov0" title="0">tbAPI, err := tbapi.NewBotAPI(settings.Telegram.Token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make telegram bot, %w", err)
        }</span>
        <span class="cov0" title="0">tbAPI.Debug = settings.Transient.TGDbg

        // make spam logger writer
        loggerWr, err := makeSpamLogWriter(settings)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make spam log writer, %w", err)
        }</span>
        <span class="cov0" title="0">defer loggerWr.Close()

        // make spam logger
        spamLogger, err := makeSpamLogger(ctx, settings.InstanceID, loggerWr, dataDB)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make spam logger, %w", err)
        }</span>

        // make telegram listener
        <span class="cov0" title="0">tgListener := events.TelegramListener{
                TbAPI:                   tbAPI,
                Group:                   settings.Telegram.Group,
                IdleDuration:            settings.Telegram.IdleDuration,
                SuperUsers:              settings.Admin.SuperUsers,
                Bot:                     spamBot,
                StartupMsg:              settings.Message.Startup,
                WarnMsg:                 settings.Message.Warn,
                NoSpamReply:             settings.NoSpamReply,
                SuppressJoinMessage:     settings.SuppressJoinMessage,
                SpamLogger:              spamLogger,
                AdminGroup:              settings.Admin.AdminGroup,
                TestingIDs:              settings.Admin.TestingIDs,
                Locator:                 locator,
                TrainingMode:            settings.Training,
                SoftBanMode:             settings.SoftBan,
                DisableAdminSpamForward: settings.Admin.DisableAdminSpamForward,
                Dry:                     settings.Dry,
        }

        log.Printf("[DEBUG] telegram listener config: {group: %s, idle: %v, super: %v, admin: %s, testing: %v, no-reply: %v,"+
                " suppress: %v, dry: %v, training: %v}", tgListener.Group, tgListener.IdleDuration, tgListener.SuperUsers,
                tgListener.AdminGroup, tgListener.TestingIDs, tgListener.NoSpamReply, tgListener.SuppressJoinMessage, tgListener.Dry,
                tgListener.TrainingMode)

        // run telegram listener and event processor loop
        if err := tgListener.Do(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("telegram listener failed, %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// makeDB creates database connection based on the settings model
func makeDB(ctx context.Context, settings *config.Settings) (*engine.SQL, error) <span class="cov5" title="12">{
        if settings.Transient.DataBaseURL == "" </span><span class="cov0" title="0">{
                return nil, errors.New("empty database URL")
        }</span>
        <span class="cov5" title="12">dbURL := settings.Transient.DataBaseURL

        // if dbURL has no path separator, assume it is a file name and add dynamic data path for sqlite
        if !strings.Contains(dbURL, "/") &amp;&amp; !strings.Contains(dbURL, "\\") </span><span class="cov0" title="0">{
                dbURL = filepath.Join(settings.Files.DynamicDataPath, dbURL)
        }</span>
        <span class="cov5" title="12">log.Printf("[DEBUG] data db: %s", dbURL)

        db, err := engine.New(ctx, dbURL, settings.InstanceID)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("can't make db %s, %w", settings.Transient.DataBaseURL, err)
        }</span>

        // backup db on version change for sqlite
        <span class="cov4" title="10">if db.Type() == engine.Sqlite </span><span class="cov4" title="10">{
                // get file name from dbURL for sqlite
                dbFile := dbURL
                dbFile = strings.TrimPrefix(dbFile, "file://")
                dbFile = strings.TrimPrefix(dbFile, "file:")

                // make backup of db on version change for sqlite
                if settings.MaxBackups &gt; 0 </span><span class="cov0" title="0">{
                        if err := backupDB(dbFile, revision, settings.MaxBackups); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("backup on version change failed, %w", err)
                        }</span>
                } else<span class="cov4" title="10"> {
                        log.Print("[WARN] database backups disabled")
                }</span>
        }
        <span class="cov4" title="10">return db, nil</span>
}

// checkVolumeMount checks if dynamic files location mounted in docker and shows warning if not
// returns true if running not in docker or dynamic files dir mounted
func checkVolumeMount(settings *config.Settings) (ok bool) <span class="cov4" title="6">{
        if os.Getenv("TGSPAM_IN_DOCKER") != "1" </span><span class="cov2" title="3">{
                return true
        }</span>
        <span class="cov2" title="3">log.Printf("[DEBUG] running in docker")
        warnMsg := fmt.Sprintf("dynamic files dir %q is not mounted, changes will be lost on container restart", settings.Files.DynamicDataPath)

        // check if dynamic files dir not present. This means it is not mounted
        _, err := os.Stat(settings.Files.DynamicDataPath)
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] %s", warnMsg)
                // no dynamic files dir, no need to check further
                return false
        }</span>

        // check if .not_mounted file missing, this means it is mounted
        <span class="cov2" title="2">if _, err = os.Stat(filepath.Join(settings.Files.DynamicDataPath, ".not_mounted")); err != nil </span><span class="cov1" title="1">{
                return true
        }</span>

        // if .not_mounted file present, it can be mounted anyway with docker named volumes
        <span class="cov1" title="1">output, err := exec.Command("mount").Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] %s, can't check mount: %v", warnMsg, err)
                return true
        }</span>
        // check if the output contains the specified directory
        <span class="cov1" title="1">for _, line := range strings.Split(string(output), "\n") </span><span class="cov5" title="13">{
                if strings.Contains(line, settings.Files.DynamicDataPath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">log.Printf("[WARN] %s", warnMsg)
        return false</span>
}

func activateServer(ctx context.Context, settings *config.Settings, sf *bot.SpamFilter, loc *storage.Locator, db *engine.SQL) (err error) <span class="cov1" title="1">{
        // handle authentication - always use bcrypt hash for security
        authPasswd := settings.Transient.WebAuthPasswd
        authHash := settings.Server.AuthHash

        // if hash is provided, use it directly
        if authHash != "" </span><span class="cov0" title="0">{
                log.Printf("[INFO] using provided bcrypt hash for authentication")
        }</span> else<span class="cov1" title="1"> if authPasswd != "" </span><span class="cov1" title="1">{
                // generate hash from password if no hash but password is provided
                authHash, err = generateAuthHash(authPasswd)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't handle authentication setup: %w", err)
                }</span>
                // store the hash directly in the Server settings domain
                <span class="cov1" title="1">settings.Server.AuthHash = authHash</span>
        }
        // when neither hash nor password is provided, auth will be disabled

        // make store and load approved users
        <span class="cov1" title="1">detectedSpamStore, dsErr := storage.NewDetectedSpam(ctx, db)
        if dsErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't make detected spam store, %w", dsErr)
        }</span>

        // create settings store for database access if config DB mode is enabled
        <span class="cov1" title="1">var settingsStore *config.Store
        if settings.Transient.ConfigDB </span><span class="cov0" title="0">{
                store, err := config.NewStore(ctx, db)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create settings store: %w", err)
                }</span>
                <span class="cov0" title="0">settingsStore = store</span>
        }

        <span class="cov1" title="1">srv := webapi.Server{Config: webapi.Config{
                ListenAddr:    settings.Server.ListenAddr,
                Detector:      sf.Detector,
                SpamFilter:    sf,
                Locator:       loc,
                DetectedSpam:  detectedSpamStore,
                StorageEngine: db,            // add database engine for backup functionality
                SettingsStore: settingsStore, // may be nil if ConfigDB is false
                AuthUser:      settings.Server.AuthUser,
                AuthHash:      authHash, // use the hash (either from options or generated)
                Version:       revision,
                Dbg:           settings.Transient.Dbg,
                AppSettings:   settings,
                ConfigDBMode:  settings.Transient.ConfigDB, // indicate we're running with database config
        }}

        go func() </span><span class="cov1" title="1">{
                if err := srv.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] web server failed, %v", err)
                }</span>
        }()
        <span class="cov1" title="1">return nil</span>
}

// makeDetector creates spam detector with all checkers and updaters
// it loads samples and dynamic files
func makeDetector(settings *config.Settings) *tgspam.Detector <span class="cov4" title="7">{
        detectorConfig := tgspam.Config{
                MaxAllowedEmoji:     settings.MaxEmoji,
                MinMsgLen:           settings.MinMsgLen,
                SimilarityThreshold: settings.SimilarityThreshold,
                MinSpamProbability:  settings.MinSpamProbability,
                CasAPI:              settings.CAS.API,
                CasUserAgent:        settings.CAS.UserAgent,
                HTTPClient:          &amp;http.Client{Timeout: settings.CAS.Timeout},
                FirstMessageOnly:    !settings.ParanoidMode,
                FirstMessagesCount:  settings.FirstMessagesCount,
                OpenAIVeto:          settings.OpenAI.Veto,
                OpenAIHistorySize:   settings.OpenAI.HistorySize, // how many last requests sent to openai
                MultiLangWords:      settings.MultiLangWords,
                HistorySize:         settings.History.Size, // how many last request stored in memory
        }

        // FirstMessagesCount and ParanoidMode are mutually exclusive.
        // ParanoidMode still here for backward compatibility only.
        if settings.FirstMessagesCount &gt; 0 </span><span class="cov2" title="2">{ // if FirstMessagesCount is set, FirstMessageOnly is enforced
                detectorConfig.FirstMessageOnly = true
        }</span>
        <span class="cov4" title="7">if settings.ParanoidMode </span><span class="cov1" title="1">{ // if ParanoidMode is set, FirstMessagesCount is ignored
                detectorConfig.FirstMessageOnly = false
                detectorConfig.FirstMessagesCount = 0
        }</span>
        <span class="cov4" title="7">if settings.Transient.StorageTimeout &gt; 0 </span><span class="cov0" title="0">{ // if StorageTimeout is non-zero, set it. If zero, storage timeout is disabled
                detectorConfig.StorageTimeout = settings.Transient.StorageTimeout
        }</span>

        <span class="cov4" title="7">detector := tgspam.NewDetector(detectorConfig)

        if settings.IsOpenAIEnabled() </span><span class="cov2" title="2">{
                log.Printf("[WARN] openai enabled")
                openAIConfig := tgspam.OpenAIConfig{
                        SystemPrompt:      settings.OpenAI.Prompt,
                        CustomPrompts:     settings.OpenAI.CustomPrompts,
                        ReasoningEffort:   settings.OpenAI.ReasoningEffort,
                        Model:             settings.OpenAI.Model,
                        MaxTokensResponse: settings.OpenAI.MaxTokensResponse,
                        MaxTokensRequest:  settings.OpenAI.MaxTokensRequest,
                        MaxSymbolsRequest: settings.OpenAI.MaxSymbolsRequest,
                        RetryCount:        settings.OpenAI.RetryCount,
                }

                openaiConfig := openai.DefaultConfig(settings.OpenAI.Token)
                if settings.OpenAI.APIBase != "" </span><span class="cov0" title="0">{
                        openaiConfig.BaseURL = settings.OpenAI.APIBase
                }</span>
                <span class="cov2" title="2">log.Printf("[DEBUG] openai config: %+v", openAIConfig)

                detector.WithOpenAIChecker(openai.NewClientWithConfig(openaiConfig), openAIConfig)</span>
        }

        <span class="cov4" title="7">if settings.AbnormalSpace.Enabled </span><span class="cov0" title="0">{
                log.Printf("[INFO] words spacing check enabled")
                detector.AbnormalSpacing.Enabled = true
                detector.AbnormalSpacing.ShortWordLen = settings.AbnormalSpace.ShortWordLen
                detector.AbnormalSpacing.ShortWordRatioThreshold = settings.AbnormalSpace.ShortWordRatioThreshold
                detector.AbnormalSpacing.SpaceRatioThreshold = settings.AbnormalSpace.SpaceRatioThreshold
                detector.AbnormalSpacing.MinWordsCount = settings.AbnormalSpace.MinWords
        }</span>

        <span class="cov4" title="7">metaChecks := []tgspam.MetaCheck{}
        if settings.Meta.ImageOnly </span><span class="cov0" title="0">{
                log.Printf("[INFO] image only check enabled")
                metaChecks = append(metaChecks, tgspam.ImagesCheck())
        }</span>
        <span class="cov4" title="7">if settings.Meta.VideosOnly </span><span class="cov0" title="0">{
                log.Printf("[INFO] videos only check enabled")
                metaChecks = append(metaChecks, tgspam.VideosCheck())
        }</span>
        <span class="cov4" title="7">if settings.Meta.LinksLimit &gt;= 0 </span><span class="cov4" title="7">{
                log.Printf("[INFO] links check enabled, limit: %d", settings.Meta.LinksLimit)
                metaChecks = append(metaChecks, tgspam.LinksCheck(settings.Meta.LinksLimit))
        }</span>
        <span class="cov4" title="7">if settings.Meta.MentionsLimit &gt;= 0 </span><span class="cov4" title="7">{
                log.Printf("[INFO] mentions check enabled, limit: %d", settings.Meta.MentionsLimit)
                metaChecks = append(metaChecks, tgspam.MentionsCheck(settings.Meta.MentionsLimit))
        }</span>
        <span class="cov4" title="7">if settings.Meta.LinksOnly </span><span class="cov0" title="0">{
                log.Printf("[INFO] links only check enabled")
                metaChecks = append(metaChecks, tgspam.LinkOnlyCheck())
        }</span>
        <span class="cov4" title="7">if settings.Meta.Forward </span><span class="cov0" title="0">{
                log.Printf("[INFO] forward check enabled")
                metaChecks = append(metaChecks, tgspam.ForwardedCheck())
        }</span>
        <span class="cov4" title="7">if settings.Meta.Keyboard </span><span class="cov0" title="0">{
                log.Printf("[INFO] keyboard check enabled")
                metaChecks = append(metaChecks, tgspam.KeyboardCheck())
        }</span>
        <span class="cov4" title="7">if settings.Meta.UsernameSymbols != "" </span><span class="cov0" title="0">{
                log.Printf("[INFO] username symbols check enabled, prohibited symbols: %q", settings.Meta.UsernameSymbols)
                metaChecks = append(metaChecks, tgspam.UsernameSymbolsCheck(settings.Meta.UsernameSymbols))
        }</span>
        <span class="cov4" title="7">detector.WithMetaChecks(metaChecks...)

        log.Printf("[DEBUG] detector config: %+v", detectorConfig)

        // initialize Lua plugins if enabled
        if settings.LuaPlugins.Enabled </span><span class="cov0" title="0">{
                initLuaPlugins(detector, settings)
        }</span>

        <span class="cov4" title="7">return detector</span>
}

// initLuaPlugins initializes Lua plugin engine and configures it
func initLuaPlugins(detector *tgspam.Detector, settings *config.Settings) <span class="cov2" title="2">{
        // copy Lua plugin settings to detector config
        detector.LuaPlugins.Enabled = true
        detector.LuaPlugins.PluginsDir = settings.LuaPlugins.PluginsDir
        detector.LuaPlugins.EnabledPlugins = settings.LuaPlugins.EnabledPlugins
        detector.LuaPlugins.DynamicReload = settings.LuaPlugins.DynamicReload

        // create and initialize the plugin engine
        luaEngine := plugin.NewChecker()
        if err := detector.WithLuaEngine(luaEngine); err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] failed to initialize Lua plugins: %v", err)
                return
        }</span>

        // log successful initialization
        <span class="cov1" title="1">log.Printf("[INFO] lua plugins enabled from directory: %s", settings.LuaPlugins.PluginsDir)

        // log which plugins are enabled
        if len(settings.LuaPlugins.EnabledPlugins) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[INFO] enabled Lua plugins: %v", settings.LuaPlugins.EnabledPlugins)
        }</span> else<span class="cov1" title="1"> {
                log.Print("[INFO] all Lua plugins from directory are enabled")
        }</span>

        // log if dynamic reloading is enabled
        <span class="cov1" title="1">if settings.LuaPlugins.DynamicReload </span><span class="cov0" title="0">{
                log.Print("[INFO] dynamic reloading of Lua plugins enabled")
        }</span>
}

func makeSpamBot(ctx context.Context, settings *config.Settings, dataDB *engine.SQL, detector *tgspam.Detector) (*bot.SpamFilter, error) <span class="cov2" title="3">{
        if dataDB == nil || detector == nil </span><span class="cov1" title="1">{
                return nil, errors.New("nil datadb or detector")
        }</span>

        // make samples store
        <span class="cov2" title="2">samplesStore, err := storage.NewSamples(ctx, dataDB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't make samples store, %w", err)
        }</span>
        <span class="cov2" title="2">if err = migrateSamples(ctx, settings, samplesStore); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't migrate samples, %w", err)
        }</span>

        // make dictionary store
        <span class="cov2" title="2">dictionaryStore, err := storage.NewDictionary(ctx, dataDB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't make dictionary store, %w", err)
        }</span>
        <span class="cov2" title="2">if err := migrateDicts(ctx, settings, dictionaryStore); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't migrate dictionary, %w", err)
        }</span>

        <span class="cov2" title="2">spamBotParams := bot.SpamConfig{
                GroupID:      settings.InstanceID,
                SamplesStore: samplesStore,
                DictStore:    dictionaryStore,
                SpamMsg:      settings.Message.Spam,
                SpamDryMsg:   settings.Message.Dry,
                Dry:          settings.Dry,
        }
        spamBot := bot.NewSpamFilter(detector, spamBotParams)
        log.Printf("[DEBUG] spam bot config: %+v", spamBotParams)

        if err := spamBot.ReloadSamples(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't reload samples, %w", err)
        }</span>

        // set detector samples updaters
        <span class="cov2" title="2">detector.WithSpamUpdater(storage.NewSampleUpdater(samplesStore, storage.SampleTypeSpam, settings.Transient.StorageTimeout))
        detector.WithHamUpdater(storage.NewSampleUpdater(samplesStore, storage.SampleTypeHam, settings.Transient.StorageTimeout))

        return spamBot, nil</span>
}

// expandPath expands ~ to home dir and makes the absolute path
func expandPath(path string) string <span class="cov4" title="10">{
        if path == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov4" title="9">if path[0] == '~' </span><span class="cov2" title="3">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov2" title="3">return filepath.Join(home, path[1:])</span>
        }
        <span class="cov4" title="6">ep, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov4" title="6">return ep</span>
}

type nopWriteCloser struct{ io.Writer }

func (n nopWriteCloser) Close() error <span class="cov0" title="0">{ return nil }</span>

// makeSpamLogger creates spam logger to keep reports about spam messages
// it writes json lines to the provided writer
func makeSpamLogger(ctx context.Context, gid string, wr io.Writer, dataDB *engine.SQL) (events.SpamLogger, error) <span class="cov1" title="1">{
        // make store and load approved users
        detectedSpamStore, auErr := storage.NewDetectedSpam(ctx, dataDB)
        if auErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't make approved users store, %w", auErr)
        }</span>

        <span class="cov1" title="1">logWr := events.SpamLoggerFunc(func(msg *bot.Message, response *bot.Response) </span><span class="cov1" title="1">{
                userName := msg.From.Username
                if userName == "" </span><span class="cov0" title="0">{
                        userName = msg.From.DisplayName
                }</span>
                // write to log file
                <span class="cov1" title="1">text := strings.ReplaceAll(msg.Text, "\n", " ")
                text = strings.TrimSpace(text)
                log.Printf("[DEBUG] spam detected from %v, text: %s", msg.From, text)
                m := struct {
                        TimeStamp   string `json:"ts"`
                        DisplayName string `json:"display_name"`
                        UserName    string `json:"user_name"`
                        UserID      int64  `json:"user_id"`
                        Text        string `json:"text"`
                }{
                        TimeStamp:   time.Now().In(time.Local).Format(time.RFC3339),
                        DisplayName: msg.From.DisplayName,
                        UserName:    msg.From.Username,
                        UserID:      msg.From.ID,
                        Text:        text,
                }
                line, err := json.Marshal(&amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] can't marshal json, %v", err)
                        return
                }</span>
                <span class="cov1" title="1">if _, err := wr.Write(append(line, '\n')); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] can't write to log, %v", err)
                }</span>

                // write to db store
                <span class="cov1" title="1">rec := storage.DetectedSpamInfo{
                        Text:      text,
                        UserID:    msg.From.ID,
                        UserName:  userName,
                        Timestamp: time.Now().In(time.Local),
                        GID:       gid,
                }
                if err := detectedSpamStore.Write(ctx, rec, response.CheckResults); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] can't write to db, %v", err)
                }</span>
        })

        <span class="cov1" title="1">return logWr, nil</span>
}

// makeSpamLogWriter creates spam log writer to keep reports about spam messages
// it parses settings and makes lumberjack logger with rotation
func makeSpamLogWriter(settings *config.Settings) (accessLog io.WriteCloser, err error) <span class="cov2" title="3">{
        if !settings.Logger.Enabled </span><span class="cov1" title="1">{
                return nopWriteCloser{io.Discard}, nil
        }</span>

        <span class="cov2" title="2">sizeParse := func(inp string) (uint64, error) </span><span class="cov2" title="2">{
                if inp == "" </span><span class="cov0" title="0">{
                        return 0, errors.New("empty value")
                }</span>
                <span class="cov2" title="2">for i, sfx := range []string{"k", "m", "g", "t"} </span><span class="cov4" title="6">{
                        if strings.HasSuffix(inp, strings.ToUpper(sfx)) || strings.HasSuffix(inp, strings.ToLower(sfx)) </span><span class="cov1" title="1">{
                                val, err := strconv.Atoi(inp[:len(inp)-1])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("can't parse %s: %w", inp, err)
                                }</span>
                                <span class="cov1" title="1">return uint64(float64(val) * math.Pow(float64(1024), float64(i+1))), nil</span>
                        }
                }
                <span class="cov1" title="1">return strconv.ParseUint(inp, 10, 64)</span>
        }

        <span class="cov2" title="2">maxSize, perr := sizeParse(settings.Logger.MaxSize)
        if perr != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("can't parse logger MaxSize: %w", perr)
        }</span>

        <span class="cov1" title="1">maxSize /= 1048576

        log.Printf("[INFO] logger enabled for %s, max size %dM", settings.Logger.FileName, maxSize)
        return &amp;lumberjack.Logger{
                Filename:   settings.Logger.FileName,
                MaxSize:    int(maxSize), //nolint:gosec // size in MB not that big to cause overflow
                MaxBackups: settings.Logger.MaxBackups,
                Compress:   true,
                LocalTime:  true,
        }, nil</span>
}

// migrateSamples runs migrations from legacy text files samples to db, if such files found
func migrateSamples(ctx context.Context, settings *config.Settings, samplesDB *storage.Samples) error <span class="cov4" title="7">{
        if settings.Convert == "disabled" </span><span class="cov0" title="0">{
                log.Print("[DEBUG] samples migration disabled")
                return nil
        }</span>
        <span class="cov4" title="7">migrateSamples := func(file string, sampleType storage.SampleType, origin storage.SampleOrigin) (*storage.SamplesStats, error) </span><span class="cov6" title="24">{
                if _, err := os.Stat(file); err != nil </span><span class="cov5" title="15">{
                        log.Printf("[DEBUG] samples file %s not found, skip", file)
                        return &amp;storage.SamplesStats{}, nil
                }</span>
                <span class="cov4" title="9">fh, err := os.Open(file) //nolint:gosec // file path is controlled by the app
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't open samples file, %w", err)
                }</span>
                <span class="cov4" title="9">defer fh.Close()
                stats, err := samplesDB.Import(ctx, sampleType, origin, fh, true) // clean records before import
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't load samples, %w", err)
                }</span>
                <span class="cov4" title="9">if err := fh.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't close samples file, %w", err)
                }</span>
                <span class="cov4" title="9">if err := os.Rename(file, file+".loaded"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't rename samples file, %w", err)
                }</span>
                <span class="cov4" title="9">return stats, nil</span>
        }

        <span class="cov4" title="7">if samplesDB == nil </span><span class="cov1" title="1">{
                return errors.New("samples db is nil")
        }</span>

        // migrate preset spam samples if files exist
        <span class="cov4" title="6">spamPresetFile := filepath.Join(settings.Files.SamplesDataPath, samplesSpamFile)
        s, err := migrateSamples(spamPresetFile, storage.SampleTypeSpam, storage.SampleOriginPreset)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't migrate spam preset samples, %w", err)
        }</span>
        <span class="cov4" title="6">if s.PresetHam &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] spam preset samples loaded: %s", s)
        }</span>

        // migrate preset ham samples if files exist
        <span class="cov4" title="6">hamPresetFile := filepath.Join(settings.Files.SamplesDataPath, samplesHamFile)
        s, err = migrateSamples(hamPresetFile, storage.SampleTypeHam, storage.SampleOriginPreset)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't migrate ham preset samples, %w", err)
        }</span>
        <span class="cov4" title="6">if s.PresetHam &gt; 0 </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] ham preset samples loaded: %s", s)
        }</span>

        // migrate dynamic spam samples if files exist
        <span class="cov4" title="6">dynSpamFile := filepath.Join(settings.Files.DynamicDataPath, dynamicSpamFile)
        s, err = migrateSamples(dynSpamFile, storage.SampleTypeSpam, storage.SampleOriginUser)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't migrate spam dynamic samples, %w", err)
        }</span>
        <span class="cov4" title="6">if s.UserSpam &gt; 0 </span><span class="cov1" title="1">{
                log.Printf("[DEBUG] spam dynamic samples loaded: %s", s)
        }</span>

        // migrate dynamic ham samples if files exist
        <span class="cov4" title="6">dynHamFile := filepath.Join(settings.Files.DynamicDataPath, dynamicHamFile)
        s, err = migrateSamples(dynHamFile, storage.SampleTypeHam, storage.SampleOriginUser)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't migrate ham dynamic samples, %w", err)
        }</span>
        <span class="cov4" title="6">if s.UserHam &gt; 0 </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] ham dynamic samples loaded: %s", s)
        }</span>

        <span class="cov4" title="6">if s.TotalHam &gt; 0 || s.TotalSpam &gt; 0 </span><span class="cov2" title="2">{
                log.Printf("[INFO] samples migration done: %s", s)
        }</span>
        <span class="cov4" title="6">return nil</span>
}

// migrateDicts runs migrations from legacy dictionary text files to db, if needed
func migrateDicts(ctx context.Context, settings *config.Settings, dictDB *storage.Dictionary) error <span class="cov4" title="7">{
        if settings.Convert == "disabled" </span><span class="cov0" title="0">{
                log.Print("[DEBUG] dictionary migration disabled")
                return nil
        }</span>

        <span class="cov4" title="7">migrateDict := func(file string, dictType storage.DictionaryType) (*storage.DictionaryStats, error) </span><span class="cov5" title="12">{
                if _, err := os.Stat(file); err != nil </span><span class="cov3" title="5">{
                        log.Printf("[DEBUG] dictionary file %s not found, skip", file)
                        return &amp;storage.DictionaryStats{}, nil
                }</span>
                <span class="cov4" title="7">fh, err := os.Open(file) //nolint:gosec // file path is controlled by the app
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't open dictionary file, %w", err)
                }</span>
                <span class="cov4" title="7">defer fh.Close()
                stats, err := dictDB.Import(ctx, dictType, fh, true) // clean records before import
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't load dictionary, %w", err)
                }</span>
                <span class="cov4" title="7">if err := fh.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't close dictionary file, %w", err)
                }</span>
                <span class="cov4" title="7">if err := os.Rename(file, file+".loaded"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't rename dictionary file, %w", err)
                }</span>
                <span class="cov4" title="7">return stats, nil</span>
        }

        <span class="cov4" title="7">if dictDB == nil </span><span class="cov1" title="1">{
                return errors.New("dictionary db is nil")
        }</span>

        // migrate stop-words if files exist
        <span class="cov4" title="6">stopWordsFile := filepath.Join(settings.Files.SamplesDataPath, stopWordsFile)
        s, err := migrateDict(stopWordsFile, storage.DictionaryTypeStopPhrase)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't migrate stop words, %w", err)
        }</span>
        <span class="cov4" title="6">if s.TotalStopPhrases &gt; 0 </span><span class="cov2" title="2">{
                log.Printf("[INFO] stop words loaded: %s", s)
        }</span>

        // migrate excluded tokens if files exist
        <span class="cov4" title="6">excludeTokensFile := filepath.Join(settings.Files.SamplesDataPath, excludeTokensFile)
        s, err = migrateDict(excludeTokensFile, storage.DictionaryTypeIgnoredWord)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't migrate excluded tokens, %w", err)
        }</span>
        <span class="cov4" title="6">if s.TotalIgnoredWords &gt; 0 </span><span class="cov2" title="3">{
                log.Printf("[INFO] excluded tokens loaded: %s", s)
        }</span>

        <span class="cov4" title="6">if s.TotalIgnoredWords &gt; 0 || s.TotalStopPhrases &gt; 0 </span><span class="cov2" title="3">{
                log.Printf("[DEBUG] dictionaries migration done: %s", s)
        }</span>
        <span class="cov4" title="6">return nil</span>
}

// backupDB creates a backup of the db file if the version has changed. It copies the db file to a new db file
// named as the original file with a version suffix, e.g., tg-spam.db.master-77e0bfd-20250107T23:17:34.
// The file is created only if the version has changed and a backup file with the name tg-spam.db.&lt;version&gt; does not exist.
// It keeps up to maxBackups files; if maxBackups is 0, no backups are made.
// Files are removed based on the final part of the version, i.e., 20250107T23:17:34, with the oldest backups removed first.
// If the backup file extension suffix with the timestamp is not found, the modification time of the file is used instead.
func backupDB(dbFile, version string, maxBackups int) error <span class="cov4" title="6">{
        if maxBackups == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="5">backupFile := dbFile + "." + strings.ReplaceAll(version, ".", "_") // replace dots with underscores for file name
        if _, err := os.Stat(backupFile); err == nil </span><span class="cov1" title="1">{
                // backup file for the version already exists, no need to make it again
                return nil
        }</span>
        <span class="cov3" title="4">if _, err := os.Stat(dbFile); err != nil </span><span class="cov1" title="1">{
                // db file not found, no need to backup. This is legit if the db is not created yet on the first run
                log.Printf("[WARN] db file not found: %s, skip backup", dbFile)
                return nil
        }</span>

        <span class="cov2" title="3">log.Printf("[DEBUG] db backup: %s -&gt; %s", dbFile, backupFile)
        // copy current db to the backup file
        if err := fileutils.CopyFile(dbFile, backupFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy db file: %w", err)
        }</span>
        <span class="cov2" title="3">log.Printf("[INFO] db backup created: %s", backupFile)

        // cleanup old backups if needed
        files, err := filepath.Glob(dbFile + ".*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list backup files: %w", err)
        }</span>

        <span class="cov2" title="3">if len(files) &lt;= maxBackups </span><span class="cov1" title="1">{
                return nil
        }</span>

        // sort files by timestamp in version suffix or mod time if suffix not formatted as timestamp
        <span class="cov2" title="2">sort.Slice(files, func(i, j int) bool </span><span class="cov4" title="6">{
                getTime := func(f string) time.Time </span><span class="cov5" title="12">{
                        base := filepath.Base(f) // file name like this: tg-spam.db.master-77e0bfd-20250107T23:17:34
                        // try to get timestamp from version suffix first
                        parts := strings.Split(base, "-")
                        if len(parts) &gt;= 3 </span><span class="cov4" title="10">{
                                suffix := parts[len(parts)-1]
                                if t, err := time.ParseInLocation("20060102T15:04:05", suffix, time.Local); err == nil </span><span class="cov4" title="10">{
                                        return t
                                }</span>
                        }
                        // fallback to modification time for non-versioned files
                        <span class="cov2" title="2">fi, err := os.Stat(f)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[WARN] can't stat file %s: %v", f, err)
                                return time.Now().Local() // treat errored files as newest to avoid deleting them
                        }</span>
                        <span class="cov2" title="2">return fi.ModTime().Local()</span> // convert to local for consistent comparison
                }
                <span class="cov4" title="6">return getTime(files[i]).Before(getTime(files[j]))</span>
        })

        // remove oldest files
        <span class="cov2" title="2">for i := 0; i &lt; len(files)-maxBackups; i++ </span><span class="cov2" title="3">{
                if err := os.Remove(files[i]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove old backup %s: %w", files[i], err)
                }</span>
                <span class="cov2" title="3">log.Printf("[DEBUG] db backup removed: %s", files[i])</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// generateAuthHash creates a bcrypt hash from the given password
// If the password is "auto", generates a random password first
func generateAuthHash(password string) (string, error) <span class="cov2" title="2">{
        var hashSource string
        var randomPassword string
        var err error

        // generate random password if needed
        if password == "auto" </span><span class="cov1" title="1">{
                randomPassword, err = webapi.GenerateRandomPassword(20)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("can't generate random password: %w", err)
                }</span>
                <span class="cov1" title="1">hashSource = randomPassword</span>
        } else<span class="cov1" title="1"> {
                hashSource = password
        }</span>

        // generate hash from the password or random password
        <span class="cov2" title="2">hash, err := rest.GenerateBcryptHash(hashSource)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("can't generate bcrypt hash: %w", err)
        }</span>

        // log the appropriate message
        <span class="cov2" title="2">if password == "auto" </span><span class="cov1" title="1">{
                log.Printf("[WARN] generated basic auth password for user tg-spam: %q, bcrypt hash: %s", randomPassword, hash)
        }</span> else<span class="cov1" title="1"> {
                log.Printf("[INFO] generated bcrypt hash from provided password")
        }</span>

        <span class="cov2" title="2">return hash, nil</span>
}

// optToSettings converts CLI options to the domain settings model
func optToSettings(opts options) *config.Settings <span class="cov0" title="0">{
        // create settings model from options
        settings := &amp;config.Settings{
                InstanceID: opts.InstanceID,

                Telegram: config.TelegramSettings{
                        Group:        opts.Telegram.Group,
                        IdleDuration: opts.Telegram.IdleDuration,
                        Timeout:      opts.Telegram.Timeout,
                },

                Admin: config.AdminSettings{
                        AdminGroup:              opts.AdminGroup,
                        DisableAdminSpamForward: opts.DisableAdminSpamForward,
                        TestingIDs:              opts.TestingIDs,
                        SuperUsers:              opts.SuperUsers,
                },

                History: config.HistorySettings{
                        Duration: opts.HistoryDuration,
                        MinSize:  opts.HistoryMinSize,
                        Size:     opts.HistorySize,
                },

                Logger: config.LoggerSettings{
                        Enabled:    opts.Logger.Enabled,
                        FileName:   opts.Logger.FileName,
                        MaxSize:    opts.Logger.MaxSize,
                        MaxBackups: opts.Logger.MaxBackups,
                },

                CAS: config.CASSettings{
                        API:       opts.CAS.API,
                        Timeout:   opts.CAS.Timeout,
                        UserAgent: opts.CAS.UserAgent,
                },

                Meta: config.MetaSettings{
                        LinksLimit:      opts.Meta.LinksLimit,
                        MentionsLimit:   opts.Meta.MentionsLimit,
                        ImageOnly:       opts.Meta.ImageOnly,
                        LinksOnly:       opts.Meta.LinksOnly,
                        VideosOnly:      opts.Meta.VideosOnly,
                        AudiosOnly:      opts.Meta.AudiosOnly,
                        Forward:         opts.Meta.Forward,
                        Keyboard:        opts.Meta.Keyboard,
                        UsernameSymbols: opts.Meta.UsernameSymbols,
                },

                OpenAI: config.OpenAISettings{
                        APIBase:           opts.OpenAI.APIBase,
                        Veto:              opts.OpenAI.Veto,
                        Prompt:            opts.OpenAI.Prompt,
                        CustomPrompts:     opts.OpenAI.CustomPrompts,
                        Model:             opts.OpenAI.Model,
                        MaxTokensResponse: opts.OpenAI.MaxTokensResponse,
                        MaxTokensRequest:  opts.OpenAI.MaxTokensRequest,
                        MaxSymbolsRequest: opts.OpenAI.MaxSymbolsRequest,
                        RetryCount:        opts.OpenAI.RetryCount,
                        HistorySize:       opts.OpenAI.HistorySize,
                        ReasoningEffort:   opts.OpenAI.ReasoningEffort,
                },

                LuaPlugins: config.LuaPluginsSettings{
                        Enabled:        opts.LuaPlugins.Enabled,
                        PluginsDir:     opts.LuaPlugins.PluginsDir,
                        EnabledPlugins: opts.LuaPlugins.EnabledPlugins,
                        DynamicReload:  opts.LuaPlugins.DynamicReload,
                },

                AbnormalSpace: config.AbnormalSpaceSettings{
                        Enabled:                 opts.AbnormalSpacing.Enabled,
                        SpaceRatioThreshold:     opts.AbnormalSpacing.SpaceRatioThreshold,
                        ShortWordRatioThreshold: opts.AbnormalSpacing.ShortWordRatioThreshold,
                        ShortWordLen:            opts.AbnormalSpacing.ShortWordLen,
                        MinWords:                opts.AbnormalSpacing.MinWords,
                },

                Files: config.FilesSettings{
                        SamplesDataPath: opts.Files.SamplesDataPath,
                        DynamicDataPath: opts.Files.DynamicDataPath,
                        WatchInterval:   int(opts.Files.WatchInterval.Seconds()),
                },

                Message: config.MessageSettings{
                        Startup: opts.Message.Startup,
                        Spam:    opts.Message.Spam,
                        Dry:     opts.Message.Dry,
                        Warn:    opts.Message.Warn,
                },

                Server: config.ServerSettings{
                        Enabled:    opts.Server.Enabled,
                        ListenAddr: opts.Server.ListenAddr,
                        AuthUser:   opts.Server.AuthUser,
                },

                SimilarityThreshold: opts.SimilarityThreshold,
                MinMsgLen:           opts.MinMsgLen,
                MaxEmoji:            opts.MaxEmoji,
                MinSpamProbability:  opts.MinSpamProbability,
                MultiLangWords:      opts.MultiLangWords,
                NoSpamReply:         opts.NoSpamReply,
                SuppressJoinMessage: opts.SuppressJoinMessage,
                ParanoidMode:        opts.ParanoidMode,
                FirstMessagesCount:  opts.FirstMessagesCount,
                Training:            opts.Training,
                SoftBan:             opts.SoftBan,
                Convert:             opts.Convert,
                MaxBackups:          opts.MaxBackups,
                Dry:                 opts.Dry,
        }

        // set transient settings (not persisted to database)
        settings.Transient = config.TransientSettings{
                DataBaseURL:        opts.DataBaseURL,
                StorageTimeout:     opts.StorageTimeout,
                ConfigDB:           opts.ConfigDB,
                Dbg:                opts.Dbg,
                TGDbg:              opts.TGDbg,
                WebAuthPasswd:      opts.Server.AuthPasswd,
                ConfigDBEncryptKey: opts.ConfigDBEncryptKey,
        }

        // set credentials in their respective domain structures
        settings.Telegram.Token = opts.Telegram.Token
        settings.OpenAI.Token = opts.OpenAI.Token
        settings.Server.AuthHash = opts.Server.AuthHash

        return settings
}</span>

// applyCLIOverrides applies explicit CLI overrides to settings loaded from database
// Only overrides values that were explicitly set on the command line (not defaults)
//
// How to add new overrides:
// 1. Check if the CLI option was explicitly provided (not using default value)
// 2. Compare with the default value from the options struct definition
// 3. Apply the override only if the value differs from the default
//
// Example for adding telegram token override:
//
//        if opts.Telegram.Token != "" {  // "" is the default
//            settings.Telegram.Token = opts.Telegram.Token
//        }
func applyCLIOverrides(settings *config.Settings, opts options) <span class="cov3" title="4">{
        // override auth password if explicitly provided (not using default "auto")
        if opts.Server.AuthPasswd != "auto" </span><span class="cov2" title="2">{
                settings.Transient.WebAuthPasswd = opts.Server.AuthPasswd
                // clear auth hash since we have a new password
                settings.Server.AuthHash = ""
        }</span>

        // override auth hash if explicitly provided
        <span class="cov3" title="4">if opts.Server.AuthHash != "" </span><span class="cov2" title="2">{
                settings.Server.AuthHash = opts.Server.AuthHash
                // clear password since hash takes precedence
                settings.Transient.WebAuthPasswd = ""
        }</span>
}

// loadConfigFromDB loads configuration from the database
func loadConfigFromDB(ctx context.Context, settings *config.Settings) error <span class="cov4" title="6">{
        if !settings.Transient.ConfigDB </span><span class="cov0" title="0">{
                return nil // skip if not enabled
        }</span>

        <span class="cov4" title="6">log.Print("[INFO] loading configuration from database")

        // create database connection using the same logic as main data DB
        db, err := makeDB(ctx, settings)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to connect to database for config: %w", err)
        }</span>

        // create settings store with encryption if key provided
        <span class="cov3" title="5">var storeOpts []config.StoreOption
        if settings.Transient.ConfigDBEncryptKey != "" </span><span class="cov0" title="0">{
                crypter, cryptErr := config.NewCrypter(settings.Transient.ConfigDBEncryptKey, settings.InstanceID)
                if cryptErr != nil </span><span class="cov0" title="0">{
                        log.Fatalf("[FATAL] invalid encryption key: %v", cryptErr)
                }</span>
                <span class="cov0" title="0">storeOpts = append(storeOpts, config.WithCrypter(crypter))
                log.Print("[INFO] configuration encryption enabled for database access")</span>
        }

        <span class="cov3" title="5">settingsStore, err := config.NewStore(ctx, db, storeOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create settings store: %w", err)
        }</span>

        // load settings
        <span class="cov3" title="5">dbSettings, err := settingsStore.Load(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to load settings from database: %w", err)
        }</span>

        // save original transient values only (non-functional values)
        <span class="cov3" title="4">transient := settings.Transient

        // replace settings with loaded values including credentials
        *settings = *dbSettings

        // restore transient values
        settings.Transient = transient

        log.Printf("[INFO] configuration loaded from database successfully")
        return nil</span>
}

// saveConfigToDB saves the current configuration to the database
func saveConfigToDB(ctx context.Context, settings *config.Settings) error <span class="cov3" title="5">{
        log.Print("[INFO] saving configuration to database")

        // create database connection
        db, err := makeDB(ctx, settings)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to connect to database for config: %w", err)
        }</span>

        // create settings store with encryption if key provided
        <span class="cov3" title="4">var storeOpts []config.StoreOption
        if settings.Transient.ConfigDBEncryptKey != "" </span><span class="cov0" title="0">{
                crypter, cryptErr := config.NewCrypter(settings.Transient.ConfigDBEncryptKey, settings.InstanceID)
                if cryptErr != nil </span><span class="cov0" title="0">{
                        log.Fatalf("[FATAL] invalid encryption key: %v", cryptErr)
                }</span>
                <span class="cov0" title="0">storeOpts = append(storeOpts, config.WithCrypter(crypter))
                log.Print("[INFO] configuration encryption enabled for database storage")</span>
        }

        <span class="cov3" title="4">settingsStore, err := config.NewStore(ctx, db, storeOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create settings store: %w", err)
        }</span>

        // generate auth hash if password is provided but hash isn't
        <span class="cov3" title="4">if settings.Transient.WebAuthPasswd != "" &amp;&amp; settings.Server.AuthHash == "" </span><span class="cov1" title="1">{
                // generate bcrypt hash from the password
                hash, hashErr := generateAuthHash(settings.Transient.WebAuthPasswd)
                if hashErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate auth hash: %w", hashErr)
                }</span>

                // update the hash directly in the Server settings domain
                <span class="cov1" title="1">settings.Server.AuthHash = hash</span>
        }

        // save settings to database
        <span class="cov3" title="4">if err := settingsStore.Save(ctx, settings); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration to database: %w", err)
        }</span>

        <span class="cov3" title="4">log.Printf("[INFO] configuration saved to database successfully")
        return nil</span>
}

func setupLog(dbg bool, secrets ...string) <span class="cov2" title="2">{
        logOpts := []lgr.Option{lgr.Msec, lgr.LevelBraces, lgr.StackTraceOnError}
        if dbg </span><span class="cov2" title="2">{
                logOpts = []lgr.Option{lgr.Debug, lgr.CallerFile, lgr.CallerFunc, lgr.Msec, lgr.LevelBraces, lgr.StackTraceOnError}
        }</span>

        <span class="cov2" title="2">colorizer := lgr.Mapper{
                ErrorFunc:  func(s string) string </span><span class="cov0" title="0">{ return color.New(color.FgHiRed).Sprint(s) }</span>,
                WarnFunc:   func(s string) string <span class="cov7" title="36">{ return color.New(color.FgRed).Sprint(s) }</span>,
                InfoFunc:   func(s string) string <span class="cov9" title="128">{ return color.New(color.FgYellow).Sprint(s) }</span>,
                DebugFunc:  func(s string) string <span class="cov10" title="198">{ return color.New(color.FgWhite).Sprint(s) }</span>,
                CallerFunc: func(s string) string <span class="cov9" title="181">{ return color.New(color.FgBlue).Sprint(s) }</span>,
                TimeFunc:   func(s string) string <span class="cov9" title="181">{ return color.New(color.FgCyan).Sprint(s) }</span>,
        }
        <span class="cov2" title="2">logOpts = append(logOpts, lgr.Map(colorizer))

        if len(secrets) &gt; 0 </span><span class="cov1" title="1">{
                logOpts = append(logOpts, lgr.Secret(secrets...))
        }</span>
        <span class="cov2" title="2">lgr.SetupStdLogger(logOpts...)
        lgr.Setup(logOpts...)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package storage

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/jmoiron/sqlx"
        _ "modernc.org/sqlite" // sqlite driver loaded here

        "github.com/umputun/tg-spam/app/storage/engine"
        "github.com/umputun/tg-spam/lib/approved"
)

// ApprovedUsers is a storage for approved users
type ApprovedUsers struct {
        *engine.SQL
        engine.RWLocker
}

// approvedUsersInfo is a struct to store approved user info in the database
type approvedUsersInfo struct {
        UserID    string    `db:"uid"`
        GroupID   string    `db:"gid"`
        UserName  string    `db:"name"`
        Timestamp time.Time `db:"timestamp"`
}

// all approved users queries
const (
        CmdCreateApprovedUsersTable engine.DBCmd = iota + 100
        CmdCreateApprovedUsersIndexes
        CmdAddApprovedUser
        CmdAddUIDColumn
        CmdAddGIDColumn
)

// queries holds all approved users queries
var approvedUsersQueries = engine.NewQueryMap().
        Add(CmdCreateApprovedUsersTable, engine.Query{
                Sqlite: `CREATE TABLE IF NOT EXISTS approved_users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            uid TEXT,
            gid TEXT DEFAULT '',
            name TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(gid, uid)
        )`,
                Postgres: `CREATE TABLE IF NOT EXISTS approved_users (
            id SERIAL PRIMARY KEY,
            uid TEXT,
            gid TEXT DEFAULT '',
            name TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(gid, uid)
        )`,
        }).
        AddSame(CmdCreateApprovedUsersIndexes, `
        CREATE INDEX IF NOT EXISTS idx_approved_users_uid ON approved_users(uid);
        CREATE INDEX IF NOT EXISTS idx_approved_users_gid ON approved_users(gid);
        CREATE INDEX IF NOT EXISTS idx_approved_users_name ON approved_users(name);
        CREATE INDEX IF NOT EXISTS idx_approved_users_timestamp ON approved_users(timestamp)
    `).
        Add(CmdAddApprovedUser, engine.Query{
                Sqlite:   "INSERT OR REPLACE INTO approved_users (uid, gid, name, timestamp) VALUES (?, ?, ?, ?)",
                Postgres: "INSERT INTO approved_users (uid, gid, name, timestamp) VALUES ($1, $2, $3, $4) ON CONFLICT (gid, uid) DO UPDATE SET name=EXCLUDED.name, timestamp=EXCLUDED.timestamp",
        }).
        Add(CmdAddUIDColumn, engine.Query{
                Sqlite:   "ALTER TABLE approved_users ADD COLUMN uid TEXT",
                Postgres: "ALTER TABLE approved_users ADD COLUMN IF NOT EXISTS uid TEXT",
        }).
        Add(CmdAddGIDColumn, engine.Query{
                Sqlite:   "ALTER TABLE approved_users ADD COLUMN gid TEXT DEFAULT ''",
                Postgres: "ALTER TABLE approved_users ADD COLUMN IF NOT EXISTS gid TEXT DEFAULT ''",
        })

// NewApprovedUsers creates a new ApprovedUsers storage
func NewApprovedUsers(ctx context.Context, db *engine.SQL) (*ApprovedUsers, error) <span class="cov10" title="44">{
        if db == nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("db connection is nil")
        }</span>
        <span class="cov9" title="42">res := &amp;ApprovedUsers{SQL: db, RWLocker: db.MakeLock()}
        cfg := engine.TableConfig{
                Name:          "approved_users",
                CreateTable:   CmdCreateApprovedUsersTable,
                CreateIndexes: CmdCreateApprovedUsersIndexes,
                MigrateFunc:   res.migrate,
                QueriesMap:    approvedUsersQueries,
        }
        if err := engine.InitTable(ctx, db, cfg); err != nil </span><span class="cov4" title="4">{
                return nil, fmt.Errorf("failed to init approved users storage: %w", err)
        }</span>
        <span class="cov9" title="38">return res, nil</span>
}

// Read returns a list of all approved users
func (au *ApprovedUsers) Read(ctx context.Context) ([]approved.UserInfo, error) <span class="cov8" title="25">{
        au.RLock()
        defer au.RUnlock()

        query := au.Adopt("SELECT uid, gid, name, timestamp FROM approved_users WHERE gid = ? ORDER BY uid ASC")
        users := []approvedUsersInfo{}
        if err := au.SelectContext(ctx, &amp;users, query, au.GID()); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to get approved users: %w", err)
        }</span>

        <span class="cov8" title="23">res := make([]approved.UserInfo, len(users))
        for i, u := range users </span><span class="cov8" title="27">{
                res[i] = approved.UserInfo{
                        UserID:    u.UserID,
                        UserName:  u.UserName,
                        Timestamp: u.Timestamp,
                }
        }</span>
        <span class="cov8" title="23">log.Printf("[DEBUG] read %d approved users", len(res))
        return res, nil</span>
}

// Write adds a user to the approved list
func (au *ApprovedUsers) Write(ctx context.Context, user approved.UserInfo) error <span class="cov9" title="43">{
        if user.UserID == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("user id can't be empty")
        }</span>

        <span class="cov9" title="41">au.Lock()
        defer au.Unlock()

        if user.Timestamp.IsZero() </span><span class="cov9" title="33">{
                user.Timestamp = time.Now()
        }</span>

        <span class="cov9" title="41">query, err := approvedUsersQueries.Pick(au.Type(), CmdAddApprovedUser)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get write query: %w", err)
        }</span>

        <span class="cov9" title="41">if _, err := au.ExecContext(ctx, query, user.UserID, au.GID(), user.UserName, user.Timestamp); err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("failed to insert user %+v: %w", user, err)
        }</span>

        <span class="cov9" title="37">log.Printf("[INFO] user %q (%s) added to approved users", user.UserName, user.UserID)
        return nil</span>
}

// Delete removes a user from the approved list
func (au *ApprovedUsers) Delete(ctx context.Context, id string) error <span class="cov5" title="8">{
        if id == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("user id can't be empty")
        }</span>

        <span class="cov5" title="6">au.Lock()
        defer au.Unlock()

        // check if user exists first
        var user approvedUsersInfo
        query := au.Adopt("SELECT uid, gid, name, timestamp FROM approved_users WHERE uid = ? AND gid = ?")
        if err := au.GetContext(ctx, &amp;user, query, id, au.GID()); err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("failed to get approved user for id %s: %w", id, err)
        }</span>

        // delete user  "DELETE FROM approved_users WHERE uid = ? AND gid = ?"
        <span class="cov2" title="2">query = au.Adopt("DELETE FROM approved_users WHERE uid = ? AND gid = ?")
        if _, err := au.ExecContext(ctx, query, id, au.GID()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete id %s: %w", id, err)
        }</span>

        <span class="cov2" title="2">log.Printf("[INFO] user %q (%s) deleted from approved users", user.UserName, id)
        return nil</span>
}

// migrateTableTx handles migration within a transaction
func (au *ApprovedUsers) migrate(ctx context.Context, tx *sqlx.Tx, gid string) error <span class="cov9" title="38">{
        // try to select with new structure, if works - already migrated
        var count int
        err := tx.GetContext(ctx, &amp;count, "SELECT COUNT(*) FROM approved_users WHERE uid='' AND gid=''")
        if err == nil </span><span class="cov9" title="35">{
                log.Printf("[DEBUG] approved_users table already migrated")
                return nil
        }</span>

        // add columns using db-specific queries
        <span class="cov3" title="3">addUIDQuery, err := approvedUsersQueries.Pick(au.Type(), CmdAddUIDColumn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add UID query: %w", err)
        }</span>

        <span class="cov3" title="3">_, err = tx.ExecContext(ctx, addUIDQuery)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "duplicate column") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add uid column: %w", err)
        }</span>

        <span class="cov3" title="3">addGIDQuery, err := approvedUsersQueries.Pick(au.Type(), CmdAddGIDColumn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add GID query: %w", err)
        }</span>

        <span class="cov3" title="3">_, err = tx.ExecContext(ctx, addGIDQuery)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "duplicate column") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add gid column: %w", err)
        }</span>

        <span class="cov3" title="3">migrateQuery := au.Adopt("UPDATE approved_users SET uid = id, gid = ? WHERE uid IS NULL OR uid = ''")
        if _, err = tx.ExecContext(ctx, migrateQuery, gid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to migrate data: %w", err)
        }</span>

        <span class="cov3" title="3">log.Printf("[DEBUG] approved_users table migrated")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package storage

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/jmoiron/sqlx"

        "github.com/umputun/tg-spam/app/storage/engine"
        "github.com/umputun/tg-spam/lib/spamcheck"
)

const maxDetectedSpamEntries = 500

// DetectedSpam is a storage for detected spam entries
type DetectedSpam struct {
        *engine.SQL
        engine.RWLocker
}

// DetectedSpamInfo represents information about a detected spam entry.
type DetectedSpamInfo struct {
        ID         int64                `db:"id"`
        GID        string               `db:"gid"`
        Text       string               `db:"text"`
        UserID     int64                `db:"user_id"`
        UserName   string               `db:"user_name"`
        Timestamp  time.Time            `db:"timestamp"`
        Added      bool                 `db:"added"`  // added to samples
        ChecksJSON string               `db:"checks"` // store as JSON
        Checks     []spamcheck.Response `db:"-"`      // don't store in DB directly
}

// detected spam query commands
const (
        CmdCreateDetectedSpamTable engine.DBCmd = iota + 200
        CmdCreateDetectedSpamIndexes
)

// queries holds all detected spam queries
var detectedSpamQueries = engine.NewQueryMap().
        Add(CmdCreateDetectedSpamTable, engine.Query{
                Sqlite: `CREATE TABLE IF NOT EXISTS detected_spam (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            gid TEXT NOT NULL DEFAULT '',
            text TEXT,
            user_id INTEGER,
            user_name TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            added BOOLEAN DEFAULT 0,
            checks TEXT
        )`,
                Postgres: `CREATE TABLE IF NOT EXISTS detected_spam (
            id SERIAL PRIMARY KEY,
            gid TEXT NOT NULL DEFAULT '',
            text TEXT,
            user_id BIGINT,
            user_name TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            added BOOLEAN DEFAULT false,
            checks TEXT
        )`,
        }).
        AddSame(CmdCreateDetectedSpamIndexes, `
              CREATE INDEX IF NOT EXISTS idx_detected_spam_gid_ts ON detected_spam(gid, timestamp DESC);
        CREATE INDEX IF NOT EXISTS idx_detected_spam_user_id_gid ON detected_spam(user_id, gid);
                CREATE INDEX IF NOT EXISTS idx_spam_gid_time ON detected_spam(gid, timestamp DESC);
        CREATE INDEX IF NOT EXISTS idx_detected_spam_gid ON detected_spam(gid)`,
        ).
        Add(CmdAddGIDColumn, engine.Query{
                Sqlite:   "ALTER TABLE detected_spam ADD COLUMN gid TEXT DEFAULT ''",
                Postgres: "ALTER TABLE detected_spam ADD COLUMN IF NOT EXISTS gid TEXT DEFAULT ''",
        })

// NewDetectedSpam creates a new DetectedSpam storage
func NewDetectedSpam(ctx context.Context, db *engine.SQL) (*DetectedSpam, error) <span class="cov5" title="24">{
        if db == nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("db connection is nil")
        }</span>
        <span class="cov5" title="22">res := &amp;DetectedSpam{SQL: db, RWLocker: db.MakeLock()}
        cfg := engine.TableConfig{
                Name:          "detected_spam",
                CreateTable:   CmdCreateDetectedSpamTable,
                CreateIndexes: CmdCreateDetectedSpamIndexes,
                MigrateFunc:   res.migrate,
                QueriesMap:    detectedSpamQueries,
        }
        if err := engine.InitTable(ctx, db, cfg); err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("failed to init detected spam storage: %w", err)
        }</span>
        <span class="cov4" title="20">return res, nil</span>
}

// Write adds a new detected spam entry
func (ds *DetectedSpam) Write(ctx context.Context, entry DetectedSpamInfo, checks []spamcheck.Response) error <span class="cov10" title="1040">{
        ds.Lock()
        defer ds.Unlock()

        if entry.GID == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("missing required GID field")
        }</span>

        <span class="cov9" title="1038">checksJSON, err := json.Marshal(checks)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal checks: %w", err)
        }</span>

        <span class="cov9" title="1038">query := ds.Adopt("INSERT INTO detected_spam (gid, text, user_id, user_name, timestamp, checks) VALUES (?, ?, ?, ?, ?, ?)")
        _, err = ds.ExecContext(ctx, query, entry.GID, entry.Text, entry.UserID, entry.UserName, entry.Timestamp, string(checksJSON))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert detected spam entry: %w", err)
        }</span>

        <span class="cov9" title="1038">log.Printf("[INFO] detected spam entry added for gid:%s, user_id:%d, name:%s", entry.GID, entry.UserID, entry.UserName)
        return nil</span>
}

// SetAddedToSamplesFlag sets the added flag to true for the detected spam entry with the given id
func (ds *DetectedSpam) SetAddedToSamplesFlag(ctx context.Context, id int64) error <span class="cov1" title="2">{
        ds.Lock()
        defer ds.Unlock()

        query := ds.Adopt("UPDATE detected_spam SET added = ? WHERE id = ?")
        if _, err := ds.ExecContext(ctx, query, true, id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update added to samples flag: %w", err)
        }</span>
        <span class="cov1" title="2">return nil</span>
}

// Read returns the latest detected spam entries, up to maxDetectedSpamEntries
func (ds *DetectedSpam) Read(ctx context.Context) ([]DetectedSpamInfo, error) <span class="cov4" title="11">{
        ds.RLock()
        defer ds.RUnlock()

        query := ds.Adopt("SELECT * FROM detected_spam WHERE gid = ? ORDER BY timestamp DESC LIMIT ?")
        var entries []DetectedSpamInfo
        err := ds.SelectContext(ctx, &amp;entries, query, ds.GID(), maxDetectedSpamEntries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get detected spam entries: %w", err)
        }</span>

        <span class="cov4" title="11">for i, entry := range entries </span><span class="cov9" title="1009">{
                var checks []spamcheck.Response
                if err := json.Unmarshal([]byte(entry.ChecksJSON), &amp;checks); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal checks for entry %d: %w", i, err)
                }</span>
                <span class="cov9" title="1009">entries[i].Checks = checks
                entries[i].Timestamp = entry.Timestamp.Local()</span>
        }
        <span class="cov4" title="11">return entries, nil</span>
}

// FindByUserID returns the latest detected spam entry for the given user ID
func (ds *DetectedSpam) FindByUserID(ctx context.Context, userID int64) (*DetectedSpamInfo, error) <span class="cov3" title="8">{
        ds.RLock()
        defer ds.RUnlock()

        query := ds.Adopt("SELECT * FROM detected_spam WHERE user_id = ? AND gid = ? ORDER BY timestamp DESC LIMIT 1")
        var entry DetectedSpamInfo
        err := ds.GetContext(ctx, &amp;entry, query, userID, ds.GID())
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="2">{
                // not found, return nil *DetectedSpamInfo instead of error
                return nil, nil
        }</span>
        <span class="cov3" title="6">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get detected spam entry for user_id %d: %w", userID, err)
        }</span>

        <span class="cov3" title="6">var checks []spamcheck.Response
        if err := json.Unmarshal([]byte(entry.ChecksJSON), &amp;checks); err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("failed to unmarshal checks for entry: %w", err)
        }</span>
        <span class="cov2" title="4">entry.Checks = checks
        entry.Timestamp = entry.Timestamp.Local()
        return &amp;entry, nil</span>
}

func (ds *DetectedSpam) migrate(ctx context.Context, tx *sqlx.Tx, gid string) error <span class="cov4" title="20">{
        // try to select with new structure, if works - already migrated
        var count int
        err := tx.GetContext(ctx, &amp;count, "SELECT COUNT(*) FROM detected_spam WHERE gid = ''")
        if err == nil </span><span class="cov4" title="19">{
                log.Printf("[DEBUG] detected_spam table already migrated")
                return nil
        }</span>

        // add gid column using db-specific query
        <span class="cov1" title="1">addGIDQuery, err := detectedSpamQueries.Pick(ds.Type(), CmdAddGIDColumn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add GID query: %w", err)
        }</span>

        <span class="cov1" title="1">_, err = tx.ExecContext(ctx, addGIDQuery)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "duplicate column") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add gid column: %w", err)
        }</span>

        // update existing records with provided gid
        <span class="cov1" title="1">if _, err = tx.ExecContext(ctx, "UPDATE detected_spam SET gid = ? WHERE gid = ''", gid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update gid for existing records: %w", err)
        }</span>

        <span class="cov1" title="1">log.Printf("[DEBUG] detected_spam table migrated")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package storage

import (
        "context"
        "encoding/csv"
        "fmt"
        "io"
        "iter"
        "strings"

        "github.com/jmoiron/sqlx"

        "github.com/umputun/tg-spam/app/storage/engine"
)

// dictionary-related command constants
const (
        CmdCreateDictionaryTable engine.DBCmd = iota + 300
        CmdCreateDictionaryIndexes
        CmdAddDictionaryEntry
        CmdImportDictionaryEntry
)

// all dictionary-related queries
var dictionaryQueries = engine.NewQueryMap().
        Add(CmdCreateDictionaryTable, engine.Query{
                Sqlite: `CREATE TABLE IF NOT EXISTS dictionary (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            gid TEXT DEFAULT '',
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            type TEXT CHECK (type IN ('stop_phrase', 'ignored_word')),
            data TEXT NOT NULL,
            UNIQUE(gid, data)
        )`,
                Postgres: `CREATE TABLE IF NOT EXISTS dictionary (
            id SERIAL PRIMARY KEY,
            gid TEXT DEFAULT '',
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            type TEXT CHECK (type IN ('stop_phrase', 'ignored_word')),
            data TEXT NOT NULL,
            UNIQUE(gid, data)
        )`,
        }).
        Add(CmdCreateDictionaryIndexes, engine.Query{
                Sqlite: `
                        CREATE INDEX IF NOT EXISTS idx_dictionary_timestamp ON dictionary(timestamp);
                        CREATE INDEX IF NOT EXISTS idx_dictionary_type ON dictionary(type);
                        CREATE INDEX IF NOT EXISTS idx_dictionary_phrase ON dictionary(data);
                        CREATE INDEX IF NOT EXISTS idx_dictionary_gid ON dictionary(gid)`,
                Postgres: `
                        CREATE INDEX IF NOT EXISTS idx_dictionary_gid_type_ts ON dictionary(gid, type, timestamp);
                        CREATE INDEX IF NOT EXISTS idx_dictionary_gid_data ON dictionary(gid, data)`,
        }).
        Add(CmdAddGIDColumn, engine.Query{
                Sqlite:   "ALTER TABLE dictionary ADD COLUMN gid TEXT DEFAULT ''",
                Postgres: "ALTER TABLE dictionary ADD COLUMN IF NOT EXISTS gid TEXT DEFAULT ''",
        }).
        Add(CmdAddDictionaryEntry, engine.Query{
                Sqlite:   `INSERT OR IGNORE INTO dictionary (type, data, gid) VALUES (?, ?, ?)`,
                Postgres: `INSERT INTO dictionary (type, data, gid) VALUES ($1, $2, $3) ON CONFLICT (gid, data) DO NOTHING`,
        }).
        Add(CmdImportDictionaryEntry, engine.Query{
                Sqlite:   `INSERT OR REPLACE INTO dictionary (type, data, gid) VALUES (?, ?, ?)`,
                Postgres: `INSERT INTO dictionary (type, data, gid) VALUES ($1, $2, $3) ON CONFLICT (gid, data) DO UPDATE SET type = EXCLUDED.type`,
        })

// Dictionary is a storage for stop words/phrases and ignored words
type Dictionary struct {
        *engine.SQL
        engine.RWLocker
}

// DictionaryType represents the type of dictionary entry
type DictionaryType string

// enum for dictionary types
const (
        DictionaryTypeStopPhrase  DictionaryType = "stop_phrase"
        DictionaryTypeIgnoredWord DictionaryType = "ignored_word"
)

// NewDictionary creates a new Dictionary storage
func NewDictionary(ctx context.Context, db *engine.SQL) (*Dictionary, error) <span class="cov5" title="38">{
        if db == nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("db connection is nil")
        }</span>
        <span class="cov5" title="36">res := &amp;Dictionary{SQL: db, RWLocker: db.MakeLock()}
        cfg := engine.TableConfig{
                Name:          "dictionary",
                CreateTable:   CmdCreateDictionaryTable,
                CreateIndexes: CmdCreateDictionaryIndexes,
                MigrateFunc:   res.migrate,
                QueriesMap:    dictionaryQueries,
        }
        if err := engine.InitTable(ctx, db, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init dictionary storage: %w", err)
        }</span>
        <span class="cov5" title="36">return res, nil</span>
}

// Add adds a stop phrase or ignored word to the dictionary
func (d *Dictionary) Add(ctx context.Context, t DictionaryType, data string) error <span class="cov9" title="1048">{
        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return err
        }</span>
        <span class="cov9" title="1046">if data == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("data cannot be empty")
        }</span>

        <span class="cov9" title="1044">d.Lock()
        defer d.Unlock()

        // get the appropriate query for current db type
        query, err := dictionaryQueries.Pick(d.Type(), CmdAddDictionaryEntry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get insert query: %w", err)
        }</span>

        <span class="cov9" title="1044">if _, err = d.ExecContext(ctx, query, t, data, d.GID()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add data: %w", err)
        }</span>

        <span class="cov9" title="1044">return nil</span>
}

// Delete removes an entry from the dictionary by its ID
func (d *Dictionary) Delete(ctx context.Context, id int64) error <span class="cov2" title="4">{
        d.Lock()
        defer d.Unlock()

        result, err := d.ExecContext(ctx, d.Adopt(`DELETE FROM dictionary WHERE id = ?`), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove phrase: %w", err)
        }</span>

        <span class="cov2" title="4">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>
        <span class="cov2" title="4">if affected == 0 </span><span class="cov1" title="2">{
                return fmt.Errorf("phrase with id %d not found", id)
        }</span>
        <span class="cov1" title="2">return nil</span>
}

// Read reads all entries from the dictionary by type
func (d *Dictionary) Read(ctx context.Context, t DictionaryType) ([]string, error) <span class="cov9" title="1024">{
        d.RLock()
        defer d.RUnlock()

        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="1022">var data []string
        query := d.Adopt(`SELECT data FROM dictionary WHERE type = ? AND gid = ? ORDER BY timestamp`)
        if err := d.SelectContext(ctx, &amp;data, query, t, d.GID()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get data: %w", err)
        }</span>
        <span class="cov9" title="1022">return data, nil</span>
}

// Reader returns a reader for phrases by type
// lock is lacking deliberately because Read is already protected
func (d *Dictionary) Reader(ctx context.Context, t DictionaryType) (io.ReadCloser, error) <span class="cov3" title="8">{
        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov3" title="6">recs, err := d.Read(ctx, t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read phrases: %w", err)
        }</span>
        <span class="cov3" title="6">data := strings.Join(recs, "\n")
        return io.NopCloser(strings.NewReader(data)), nil</span>
}

// Iterator returns an iterator for phrases by type
func (d *Dictionary) Iterator(ctx context.Context, t DictionaryType) (iter.Seq[string], error) <span class="cov2" title="4">{
        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="2">query := d.Adopt(`SELECT data FROM dictionary WHERE type = ? AND gid = ? ORDER BY timestamp`)

        d.RLock()
        rows, err := d.QueryxContext(ctx, query, t, d.GID())
        d.RUnlock()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query phrases: %w", err)
        }</span>

        <span class="cov1" title="2">return func(yield func(string) bool) </span><span class="cov1" title="2">{
                defer rows.Close()
                for rows.Next() </span><span class="cov3" title="6">{
                        var phrase string
                        if err := rows.Scan(&amp;phrase); err != nil </span><span class="cov0" title="0">{
                                return // terminate iteration on scan error
                        }</span>
                        <span class="cov3" title="6">if !yield(phrase) </span><span class="cov0" title="0">{
                                return // stop iteration if `yield` returns false
                        }</span>
                }
        }, nil
}

// Import reads phrases from the reader and imports them into the storage.
// If withCleanup is true removes all entries with the same type before import.
// Input format is either a single phrase per line or a CSV file with multiple phrases.
// Import reads phrases from the reader and imports them into the storage.
func (d *Dictionary) Import(ctx context.Context, t DictionaryType, r io.Reader, withCleanup bool) (*DictionaryStats, error) <span class="cov3" title="12">{
        if err := t.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="12">if r == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reader cannot be nil")
        }</span>

        <span class="cov3" title="12">d.Lock()

        // start transaction
        tx, err := d.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                d.Unlock()
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov3" title="12">defer tx.Rollback()
        gid := d.GID()

        // remove all entries with the same type if requested
        if withCleanup </span><span class="cov3" title="10">{
                if _, err = tx.ExecContext(ctx, d.Adopt(`DELETE FROM dictionary WHERE type = ? AND gid = ?`), t, gid); err != nil </span><span class="cov0" title="0">{
                        d.Unlock()
                        return nil, fmt.Errorf("failed to remove old entries: %w", err)
                }</span>
        }

        // get the appropriate insert query for current db type
        <span class="cov3" title="12">query, err := dictionaryQueries.Pick(d.Type(), CmdImportDictionaryEntry)
        if err != nil </span><span class="cov0" title="0">{
                d.Unlock()
                return nil, fmt.Errorf("failed to get insert query: %w", err)
        }</span>

        // prepare statement for inserts
        <span class="cov3" title="12">insertStmt, err := tx.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                d.Unlock()
                return nil, fmt.Errorf("failed to prepare insert statement: %w", err)
        }</span>
        <span class="cov3" title="12">defer insertStmt.Close()

        // use csv reader to handle quoted strings and comma separation properly
        csvReader := csv.NewReader(r)
        csvReader.FieldsPerRecord = -1 // allow variable number of fields
        csvReader.TrimLeadingSpace = true

        for </span><span class="cov4" title="22">{
                record, csvErr := csvReader.Read()
                if csvErr == io.EOF </span><span class="cov3" title="10">{
                        break</span>
                }
                <span class="cov3" title="12">if csvErr != nil </span><span class="cov1" title="2">{
                        d.Unlock()
                        return nil, fmt.Errorf("error reading input: %w", csvErr)
                }</span>

                // process each field in the record
                <span class="cov3" title="10">for _, field := range record </span><span class="cov4" title="26">{
                        if field == "" </span><span class="cov0" title="0">{ // skip empty entries
                                continue</span>
                        }

                        <span class="cov4" title="26">if _, err = insertStmt.ExecContext(ctx, t, field, gid); err != nil </span><span class="cov0" title="0">{
                                d.Unlock()
                                return nil, fmt.Errorf("failed to add entry: %w", err)
                        }</span>
                }
        }

        <span class="cov3" title="10">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                d.Unlock()
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov3" title="10">d.Unlock() // release the lock before getting stats

        return d.Stats(ctx)</span>
}

// String implements Stringer interface
func (t DictionaryType) String() string <span class="cov3" title="9">{ return string(t) }</span>

// Validate checks if the dictionary type is valid
func (t DictionaryType) Validate() error <span class="cov10" title="2099">{
        switch t </span>{
        case DictionaryTypeStopPhrase, DictionaryTypeIgnoredWord:<span class="cov9" title="2090">
                return nil</span>
        }
        <span class="cov3" title="9">return fmt.Errorf("invalid dictionary type: %s", t)</span>
}

// DictionaryStats returns statistics about dictionary entries
type DictionaryStats struct {
        TotalStopPhrases  int `db:"stop_phrases_count"`
        TotalIgnoredWords int `db:"ignored_words_count"`
}

// String returns a string representation of the stats
func (d *DictionaryStats) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("stop phrases: %d, ignored words: %d", d.TotalStopPhrases, d.TotalIgnoredWords)
}</span>

// Stats returns statistics about dictionary entries for the given GID
func (d *Dictionary) Stats(ctx context.Context) (*DictionaryStats, error) <span class="cov4" title="14">{
        d.RLock()
        defer d.RUnlock()

        query := d.Adopt(`
        SELECT 
            COUNT(CASE WHEN type = ? THEN 1 END) as stop_phrases_count,
            COUNT(CASE WHEN type = ? THEN 1 END) as ignored_words_count
        FROM dictionary
        WHERE gid = ?`,
        )

        var stats DictionaryStats
        if err := d.GetContext(ctx, &amp;stats, query, DictionaryTypeStopPhrase, DictionaryTypeIgnoredWord, d.GID()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stats: %w", err)
        }</span>
        <span class="cov4" title="14">return &amp;stats, nil</span>
}

func (d *Dictionary) migrate(_ context.Context, _ *sqlx.Tx, _ string) error <span class="cov5" title="36">{
        // no migrations yet
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package engine

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/jmoiron/sqlx"
)

// Converter provides methods for database format conversion specifically for tg-spam tables.
// The primary purpose is to facilitate migration from SQLite to PostgreSQL with
// proper handling of each table's specific requirements and data types.
type Converter struct {
        db *SQL
}

// NewConverter creates a new converter for the given SQL engine
func NewConverter(db *SQL) *Converter <span class="cov5" title="11">{
        return &amp;Converter{db: db}
}</span>

// SqliteToPostgres converts a SQLite database to PostgreSQL format and writes it to the provided writer.
// It only converts the tables used by tg-spam: detected_spam, approved_users, samples, dictionary.
//
// The conversion process includes:
// 1. Converting table schemas with appropriate data type mappings
// 2. Converting boolean values from SQLite (0/1) to PostgreSQL (false/true)
// 3. Handling special cases like the message_hash column in samples table
// 4. Converting indices and constraints to PostgreSQL format
// 5. Exporting data using PostgreSQL's efficient COPY format
func (c *Converter) SqliteToPostgres(ctx context.Context, w io.Writer) error <span class="cov3" title="3">{
        // check if the database is SQLite
        if c.db.dbType != Sqlite </span><span class="cov1" title="1">{
                return fmt.Errorf("source database must be SQLite, got %s", c.db.dbType)
        }</span>

        // begin transaction to ensure consistent backup
        <span class="cov2" title="2">tx, err := c.db.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov2" title="2">defer tx.Rollback()

        // write header
        timestamp := time.Now().Format(time.RFC3339)
        header := fmt.Sprintf("-- SQLite to PostgreSQL export for tg-spam\n-- Generated: %s\n-- GID: %s\n\n", timestamp, c.db.gid)
        if _, writeErr := io.WriteString(w, header); writeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write header: %w", writeErr)
        }</span>

        // write start transaction
        <span class="cov2" title="2">if _, writeErr := io.WriteString(w, "BEGIN;\n\n"); writeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write transaction start: %w", writeErr)
        }</span>

        // define the tables specific to tg-spam that we want to convert
        <span class="cov2" title="2">tables := []string{"detected_spam", "approved_users", "samples", "dictionary"}

        // for each table, export schema and data if it exists
        for _, table := range tables </span><span class="cov4" title="8">{
                // check if table exists
                var count int
                query := "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?"
                if err := tx.GetContext(ctx, &amp;count, query, table); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if table %s exists: %w", table, err)
                }</span>

                <span class="cov4" title="8">if count == 0 </span><span class="cov0" title="0">{
                        // table doesn't exist, skip it
                        continue</span>
                }

                <span class="cov4" title="8">if err := c.convertTable(ctx, tx, w, table); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // write commit transaction
        <span class="cov2" title="2">if _, err := io.WriteString(w, "COMMIT;\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write transaction commit: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// convertTable exports a SQLite table in PostgreSQL format.
// This function handles the full conversion process for a single table:
// 1. Get and convert the table schema
// 2. Export the table data in PostgreSQL format
// 3. Convert and write the table's indices
func (c *Converter) convertTable(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov4" title="8">{
        // get table schema information
        var createStmt string
        query := fmt.Sprintf("SELECT sql FROM sqlite_master WHERE type='table' AND name='%s'", table)
        if err := tx.GetContext(ctx, &amp;createStmt, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get schema for table %s: %w", table, err)
        }</span>

        // convert SQLite schema to PostgreSQL schema
        <span class="cov4" title="8">pgCreateStmt := c.convertTableSchema(table, createStmt)

        // write converted schema
        if _, writeErr := fmt.Fprintf(w, "%s;\n\n", pgCreateStmt); writeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write schema: %w", writeErr)
        }</span>

        // get columns for the table
        <span class="cov4" title="8">columns, err := c.getTableColumns(ctx, tx, table)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get data and write as PostgreSQL COPY statements
        <span class="cov4" title="8">if err := c.exportTableData(ctx, tx, w, table, columns); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // convert and write indices
        <span class="cov4" title="8">if err := c.convertIndices(ctx, tx, w, table); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // write newline after table
        <span class="cov4" title="8">if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write newline: %w", err)
        }</span>

        <span class="cov4" title="8">return nil</span>
}

// convertTableSchema converts a SQLite CREATE TABLE statement to PostgreSQL syntax.
// It handles specific type mappings for each of the tg-spam tables.
// This function performs both general conversions applicable to all tables
// and table-specific conversions based on the schema requirements.
func (c *Converter) convertTableSchema(tableName, sqliteStmt string) string <span class="cov6" title="17">{
        pgStmt := sqliteStmt

        // common conversions applicable to all tables:
        // 1. SQLite autoincrement primary key to PostgreSQL serial
        pgStmt = strings.ReplaceAll(pgStmt, "INTEGER PRIMARY KEY AUTOINCREMENT", "SERIAL PRIMARY KEY")
        // 2. SQLite datetime to PostgreSQL timestamp
        pgStmt = strings.ReplaceAll(pgStmt, "DATETIME", "TIMESTAMP")
        // 3. SQLite blob to PostgreSQL bytea
        pgStmt = strings.ReplaceAll(pgStmt, "BLOB", "BYTEA")

        // table-specific conversions handle unique requirements for each table
        switch tableName </span>{
        case "detected_spam":<span class="cov3" title="4">
                // 1. user_id in detected_spam should be BIGINT to match PostgreSQL schema
                //    this is because Telegram user IDs can be very large numbers
                pgStmt = strings.ReplaceAll(pgStmt, "user_id INTEGER", "user_id BIGINT")

                // 2. Convert SQLite boolean (0) to PostgreSQL boolean (false)
                //    postgreSQL uses true/false values rather than 0/1
                pgStmt = strings.ReplaceAll(pgStmt, "added BOOLEAN DEFAULT 0", "added BOOLEAN DEFAULT false")</span>

        case "approved_users":<span class="cov2" title="2"></span>
                // approved_users table has a UNIQUE constraint on (gid, uid)
                // no specific conversions needed here because:
                // - The UNIQUE constraint syntax is identical in both SQLite and PostgreSQL
                // - All other type conversions are handled by the common conversions above

        case "samples":<span class="cov3" title="4">
                // the samples table requires special handling for message hashing in PostgreSQL.
                // in SQLite, we use the message text directly in the unique constraint.
                // in PostgreSQL, we create a stored computed hash column for better performance:
                if !strings.Contains(pgStmt, "message_hash") </span><span class="cov3" title="4">{
                        // 1. Add a generated column that computes a SHA256 hash of the message text
                        // 2. Change the unique constraint to use the hash instead of the full message text
                        pgStmt = strings.Replace(pgStmt, "UNIQUE(gid, message)",
                                "message_hash TEXT GENERATED ALWAYS AS (encode(sha256(message::bytea), 'hex')) STORED,\n            UNIQUE(gid, message_hash)", 1)
                }</span>

        case "dictionary":<span class="cov2" title="2"></span>
                // dictionary table has standard types and constraints
                // no specific conversions are needed beyond the common ones applied to all tables
        }

        // final conversion of boolean defaults for any boolean columns in all tables
        <span class="cov6" title="17">pgStmt = strings.ReplaceAll(pgStmt, "BOOLEAN DEFAULT 0", "BOOLEAN DEFAULT false")
        pgStmt = strings.ReplaceAll(pgStmt, "BOOLEAN DEFAULT 1", "BOOLEAN DEFAULT true")

        return pgStmt</span>
}

// getTableColumns returns the column names for a SQLite table.
// This is needed to properly map data during the export process.
func (c *Converter) getTableColumns(ctx context.Context, tx *sqlx.Tx, table string) ([]string, error) <span class="cov5" title="11">{
        var columns []string
        // use SQLite PRAGMA_TABLE_INFO to get column information
        query := "SELECT name FROM PRAGMA_TABLE_INFO(?)"
        if err := tx.SelectContext(ctx, &amp;columns, query, table); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns for table %s: %w", table, err)
        }</span>
        <span class="cov5" title="11">return columns, nil</span>
}

// exportTableData exports data from a SQLite table in PostgreSQL COPY format.
// The COPY format is much more efficient than individual INSERT statements
// for bulk loading data into PostgreSQL.
func (c *Converter) exportTableData(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string, columns []string) error <span class="cov5" title="10">{
        // get row count first to check if there's any data to export
        var count int
        if err := tx.GetContext(ctx, &amp;count, fmt.Sprintf("SELECT COUNT(*) FROM %s", table)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get row count: %w", err)
        }</span>

        <span class="cov5" title="10">if count == 0 </span><span class="cov1" title="1">{
                // no data to export, return early
                return nil
        }</span>

        // special handling for samples table - need to exclude message_hash column for COPY
        // because it's a generated column in PostgreSQL and shouldn't be included in the COPY command
        <span class="cov5" title="9">copyColumns := columns
        if table == "samples" &amp;&amp; len(columns) &gt; 0 </span><span class="cov2" title="2">{
                // remove message_hash column for PostgreSQL COPY as it's a generated column
                filteredColumns := make([]string, 0, len(columns))
                for _, col := range columns </span><span class="cov5" title="12">{
                        if col != "message_hash" </span><span class="cov5" title="12">{
                                filteredColumns = append(filteredColumns, col)
                        }</span>
                }
                <span class="cov2" title="2">copyColumns = filteredColumns</span>
        }

        // write COPY statement header with explanatory comment
        <span class="cov5" title="9">if _, err := fmt.Fprintf(w, "-- Data for table %s\n", table); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write comment: %w", err)
        }</span>

        // the COPY command specifies which table and columns to load data into
        <span class="cov5" title="9">if _, err := fmt.Fprintf(w, "COPY %s (%s) FROM stdin;\n", table, strings.Join(copyColumns, ", ")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write COPY header: %w", err)
        }</span>

        // query all data from the table
        <span class="cov5" title="9">query := fmt.Sprintf("SELECT * FROM %s", table)
        rows, err := tx.QueryxContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query data: %w", err)
        }</span>
        <span class="cov5" title="9">defer rows.Close()

        // write each row in PostgreSQL COPY format (tab-separated values)
        for rows.Next() </span><span class="cov6" title="22">{
                row := make(map[string]interface{})
                if err := rows.MapScan(row); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan row: %w", err)
                }</span>

                // format values for PostgreSQL
                <span class="cov6" title="22">values := make([]string, 0, len(copyColumns))
                for _, col := range copyColumns </span><span class="cov9" title="130">{
                        val, exists := row[col]
                        if !exists </span><span class="cov0" title="0">{
                                values = append(values, "\\N") // NULL in COPY format
                                continue</span>
                        }

                        // special handling for boolean values in specific tables/columns
                        <span class="cov9" title="130">if table == "detected_spam" &amp;&amp; col == "added" </span><span class="cov3" title="5">{
                                // convert SQLite 0/1 integer boolean to PostgreSQL f/t text boolean
                                if v, ok := val.(int64); ok </span><span class="cov3" title="5">{
                                        if v == 0 </span><span class="cov3" title="3">{
                                                values = append(values, "f")
                                        }</span> else<span class="cov2" title="2"> {
                                                values = append(values, "t")
                                        }</span>
                                        <span class="cov3" title="5">continue</span>
                                }
                        }

                        <span class="cov9" title="125">values = append(values, c.formatPostgresValue(val))</span>
                }

                // write row as tab-separated values
                <span class="cov6" title="22">if _, err := fmt.Fprintf(w, "%s\n", strings.Join(values, "\t")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write data row: %w", err)
                }</span>
        }

        <span class="cov5" title="9">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error iterating rows: %w", err)
        }</span>

        // end COPY statement with the special \. marker
        <span class="cov5" title="9">if _, err := io.WriteString(w, "\\.\n\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write COPY end: %w", err)
        }</span>

        <span class="cov5" title="9">return nil</span>
}

// convertIndices converts SQLite indices to PostgreSQL format.
// This extracts index definitions from SQLite and converts them to PostgreSQL syntax.
func (c *Converter) convertIndices(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov4" title="8">{
        // get all indices for the table that have SQL definitions
        var indices []struct {
                SQL string `db:"sql"`
        }
        query := fmt.Sprintf("SELECT sql FROM sqlite_master WHERE type='index' AND tbl_name='%s' AND sql IS NOT NULL", table)
        if err := tx.SelectContext(ctx, &amp;indices, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get indices: %w", err)
        }</span>

        // convert and write each index
        <span class="cov4" title="8">for _, idx := range indices </span><span class="cov4" title="8">{
                // convert SQLite index to PostgreSQL syntax
                pgIndex := c.convertIndexDefinition(table, idx.SQL)

                // write the converted index definition
                if _, err := fmt.Fprintf(w, "%s;\n", pgIndex); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write index: %w", err)
                }</span>
        }

        <span class="cov4" title="8">return nil</span>
}

// convertIndexDefinition converts a SQLite CREATE INDEX statement to PostgreSQL syntax.
// This includes handling special cases for the samples table where we use message_hash instead of message.
func (c *Converter) convertIndexDefinition(tableName, sqliteStmt string) string <span class="cov6" title="17">{
        // start with basic conversion - most syntax is compatible
        pgStmt := sqliteStmt

        // postgreSQL &lt; 9.5 doesn't support IF NOT EXISTS in index creation
        // remove it to ensure compatibility with all PostgreSQL versions
        pgStmt = strings.ReplaceAll(pgStmt, "IF NOT EXISTS", "")

        // special handling for samples table indices that reference the message column
        if tableName == "samples" </span><span class="cov4" title="8">{
                // we need to update any index that references the message column to use message_hash instead
                if strings.Contains(pgStmt, "ON samples(") </span><span class="cov4" title="8">{
                        // extract the index column list between parentheses
                        start := strings.Index(pgStmt, "ON samples(") + len("ON samples(")
                        end := strings.Index(pgStmt[start:], ")") + start
                        indexCols := pgStmt[start:end]

                        // process each column in the index, replacing "message" with "message_hash"
                        parts := strings.Split(indexCols, ",")
                        for i, part := range parts </span><span class="cov5" title="14">{
                                trimmed := strings.TrimSpace(part)
                                if trimmed == "message" </span><span class="cov4" title="7">{
                                        parts[i] = strings.Replace(part, "message", "message_hash", 1)
                                }</span>
                        }

                        // join the modified columns back together and reconstruct the statement
                        <span class="cov4" title="8">newIndexCols := strings.Join(parts, ",")
                        pgStmt = pgStmt[:start] + newIndexCols + pgStmt[end:]</span>
                }
        }

        <span class="cov6" title="17">return pgStmt</span>
}

// formatPostgresValue formats a value for PostgreSQL COPY format.
// PostgreSQL COPY format requires special handling for NULL values and character escaping.
func (c *Converter) formatPostgresValue(value interface{}) string <span class="cov10" title="135">{
        switch v := value.(type) </span>{
        case nil:<span class="cov2" title="2">
                return "\\N"</span> // postgreSQL COPY format for NULL

        case []byte:<span class="cov1" title="1">
                // handle binary data by converting to string and escaping special characters
                s := string(v)
                // postgreSQL COPY format requires escaping backslashes and tab/newline/return chars
                s = strings.ReplaceAll(s, "\\", "\\\\") // escape backslashes
                s = strings.ReplaceAll(s, "\t", "\\t")  // escape tabs (column separator in COPY)
                s = strings.ReplaceAll(s, "\n", "\\n")  // escape newlines (row separator in COPY)
                s = strings.ReplaceAll(s, "\r", "\\r")  // escape carriage returns
                return s</span>

        case string:<span class="cov9" title="79">
                // handle string data by escaping special characters
                s := v
                s = strings.ReplaceAll(s, "\\", "\\\\") // escape backslashes
                s = strings.ReplaceAll(s, "\t", "\\t")  // escape tabs (column separator in COPY)
                s = strings.ReplaceAll(s, "\n", "\\n")  // escape newlines (row separator in COPY)
                s = strings.ReplaceAll(s, "\r", "\\r")  // escape carriage returns
                return s</span>

        case time.Time:<span class="cov6" title="22">
                // format timestamps in PostgreSQL standard format
                return v.Format("2006-01-02 15:04:05")</span>

        case bool:<span class="cov2" title="2">
                // format booleans as 't' or 'f' as required by PostgreSQL
                if v </span><span class="cov1" title="1">{
                        return "t"
                }</span>
                <span class="cov1" title="1">return "f"</span>

        default:<span class="cov7" title="29">
                // for all other types, use standard string conversion
                return fmt.Sprintf("%v", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package engine

import (
        "context"
        "fmt"
        "io"
        "log"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"  // postgres driver loaded here
        _ "modernc.org/sqlite" // sqlite driver loaded here
)

// Type is a type of database engine
type Type string

// enum of supported database engines
const (
        Unknown  Type = ""
        Sqlite   Type = "sqlite"
        Postgres Type = "postgres"
        Mysql    Type = "mysql"
)

// SQL is a wrapper for sqlx.DB with type.
// Type allows distinguishing between different database engines.
type SQL struct {
        sqlx.DB
        gid    string // group id, to allow per-group storage in the same database
        dbType Type   // type of the database engine
}

// New creates a new database engine with a connection URL and group id.
// It detects the database engine type based on the connection URL and initializes
// the appropriate driver. Supports sqlite and postgres database types.
func New(ctx context.Context, connURL, gid string) (*SQL, error) <span class="cov4" title="9">{
        log.Printf("[INFO] new database engine, conn: %s, gid: %s", connURL, gid)
        if connURL == "" </span><span class="cov1" title="1">{
                return &amp;SQL{}, fmt.Errorf("connection URL is empty")
        }</span>

        <span class="cov4" title="8">switch </span>{
        case connURL == ":memory:":<span class="cov1" title="1">
                return NewSqlite(connURL, gid)</span>
        case strings.HasPrefix(connURL, "file://"):<span class="cov1" title="1">
                return NewSqlite(strings.TrimPrefix(connURL, "file://"), gid)</span>
        case strings.HasPrefix(connURL, "file:"):<span class="cov1" title="1">
                return NewSqlite(strings.TrimPrefix(connURL, "file:"), gid)</span>
        case strings.HasPrefix(connURL, "sqlite://"):<span class="cov1" title="1">
                return NewSqlite(strings.TrimPrefix(connURL, "sqlite://"), gid)</span>
        case strings.HasSuffix(connURL, ".sqlite") || strings.HasSuffix(connURL, ".db"):<span class="cov2" title="2">
                return NewSqlite(connURL, gid)</span>
        case strings.HasPrefix(connURL, "postgres://"):<span class="cov1" title="1">
                return NewPostgres(ctx, connURL, gid)</span>
        }

        <span class="cov1" title="1">return &amp;SQL{}, fmt.Errorf("unsupported database type in connection string %q", connURL)</span>
}

// NewSqlite creates a new sqlite database
func NewSqlite(file, gid string) (*SQL, error) <span class="cov6" title="19">{
        db, err := sqlx.Connect("sqlite", file)
        if err != nil </span><span class="cov1" title="1">{
                return &amp;SQL{}, fmt.Errorf("failed to connect to sqlite: %w", err)
        }</span>
        <span class="cov5" title="18">if err := setSqlitePragma(db); err != nil </span><span class="cov0" title="0">{
                return &amp;SQL{}, err
        }</span>
        <span class="cov5" title="18">return &amp;SQL{DB: *db, gid: gid, dbType: Sqlite}, nil</span>
}

// NewPostgres creates a new postgres database. If the database doesn't exist, it will be created
func NewPostgres(ctx context.Context, connURL, gid string) (*SQL, error) <span class="cov4" title="6">{
        u, err := url.Parse(connURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid postgres connection url: %w", err)
        }</span>

        <span class="cov3" title="5">dbName := strings.TrimPrefix(u.Path, "/")
        if dbName == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("database name not specified in connection URL")
        }</span>

        // try to connect first - database might exist
        <span class="cov3" title="4">db, err := sqlx.ConnectContext(ctx, "postgres", connURL)
        if err == nil </span><span class="cov2" title="2">{
                return &amp;SQL{DB: *db, gid: gid, dbType: Postgres}, nil
        }</span>

        // create URL for postgres database
        <span class="cov2" title="2">u.Path = "/postgres"
        baseURL := u.String()

        // connect to default postgres database
        baseDB, err := sqlx.ConnectContext(ctx, "postgres", baseURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to connect to postgres: %w", err)
        }</span>
        <span class="cov1" title="1">defer baseDB.Close()

        // create database
        _, err = baseDB.ExecContext(ctx, fmt.Sprintf(`CREATE DATABASE %q`, dbName))
        if err != nil </span><span class="cov0" title="0">{
                // ignore error if database already exists
                if !strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create database: %w", err)
                }</span>
        }
        <span class="cov1" title="1">log.Printf("[INFO] created database %s", dbName)

        // connect to the new database
        db, err = sqlx.ConnectContext(ctx, "postgres", connURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to created database: %w", err)
        }</span>
        <span class="cov1" title="1">return &amp;SQL{DB: *db, gid: gid, dbType: Postgres}, nil</span>
}

// GID returns the group id
func (e *SQL) GID() string <span class="cov4" title="10">{
        return e.gid
}</span>

// Type returns the database engine type
func (e *SQL) Type() Type <span class="cov5" title="12">{
        return e.dbType
}</span>

// SetDBType sets the database engine type (used for testing)
func (e *SQL) SetDBType(dbType Type) <span class="cov0" title="0">{
        e.dbType = dbType
}</span>

// MakeLock creates a new lock for the database engine
func (e *SQL) MakeLock() RWLocker <span class="cov2" title="3">{
        if e.dbType == Sqlite </span><span class="cov2" title="2">{
                return new(sync.RWMutex) // sqlite need locking
        }</span>
        <span class="cov1" title="1">return &amp;NoopLocker{}</span> // other engines don't need locking
}

// Backup creates a database backup and writes it to the provided writer.
// For SQLite, it backs up all tables.
// For PostgreSQL, it backs up data with the current GID where applicable.
func (e *SQL) Backup(ctx context.Context, w io.Writer) error <span class="cov2" title="2">{
        switch e.dbType </span>{
        case Sqlite:<span class="cov1" title="1">
                return e.backupSqlite(ctx, w)</span>
        case Postgres:<span class="cov1" title="1">
                return e.backupPostgres(ctx, w)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("backup not supported for database type: %s", e.dbType)</span>
        }
}

// BackupSqliteAsPostgres creates a PostgreSQL-compatible backup from a SQLite database
// and writes it to the provided writer.
func (e *SQL) BackupSqliteAsPostgres(ctx context.Context, w io.Writer) error <span class="cov0" title="0">{
        converter := NewConverter(e)
        return converter.SqliteToPostgres(ctx, w)
}</span>

// Adopt adopts placeholders in a query for the database engine
// This is for query which compatible between sqlite and postgres except for the placeholders
func (e *SQL) Adopt(q string) string <span class="cov4" title="9">{
        if e.dbType != Postgres </span><span class="cov2" title="3">{ // no need to replace placeholders for sqlite
                return q
        }</span>

        <span class="cov4" title="6">placeholderCount := 1
        result := ""
        inQuotes := false

        for _, r := range q </span><span class="cov10" title="193">{
                switch r </span>{
                case '\'':<span class="cov2" title="2">
                        inQuotes = !inQuotes
                        result += string(r)</span>
                case '?':<span class="cov4" title="8">
                        if inQuotes </span><span class="cov1" title="1">{
                                result += string(r)
                        }</span> else<span class="cov4" title="7"> {
                                result += fmt.Sprintf("$%d", placeholderCount)
                                placeholderCount++
                        }</span>
                default:<span class="cov9" title="183">
                        result += string(r)</span>
                }
        }

        <span class="cov4" title="6">return result</span>
}

func setSqlitePragma(db *sqlx.DB) error <span class="cov5" title="18">{
        // set pragmas for SQLite. Commented out pragmas as they are not used in the code yet because we need
        // to make sure if it is worth having 2 more DB-related files for WAL and SHM.
        pragmas := map[string]string{
                "journal_mode": "DELETE", // explicitly set to DELETE mode to prevent WAL files
                // "journal_mode": "WAL",
                // "synchronous":  "NORMAL",
                // "busy_timeout": "5000",
                // "foreign_keys": "ON",
        }

        // set pragma
        for name, value := range pragmas </span><span class="cov5" title="18">{
                if _, err := db.Exec("PRAGMA " + name + " = " + value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set pragma %s=%s: %w", name, value, err)
                }</span>
        }
        <span class="cov5" title="18">return nil</span>
}

// backupSqlite performs a backup of the SQLite database and writes the SQL statements
// to create and populate the database to the provided writer.
func (e *SQL) backupSqlite(ctx context.Context, w io.Writer) error <span class="cov1" title="1">{
        // begin transaction to ensure consistent backup
        tx, err := e.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov1" title="1">defer tx.Rollback()

        // write header
        if headerErr := e.writeSqliteHeader(w); headerErr != nil </span><span class="cov0" title="0">{
                return headerErr
        }</span>

        // get list of all tables
        <span class="cov1" title="1">tables, err := e.getSqliteTables(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // for each table, export schema and data
        <span class="cov1" title="1">for _, table := range tables </span><span class="cov1" title="1">{
                if tableErr := e.backupSqliteTable(ctx, tx, w, table); tableErr != nil </span><span class="cov0" title="0">{
                        return tableErr
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// writeSqliteHeader writes the SQLite backup header to the writer
func (e *SQL) writeSqliteHeader(w io.Writer) error <span class="cov1" title="1">{
        timestamp := time.Now().Format(time.RFC3339)
        header := fmt.Sprintf("-- SQLite database backup\n-- Generated: %s\n-- GID: %s\n\n", timestamp, e.gid)
        if _, err := io.WriteString(w, header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write header: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// getSqliteTables returns a list of all user tables in the SQLite database
func (e *SQL) getSqliteTables(ctx context.Context, tx *sqlx.Tx) ([]string, error) <span class="cov1" title="1">{
        var tables []string
        query := "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'"
        if err := tx.SelectContext(ctx, &amp;tables, query); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tables: %w", err)
        }</span>
        <span class="cov1" title="1">return tables, nil</span>
}

// backupSqliteTable handles the backup of a single SQLite table
func (e *SQL) backupSqliteTable(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov1" title="1">{
        // write table schema
        if err := e.writeSqliteTableSchema(ctx, tx, w, table); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // write indices
        <span class="cov1" title="1">if err := e.writeSqliteTableIndices(ctx, tx, w, table); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // write newline after indices
        <span class="cov1" title="1">if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write newline: %w", err)
        }</span>

        // write table data
        <span class="cov1" title="1">columns, err := e.getSqliteColumns(ctx, tx, table)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if err := e.writeSqliteTableData(ctx, tx, w, table, columns); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // add newline after table data
        <span class="cov1" title="1">if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write newline: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// writeSqliteTableSchema writes the CREATE TABLE statement for a SQLite table
func (e *SQL) writeSqliteTableSchema(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov1" title="1">{
        var createStmt string
        query := fmt.Sprintf("SELECT sql FROM sqlite_master WHERE type='table' AND name='%s'", table)
        if err := tx.GetContext(ctx, &amp;createStmt, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get schema for table %s: %w", table, err)
        }</span>

        <span class="cov1" title="1">if _, err := fmt.Fprintf(w, "%s;\n\n", createStmt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write schema for table %s: %w", table, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// writeSqliteTableIndices writes the CREATE INDEX statements for a SQLite table
func (e *SQL) writeSqliteTableIndices(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov1" title="1">{
        var indices []struct {
                SQL string `db:"sql"`
        }
        query := fmt.Sprintf("SELECT sql FROM sqlite_master WHERE type='index' AND tbl_name='%s' AND sql IS NOT NULL", table)
        if err := tx.SelectContext(ctx, &amp;indices, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get indices for table %s: %w", table, err)
        }</span>

        <span class="cov1" title="1">for _, idx := range indices </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(w, "%s;\n", idx.SQL); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write index: %w", err)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// getSqliteColumns returns the column names for a SQLite table
func (e *SQL) getSqliteColumns(ctx context.Context, tx *sqlx.Tx, table string) ([]string, error) <span class="cov1" title="1">{
        var columns []string
        query := "SELECT name FROM PRAGMA_TABLE_INFO(?)"
        if err := tx.SelectContext(ctx, &amp;columns, query, table); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns for table %s: %w", table, err)
        }</span>
        <span class="cov1" title="1">return columns, nil</span>
}

// writeSqliteTableData writes the data for a SQLite table as INSERT statements
func (e *SQL) writeSqliteTableData(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string, columns []string) error <span class="cov1" title="1">{
        // get data from the table
        query := fmt.Sprintf("SELECT * FROM %s", table)
        rows, err := tx.QueryxContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query data from table %s: %w", table, err)
        }</span>

        // close rows when done - not using defer in the loop
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                closeErr := rows.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to close rows: %v", closeErr)
                }</span>
        }()

        // write INSERT statements for each row
        <span class="cov1" title="1">for rows.Next() </span><span class="cov2" title="2">{
                if writeErr := e.writeSqliteRow(w, rows, table, columns); writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
        }

        <span class="cov1" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// writeSqliteRow writes a single row as an INSERT statement
func (e *SQL) writeSqliteRow(w io.Writer, rows *sqlx.Rows, table string, columns []string) error <span class="cov2" title="2">{
        row := make(map[string]interface{})
        if err := rows.MapScan(row); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan row: %w", err)
        }</span>

        // build column names and values for INSERT statement
        // pre-allocate to avoid reallocation
        <span class="cov2" title="2">cols := make([]string, 0, len(columns))
        vals := make([]string, 0, len(columns))

        for _, col := range columns </span><span class="cov4" title="10">{
                // only include columns that are in the row
                value, ok := row[col]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="10">cols = append(cols, col)
                vals = append(vals, e.formatSqliteValue(value))</span>
        }

        <span class="cov2" title="2">insertStmt := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);",
                table, strings.Join(cols, ", "), strings.Join(vals, ", "))

        if _, err := fmt.Fprintln(w, insertStmt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write insert statement: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// formatSqliteValue formats a value for SQLite INSERT statement
func (e *SQL) formatSqliteValue(value interface{}) string <span class="cov4" title="10">{
        switch v := value.(type) </span>{
        case nil:<span class="cov0" title="0">
                return "NULL"</span>
        case int, int64, float64:<span class="cov2" title="2">
                return fmt.Sprintf("%v", v)</span>
        case []byte:<span class="cov0" title="0">
                return fmt.Sprintf("'%s'", strings.ReplaceAll(string(v), "'", "''"))</span>
        case string:<span class="cov4" title="6">
                return fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))</span>
        case time.Time:<span class="cov2" title="2">
                return fmt.Sprintf("'%s'", v.Format("2006-01-02 15:04:05"))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("'%v'", v)</span>
        }
}

// backupPostgres performs a backup of the PostgreSQL database and writes SQL statements
// to recreate the data to the provided writer. It filters data by the current gid.
func (e *SQL) backupPostgres(ctx context.Context, w io.Writer) error <span class="cov1" title="1">{
        // begin transaction to ensure consistent backup
        tx, err := e.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov1" title="1">defer tx.Rollback()

        // write header and transaction start
        if headerErr := e.writePostgresHeader(ctx, tx, w); headerErr != nil </span><span class="cov0" title="0">{
                return headerErr
        }</span>

        // get list of all tables
        <span class="cov1" title="1">tables, err := e.getPostgresTables(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // for each table, export schema and data
        <span class="cov1" title="1">for _, table := range tables </span><span class="cov1" title="1">{
                if tableErr := e.backupPostgresTable(ctx, tx, w, table); tableErr != nil </span><span class="cov0" title="0">{
                        return tableErr
                }</span>
        }

        // write commit transaction
        <span class="cov1" title="1">if _, writeErr := io.WriteString(w, "COMMIT;\n"); writeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write transaction commit: %w", writeErr)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// writePostgresHeader writes the PostgreSQL backup header information
func (e *SQL) writePostgresHeader(ctx context.Context, tx *sqlx.Tx, w io.Writer) error <span class="cov1" title="1">{
        // write header with backup information
        timestamp := time.Now().Format(time.RFC3339)
        header := fmt.Sprintf("-- PostgreSQL database backup\n-- Generated: %s\n-- GID: %s\n\n", timestamp, e.gid)
        if _, err := io.WriteString(w, header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write header: %w", err)
        }</span>

        // check if database is PostgreSQL
        <span class="cov1" title="1">var version string
        if err := tx.GetContext(ctx, &amp;version, "SELECT version()"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get PostgreSQL version: %w", err)
        }</span>
        <span class="cov1" title="1">if _, err := fmt.Fprintf(w, "-- PostgreSQL Version: %s\n\n", version); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write version: %w", err)
        }</span>

        // write start transaction
        <span class="cov1" title="1">if _, err := io.WriteString(w, "BEGIN;\n\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write transaction start: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// getPostgresTables returns a list of all user tables in the PostgreSQL database
func (e *SQL) getPostgresTables(ctx context.Context, tx *sqlx.Tx) ([]string, error) <span class="cov1" title="1">{
        var tables []string
        query := `
                SELECT tablename 
                FROM pg_catalog.pg_tables 
                WHERE schemaname != 'pg_catalog' 
                AND schemaname != 'information_schema'
        `
        if err := tx.SelectContext(ctx, &amp;tables, query); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tables: %w", err)
        }</span>
        <span class="cov1" title="1">return tables, nil</span>
}

// backupPostgresTable handles the backup of a single PostgreSQL table
func (e *SQL) backupPostgresTable(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov1" title="1">{
        // write table schema
        if err := e.writePostgresTableSchema(ctx, tx, w, table); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check if table has gid column and get columns
        <span class="cov1" title="1">hasGID, columns, err := e.getPostgresTableInfo(ctx, tx, table)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // write table data
        <span class="cov1" title="1">if err := e.writePostgresTableData(ctx, tx, w, table, columns, hasGID); err != nil </span><span class="cov0" title="0">{
                // skip table data if there are no rows
                if !strings.Contains(err.Error(), "no rows in result set") </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // write indices
        <span class="cov1" title="1">if err := e.writePostgresTableIndices(ctx, tx, w, table); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// writePostgresTableSchema writes the CREATE TABLE statement for a PostgreSQL table
func (e *SQL) writePostgresTableSchema(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov1" title="1">{
        var createStmt string
        query := fmt.Sprintf(`
                SELECT 
                        'CREATE TABLE ' || table_name || ' (' ||
                        array_to_string(
                                array_agg(
                                        column_name || ' ' || 
                                        data_type || 
                                        CASE 
                                                WHEN character_maximum_length IS NOT NULL THEN '(' || character_maximum_length || ')'
                                                ELSE ''
                                        END ||
                                        CASE 
                                                WHEN is_nullable = 'NO' THEN ' NOT NULL'
                                                ELSE ''
                                        END
                                ), ', '
                        ) || ');' as create_statement
                FROM information_schema.columns
                WHERE table_name = '%s'
                GROUP BY table_name
        `, table)
        if err := tx.GetContext(ctx, &amp;createStmt, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get schema for table %s: %w", table, err)
        }</span>

        // write create table statement
        <span class="cov1" title="1">if _, err := fmt.Fprintf(w, "%s\n\n", createStmt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write schema for table %s: %w", table, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// getPostgresTableInfo gets column information and checks if the table has a GID column
func (e *SQL) getPostgresTableInfo(ctx context.Context, tx *sqlx.Tx, table string) (hasGID bool, coumns []string, err error) <span class="cov1" title="1">{
        // check if the table has a GID column
        query := `
                SELECT EXISTS (
                        SELECT 1
                        FROM information_schema.columns
                        WHERE table_name = $1
                        AND column_name = 'gid'
                )
        `
        if err := tx.GetContext(ctx, &amp;hasGID, query, table); err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to check if table %s has gid column: %w", table, err)
        }</span>

        // get table columns
        <span class="cov1" title="1">var columns []string
        query = `
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = $1
                ORDER BY ordinal_position
        `
        if err := tx.SelectContext(ctx, &amp;columns, query, table); err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get columns for table %s: %w", table, err)
        }</span>

        <span class="cov1" title="1">return hasGID, columns, nil</span>
}

// writePostgresTableData writes the data rows for a PostgreSQL table
func (e *SQL) writePostgresTableData(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string, columns []string, hasGID bool) error <span class="cov1" title="1">{
        // build query to get data
        dataQuery := fmt.Sprintf("SELECT * FROM %s", table)
        if hasGID </span><span class="cov1" title="1">{
                dataQuery = fmt.Sprintf("SELECT * FROM %s WHERE gid = $1", table)
        }</span>

        // check if there are any rows first
        <span class="cov1" title="1">var count int
        countQuery := fmt.Sprintf("SELECT COUNT(*) FROM (%s) as subq", dataQuery)
        var err error
        if hasGID </span><span class="cov1" title="1">{
                err = tx.GetContext(ctx, &amp;count, countQuery, e.gid)
        }</span> else<span class="cov0" title="0"> {
                err = tx.GetContext(ctx, &amp;count, countQuery)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check row count for table %s: %w", table, err)
        }</span>

        <span class="cov1" title="1">if count == 0 </span><span class="cov0" title="0">{
                // skip if no data
                return nil
        }</span>

        // write data comment
        <span class="cov1" title="1">if _, commentErr := fmt.Fprintf(w, "-- Data for table %s\n", table); commentErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write comment: %w", commentErr)
        }</span>

        // start COPY statement
        <span class="cov1" title="1">if _, copyErr := fmt.Fprintf(w, "COPY %s (%s) FROM stdin;\n",
                table, strings.Join(columns, ", ")); copyErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write COPY statement: %w", copyErr)
        }</span>

        // execute query to get rows
        <span class="cov1" title="1">var rows *sqlx.Rows
        if hasGID </span><span class="cov1" title="1">{
                rows, err = tx.QueryxContext(ctx, dataQuery, e.gid)
        }</span> else<span class="cov0" title="0"> {
                rows, err = tx.QueryxContext(ctx, dataQuery)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query data from table %s: %w", table, err)
        }</span>

        // important: use a function to properly close rows at the end
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                closeErr := rows.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to close rows: %v", closeErr)
                }</span>
        }()

        // process rows
        <span class="cov1" title="1">for rows.Next() </span><span class="cov2" title="2">{
                if writeErr := e.writePostgresRow(w, rows, columns); writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
        }

        <span class="cov1" title="1">if rowErr := rows.Err(); rowErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error iterating rows: %w", rowErr)
        }</span>

        // end COPY statement
        <span class="cov1" title="1">if _, err := io.WriteString(w, "\\.\n\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write COPY end: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// writePostgresRow formats and writes a single row in PostgreSQL COPY format
func (e *SQL) writePostgresRow(w io.Writer, rows *sqlx.Rows, columns []string) error <span class="cov2" title="2">{
        row := make(map[string]interface{})
        if err := rows.MapScan(row); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan row: %w", err)
        }</span>

        // pre-allocate to avoid reallocation
        <span class="cov2" title="2">values := make([]string, 0, len(columns))
        for _, col := range columns </span><span class="cov4" title="10">{
                val, ok := row[col]
                if !ok </span><span class="cov0" title="0">{
                        values = append(values, "\\N") // NULL in COPY format
                        continue</span>
                }
                <span class="cov4" title="10">values = append(values, e.formatPostgresValue(val))</span>
        }

        <span class="cov2" title="2">if _, err := fmt.Fprintf(w, "%s\n", strings.Join(values, "\t")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write data row: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// formatPostgresValue formats a value for PostgreSQL COPY format
func (e *SQL) formatPostgresValue(value interface{}) string <span class="cov4" title="10">{
        switch v := value.(type) </span>{
        case nil:<span class="cov0" title="0">
                return "\\N"</span>
        case []byte:<span class="cov0" title="0">
                // escape special characters in COPY format
                s := string(v)
                s = strings.ReplaceAll(s, "\\", "\\\\")
                s = strings.ReplaceAll(s, "\t", "\\t")
                s = strings.ReplaceAll(s, "\n", "\\n")
                s = strings.ReplaceAll(s, "\r", "\\r")
                return s</span>
        case string:<span class="cov4" title="6">
                s := v
                s = strings.ReplaceAll(s, "\\", "\\\\")
                s = strings.ReplaceAll(s, "\t", "\\t")
                s = strings.ReplaceAll(s, "\n", "\\n")
                s = strings.ReplaceAll(s, "\r", "\\r")
                return s</span>
        case time.Time:<span class="cov2" title="2">
                return v.Format("2006-01-02 15:04:05")</span>
        default:<span class="cov2" title="2">
                return fmt.Sprintf("%v", v)</span>
        }
}

// writePostgresTableIndices writes the index definitions for a PostgreSQL table
func (e *SQL) writePostgresTableIndices(ctx context.Context, tx *sqlx.Tx, w io.Writer, table string) error <span class="cov1" title="1">{
        var indices []struct {
                Name       string `db:"indexname"`
                Definition string `db:"indexdef"`
        }
        query := `
                SELECT indexname, indexdef
                FROM pg_indexes
                WHERE tablename = $1
                AND indexname NOT LIKE '%_pkey'
        `
        if err := tx.SelectContext(ctx, &amp;indices, query, table); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get indices for table %s: %w", table, err)
        }</span>

        <span class="cov1" title="1">for _, idx := range indices </span><span class="cov1" title="1">{
                if _, err := fmt.Fprintf(w, "%s;\n", idx.Definition); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write index: %w", err)
                }</span>
        }

        <span class="cov1" title="1">if len(indices) &gt; 0 </span><span class="cov1" title="1">{
                if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write newline: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// TableConfig represents configuration for table initialization
type TableConfig struct {
        Name          string
        CreateTable   DBCmd
        CreateIndexes DBCmd
        MigrateFunc   func(ctx context.Context, tx *sqlx.Tx, gid string) error
        QueriesMap    *QueryMap
}

// InitTable initializes database table with schema and handles migration in a transaction
func InitTable(ctx context.Context, db *SQL, cfg TableConfig) error <span class="cov3" title="4">{
        if db == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("db connection is nil")
        }</span>

        <span class="cov2" title="3">tx, err := db.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov2" title="3">defer tx.Rollback()

        // create table first
        createSchema, err := cfg.QueriesMap.Pick(db.Type(), cfg.CreateTable)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get create table query: %w", err)
        }</span>
        <span class="cov2" title="2">if _, err = tx.ExecContext(ctx, createSchema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create schema: %w", err)
        }</span>

        // try to migrate if needed
        <span class="cov2" title="2">if err = cfg.MigrateFunc(ctx, tx, db.GID()); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to migrate table: %w", err)
        }</span>

        // create indices after migration when all columns exist
        <span class="cov1" title="1">createIndexes, err := cfg.QueriesMap.Pick(db.Type(), cfg.CreateIndexes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get create indexes query: %w", err)
        }</span>
        <span class="cov1" title="1">if _, err = tx.ExecContext(ctx, createIndexes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create indexes: %w", err)
        }</span>

        <span class="cov1" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package engine

import "sync"

// RWLocker is a read-write locker interface
type RWLocker interface {
        sync.Locker
        RLock()
        RUnlock()
}

// NoopLocker is a no-op locker
type NoopLocker struct{}

// Lock is a no-op
func (NoopLocker) Lock() {<span class="cov8" title="1">}</span>

// Unlock is a no-op
func (NoopLocker) Unlock() {<span class="cov8" title="1">}</span>

// RLock is a no-op
func (NoopLocker) RLock() {<span class="cov8" title="1">}</span>

// RUnlock is a no-op
func (NoopLocker) RUnlock() {<span class="cov8" title="1">}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package engine

import "fmt"

// DBCmd represents a database command type
type DBCmd int

// Query represents a SQL query with dialect-specific variants
type Query struct {
        Sqlite   string
        Postgres string
}

// QueryMap represents mapping between commands and their SQL queries
type QueryMap struct {
        queries map[DBCmd]Query
}

// NewQueryMap creates a new QueryMap
func NewQueryMap() *QueryMap <span class="cov7" title="6">{
        return &amp;QueryMap{queries: make(map[DBCmd]Query)}
}</span>

// Add adds queries for a command with dialect-specific versions
func (q *QueryMap) Add(cmd DBCmd, query Query) *QueryMap <span class="cov9" title="11">{
        q.queries[cmd] = query
        return q
}</span>

// AddSame adds the same query for all dialects
func (q *QueryMap) AddSame(cmd DBCmd, query string) *QueryMap <span class="cov5" title="4">{
        return q.Add(cmd, Query{Sqlite: query, Postgres: query})
}</span>

// Pick returns a query for given db type and command
func (q *QueryMap) Pick(dbType Type, cmd DBCmd) (string, error) <span class="cov10" title="14">{
        query, ok := q.queries[cmd]
        if !ok </span><span class="cov3" title="2">{
                return "", fmt.Errorf("unsupported command type %d", cmd)
        }</span>

        <span class="cov9" title="12">switch dbType </span>{
        case Sqlite:<span class="cov8" title="8">
                return query.Sqlite, nil</span>
        case Postgres:<span class="cov4" title="3">
                return query.Postgres, nil</span>
        default:<span class="cov1" title="1">
                return "", fmt.Errorf("unsupported database type %q", dbType)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package storage

import (
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/jmoiron/sqlx"
        _ "modernc.org/sqlite" // sqlite driver loaded here

        "github.com/umputun/tg-spam/app/storage/engine"
        "github.com/umputun/tg-spam/lib/spamcheck"
)

// locator-related command constants
const (
        CmdCreateLocatorTables engine.DBCmd = iota + 400
        CmdCreateLocatorIndexes
        CmdAddGIDColumnMessages
        CmdAddGIDColumnSpam
        CmdAddLocatorMessage
        CmdAddLocatorSpam
)

// locatorQueries holds all locator-related queries
var locatorQueries = engine.NewQueryMap().
        Add(CmdCreateLocatorTables, engine.Query{
                Sqlite: `CREATE TABLE IF NOT EXISTS messages (
            hash TEXT PRIMARY KEY,
            gid TEXT NOT NULL DEFAULT '',
            time TIMESTAMP,
            chat_id INTEGER,
            user_id INTEGER,
            user_name TEXT,
            msg_id INTEGER
        );
        CREATE TABLE IF NOT EXISTS spam (
            user_id INTEGER PRIMARY KEY,
            gid TEXT NOT NULL DEFAULT '',
            time TIMESTAMP,
            checks TEXT
        )`,
                Postgres: `CREATE TABLE IF NOT EXISTS messages (
            hash TEXT PRIMARY KEY,
            gid TEXT NOT NULL DEFAULT '',
            time TIMESTAMP,
            chat_id BIGINT,
            user_id BIGINT,
            user_name TEXT,
            msg_id INTEGER
        );
        CREATE TABLE IF NOT EXISTS spam (
            user_id BIGINT PRIMARY KEY,
            gid TEXT NOT NULL DEFAULT '',
            time TIMESTAMP,
            checks TEXT
        )`,
        }).
        Add(CmdCreateLocatorIndexes, engine.Query{
                Sqlite: `
                        CREATE INDEX IF NOT EXISTS idx_messages_user_id ON messages(user_id);
                        CREATE INDEX IF NOT EXISTS idx_messages_user_name ON messages(user_name);
                        CREATE INDEX IF NOT EXISTS idx_spam_time ON spam(time);
                        CREATE INDEX IF NOT EXISTS idx_messages_gid ON messages(gid);
                        CREATE INDEX IF NOT EXISTS idx_spam_gid ON spam(gid) `,
                Postgres: `
                        CREATE INDEX IF NOT EXISTS idx_messages_gid_user_id ON messages(gid, user_id);
                        CREATE INDEX IF NOT EXISTS idx_messages_gid_user_name ON messages(gid, user_name);
                        CREATE INDEX IF NOT EXISTS idx_spam_gid_time ON spam(gid, time DESC);
                        CREATE INDEX IF NOT EXISTS idx_spam_user_id_gid ON spam(user_id, gid)`,
        }).
        Add(CmdAddGIDColumnMessages, engine.Query{
                Sqlite:   "ALTER TABLE messages ADD COLUMN gid TEXT DEFAULT ''",
                Postgres: "ALTER TABLE messages ADD COLUMN IF NOT EXISTS gid TEXT DEFAULT ''",
        }).
        Add(CmdAddGIDColumnSpam, engine.Query{
                Sqlite:   "ALTER TABLE spam ADD COLUMN gid TEXT DEFAULT ''",
                Postgres: "ALTER TABLE spam ADD COLUMN IF NOT EXISTS gid TEXT DEFAULT ''",
        }).
        Add(CmdAddLocatorMessage, engine.Query{
                Sqlite: `INSERT OR REPLACE INTO messages (hash, gid, time, chat_id, user_id, user_name, msg_id) 
            VALUES (:hash, :gid, :time, :chat_id, :user_id, :user_name, :msg_id)`,
                Postgres: `INSERT INTO messages (hash, gid, time, chat_id, user_id, user_name, msg_id) 
            VALUES (:hash, :gid, :time, :chat_id, :user_id, :user_name, :msg_id)
            ON CONFLICT (hash) DO UPDATE SET 
            gid = :gid, 
            time = :time, 
            chat_id = :chat_id, 
            user_id = :user_id, 
            user_name = :user_name, 
            msg_id = :msg_id`,
        }).
        Add(CmdAddLocatorSpam, engine.Query{
                Sqlite: `INSERT OR REPLACE INTO spam (user_id, gid, time, checks) 
            VALUES (:user_id, :gid, :time, :checks)`,
                Postgres: `INSERT INTO spam (user_id, gid, time, checks) 
            VALUES (:user_id, :gid, :time, :checks)
            ON CONFLICT (user_id) DO UPDATE SET 
            gid = :gid, 
            time = :time, 
            checks = :checks`,
        })

// Locator stores messages metadata and spam results for a given ttl period.
// It is used to locate the message in the chat by its hash and to retrieve spam check results by userID.
// Useful to match messages from admin chat (only text available) to the original message and to get spam results using UserID.
type Locator struct {
        *engine.SQL
        ttl     time.Duration
        minSize int
        engine.RWLocker
}

// MsgMeta stores message metadata
type MsgMeta struct {
        Time     time.Time `db:"time"`
        ChatID   int64     `db:"chat_id"`
        UserID   int64     `db:"user_id"`
        UserName string    `db:"user_name"`
        MsgID    int       `db:"msg_id"`
}

// SpamData stores spam data for a given user
type SpamData struct {
        Time   time.Time `db:"time"`
        Checks []spamcheck.Response
}

// NewLocator creates new Locator. ttl defines how long to keep messages in db, minSize defines the minimum number of messages to keep
func NewLocator(ctx context.Context, ttl time.Duration, minSize int, db *engine.SQL) (*Locator, error) <span class="cov5" title="26">{
        if db == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db connection is nil")
        }</span>
        <span class="cov5" title="26">res := &amp;Locator{ttl: ttl, minSize: minSize, SQL: db, RWLocker: db.MakeLock()}
        cfg := engine.TableConfig{
                Name:          "messages_spam",
                CreateTable:   CmdCreateLocatorTables,
                CreateIndexes: CmdCreateLocatorIndexes,
                MigrateFunc:   res.migrate,
                QueriesMap:    locatorQueries,
        }
        if err := engine.InitTable(ctx, db, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init locator storage: %w", err)
        }</span>
        <span class="cov5" title="26">return res, nil</span>
}

func (l *Locator) migrate(ctx context.Context, tx *sqlx.Tx, gid string) error <span class="cov5" title="26">{
        // try to select with new structure, if works - already migrated
        var count int
        err := tx.GetContext(ctx, &amp;count, "SELECT COUNT(*) FROM messages WHERE gid = ''")
        if err == nil </span><span class="cov5" title="25">{
                log.Printf("[DEBUG] locator tables already migrated")
                return nil
        }</span>

        // add gid column to messages
        <span class="cov1" title="1">addGIDMessagesQuery, err := locatorQueries.Pick(l.Type(), CmdAddGIDColumnMessages)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add messages GID query: %w", err)
        }</span>

        <span class="cov1" title="1">_, err = tx.ExecContext(ctx, addGIDMessagesQuery)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "duplicate column") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add gid column to messages: %w", err)
        }</span>

        // add gid column to spam
        <span class="cov1" title="1">addGIDSpamQuery, err := locatorQueries.Pick(l.Type(), CmdAddGIDColumnSpam)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add spam GID query: %w", err)
        }</span>

        <span class="cov1" title="1">_, err = tx.ExecContext(ctx, addGIDSpamQuery)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "duplicate column") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add gid column to spam: %w", err)
        }</span>

        // update existing records with provided gid
        <span class="cov1" title="1">query := l.Adopt("UPDATE messages SET gid = ? WHERE gid = ''")
        if _, err = tx.ExecContext(ctx, query, gid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update gid for existing messages: %w", err)
        }</span>

        <span class="cov1" title="1">if _, err = tx.ExecContext(ctx, "UPDATE spam SET gid = ? WHERE gid = ''", gid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update gid for existing spam: %w", err)
        }</span>

        <span class="cov1" title="1">log.Printf("[DEBUG] locator tables migrated")
        return nil</span>
}

// Close closes the database
func (l *Locator) Close(_ context.Context) error <span class="cov0" title="0">{
        if err := l.SQL.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close SQL connection: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddMessage adds messages to the locator and also cleans up old messages.
func (l *Locator) AddMessage(ctx context.Context, msg string, chatID, userID int64, userName string, msgID int) error <span class="cov8" title="208">{
        l.Lock()
        defer l.Unlock()

        hash := l.MsgHash(msg)
        log.Printf("[DEBUG] add message to locator: %q, hash:%s, userID:%d, user name:%q, chatID:%d, msgID:%d",
                msg, hash, userID, userName, chatID, msgID)

        query, err := locatorQueries.Pick(l.Type(), CmdAddLocatorMessage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add message query: %w", err)
        }</span>

        <span class="cov8" title="208">_, err = l.NamedExecContext(ctx, query,
                struct {
                        MsgMeta
                        Hash string `db:"hash"`
                        GID  string `db:"gid"`
                }{
                        MsgMeta: MsgMeta{
                                Time:     time.Now(),
                                ChatID:   chatID,
                                UserID:   userID,
                                UserName: userName,
                                MsgID:    msgID,
                        },
                        Hash: hash,
                        GID:  l.GID(),
                })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert message: %w", err)
        }</span>
        <span class="cov8" title="208">return l.cleanupMessages(ctx)</span>
}

// AddSpam adds spam data to the locator and also cleans up old spam data.
func (l *Locator) AddSpam(ctx context.Context, userID int64, checks []spamcheck.Response) error <span class="cov3" title="4">{
        l.Lock()
        defer l.Unlock()

        checksStr, err := json.Marshal(checks)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal checks: %w", err)
        }</span>

        <span class="cov3" title="4">query, err := locatorQueries.Pick(l.Type(), CmdAddLocatorSpam)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get add spam query: %w", err)
        }</span>

        <span class="cov3" title="4">_, err = l.NamedExecContext(ctx, query,
                map[string]interface{}{
                        "user_id": userID,
                        "gid":     l.GID(),
                        "time":    time.Now(),
                        "checks":  string(checksStr),
                })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert spam: %w", err)
        }</span>
        <span class="cov3" title="4">return l.cleanupSpam()</span>
}

// Message returns message MsgMeta for given msg and gid
func (l *Locator) Message(ctx context.Context, msg string) (MsgMeta, bool) <span class="cov8" title="214">{
        l.RLock()
        defer l.RUnlock()

        var meta MsgMeta
        hash := l.MsgHash(msg)
        query := l.Adopt(`SELECT time, chat_id, user_id, user_name, msg_id FROM messages WHERE hash = ? AND gid = ?`)
        err := l.GetContext(ctx, &amp;meta, query, hash, l.GID())
        if err != nil </span><span class="cov3" title="6">{
                log.Printf("[DEBUG] failed to find message by hash %q: %v", hash, err)
                return MsgMeta{}, false
        }</span>
        <span class="cov8" title="208">return meta, true</span>
}

// UserNameByID returns username by user id within the same gid
func (l *Locator) UserNameByID(ctx context.Context, userID int64) string <span class="cov3" title="4">{
        l.RLock()
        defer l.RUnlock()

        var userName string
        query := l.Adopt(`SELECT user_name FROM messages WHERE user_id = ? AND gid = ? LIMIT 1`)
        err := l.GetContext(ctx, &amp;userName, query, userID, l.GID())
        if err != nil </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] failed to find user name by id %d: %v", userID, err)
                return ""
        }</span>
        <span class="cov2" title="2">return userName</span>
}

// UserIDByName returns user id by username within the same gid
func (l *Locator) UserIDByName(ctx context.Context, userName string) int64 <span class="cov3" title="4">{
        l.RLock()
        defer l.RUnlock()

        var userID int64
        query := l.Adopt(`SELECT user_id FROM messages WHERE user_name = ? AND gid = ? LIMIT 1`)
        err := l.GetContext(ctx, &amp;userID, query, userName, l.GID())
        if err != nil </span><span class="cov2" title="2">{
                log.Printf("[DEBUG] failed to find user id by name %q: %v", userName, err)
                return 0
        }</span>
        <span class="cov2" title="2">return userID</span>
}

// Spam returns message SpamData for given msg within the same gid
func (l *Locator) Spam(ctx context.Context, userID int64) (SpamData, bool) <span class="cov4" title="8">{
        l.RLock()
        defer l.RUnlock()

        var data SpamData
        var checksStr string
        query := l.Adopt(`SELECT time, checks FROM spam WHERE user_id = ? AND gid = ?`)
        err := l.QueryRowContext(ctx, query, userID, l.GID()).Scan(&amp;data.Time, &amp;checksStr)
        if err != nil </span><span class="cov2" title="2">{
                return SpamData{}, false
        }</span>
        <span class="cov3" title="6">if err := json.Unmarshal([]byte(checksStr), &amp;data.Checks); err != nil </span><span class="cov2" title="2">{
                return SpamData{}, false
        }</span>

        <span class="cov3" title="4">return data, true</span>
}

// MsgHash returns sha256 hash of a message
// we use hash to avoid storing potentially long messages and all we need is just match
func (l *Locator) MsgHash(msg string) string <span class="cov10" title="422">{
        return fmt.Sprintf("%x", sha256.Sum256([]byte(msg)))
}</span>

// cleanupMessages removes old messages. Messages with expired ttl are removed if the total number of messages exceeds minSize.
func (l *Locator) cleanupMessages(ctx context.Context) error <span class="cov8" title="210">{
        query := l.Adopt(`DELETE FROM messages WHERE time &lt; ? AND gid = ? AND (SELECT COUNT(*) FROM messages WHERE gid = ?) &gt; ?`)
        _, err := l.ExecContext(ctx, query, time.Now().Add(-l.ttl), l.GID(), l.GID(), l.minSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup messages: %w", err)
        }</span>
        <span class="cov8" title="210">return nil</span>
}

// cleanupSpam removes old spam data within the same gid
func (l *Locator) cleanupSpam() error <span class="cov3" title="6">{
        query := l.Adopt(`DELETE FROM spam WHERE time &lt; ? AND gid = ? AND (SELECT COUNT(*) FROM spam WHERE gid = ?) &gt; ?`)
        _, err := l.Exec(query, time.Now().Add(-l.ttl), l.GID(), l.GID(), l.minSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup spam: %w", err)
        }</span>
        <span class="cov3" title="6">return nil</span>
}

func (m MsgMeta) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{chatID: %d, user name: %s, userID: %d, msgID: %d, time: %s}",
                m.ChatID, m.UserName, m.UserID, m.MsgID, m.Time.Format(time.RFC3339))
}</span>

func (s SpamData) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{time: %s, checks: %+v}", s.Time.Format(time.RFC3339), s.Checks)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "context"
        "io"
        "time"
)

// SampleUpdater is an adaptor on top of Samples store, to update dynamic (user's) samples for detector, either ham or spam.
// The service is used by the detector to update the samples.
type SampleUpdater struct {
        samplesService *Samples
        sampleType     SampleType
        timeout        time.Duration
}

// NewSampleUpdater creates a new SampleUpdater instance with the given samples service, sample type and timeout.
func NewSampleUpdater(samplesService *Samples, sampleType SampleType, timeout time.Duration) *SampleUpdater <span class="cov10" title="26">{
        return &amp;SampleUpdater{samplesService: samplesService, sampleType: sampleType, timeout: timeout}
}</span>

// Append a message to the samples, forcing user origin
func (u *SampleUpdater) Append(msg string) error <span class="cov9" title="24">{
        ctx, cancel := context.Background(), func() </span>{<span class="cov2" title="2">}</span>
        <span class="cov9" title="24">if u.timeout &gt; 0 </span><span class="cov9" title="22">{
                ctx, cancel = context.WithTimeout(context.Background(), u.timeout)
        }</span>
        <span class="cov9" title="24">defer cancel()
        return u.samplesService.Add(ctx, u.sampleType, SampleOriginUser, msg)</span>
}

// Remove a message from the samples
func (u *SampleUpdater) Remove(msg string) error <span class="cov5" title="6">{
        ctx, cancel := context.Background(), func() </span>{<span class="cov0" title="0">}</span>
        <span class="cov5" title="6">if u.timeout &gt; 0 </span><span class="cov5" title="6">{
                ctx, cancel = context.WithTimeout(context.Background(), u.timeout)
        }</span>
        <span class="cov5" title="6">defer cancel()
        return u.samplesService.DeleteMessage(ctx, msg)</span>
}

// Reader returns a reader for the samples
func (u *SampleUpdater) Reader() (io.ReadCloser, error) <span class="cov7" title="10">{
        // we don't want to pass context with timeout here, as it's an async operation
        return u.samplesService.Reader(context.Background(), u.sampleType, SampleOriginUser)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package storage

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "iter"
        "log"

        "github.com/jmoiron/sqlx"
        _ "modernc.org/sqlite/lib" // sqlite driver

        "github.com/umputun/tg-spam/app/storage/engine"
)

// Samples is a storage for samples. It supports both ham and spam, as well as preset samples and user's samples
type Samples struct {
        *engine.SQL
        engine.RWLocker
}

// SampleType represents the type of the sample
type SampleType string

// enum for sample types
const (
        SampleTypeHam  SampleType = "ham"
        SampleTypeSpam SampleType = "spam"
)

// SampleOrigin represents the origin of the sample
type SampleOrigin string

// enum for sample origins
const (
        SampleOriginPreset SampleOrigin = "preset"
        SampleOriginUser   SampleOrigin = "user"
        SampleOriginAny    SampleOrigin = "any"
)

// samples-related command constants
const (
        CmdCreateSamplesTable engine.DBCmd = iota + 500
        CmdCreateSamplesIndexes
        CmdAddSample
        CmdImportSample
)

// queries holds all samples-related queries
var samplesQueries = engine.NewQueryMap().
        Add(CmdCreateSamplesTable, engine.Query{
                Sqlite: `CREATE TABLE IF NOT EXISTS samples (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            gid TEXT NOT NULL DEFAULT '',
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            type TEXT CHECK (type IN ('ham', 'spam')),
            origin TEXT CHECK (origin IN ('preset', 'user')),
            message TEXT NOT NULL,
            UNIQUE(gid, message)
        )`,
                Postgres: `CREATE TABLE IF NOT EXISTS samples (
            id SERIAL PRIMARY KEY,
            gid TEXT NOT NULL DEFAULT '',
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            type TEXT CHECK (type IN ('ham', 'spam')),
            origin TEXT CHECK (origin IN ('preset', 'user')),
            message TEXT NOT NULL,
            message_hash TEXT GENERATED ALWAYS AS (encode(sha256(message::bytea), 'hex')) STORED,
            UNIQUE(gid, message_hash)
        )`,
        }).
        Add(CmdAddSample, engine.Query{
                Sqlite: `INSERT OR REPLACE INTO samples (gid, type, origin, message) VALUES (?, ?, ?, ?)`,
                Postgres: `INSERT INTO samples (gid, type, origin, message) VALUES ($1, $2, $3, $4) 
                  ON CONFLICT (gid, message_hash) DO UPDATE SET type = EXCLUDED.type, origin = EXCLUDED.origin`,
        }).
        Add(CmdImportSample, engine.Query{
                Sqlite: `INSERT OR REPLACE INTO samples (gid, type, origin, message) VALUES (?, ?, ?, ?)`,
                Postgres: `INSERT INTO samples (gid, type, origin, message) 
                  VALUES ($1, $2, $3, $4) 
                  ON CONFLICT (gid, message_hash) DO UPDATE 
                  SET type = EXCLUDED.type, origin = EXCLUDED.origin`,
        }).
        Add(CmdCreateSamplesIndexes, engine.Query{
                Sqlite: `
                        CREATE INDEX IF NOT EXISTS idx_samples_gid ON samples(gid);
                        CREATE INDEX IF NOT EXISTS idx_samples_timestamp ON samples(timestamp);
                        CREATE INDEX IF NOT EXISTS idx_samples_type ON samples(type);
                        CREATE INDEX IF NOT EXISTS idx_samples_origin ON samples(origin);
                        CREATE INDEX IF NOT EXISTS idx_samples_lookup ON samples(gid, type, origin);
                        CREATE INDEX IF NOT EXISTS idx_samples_message ON samples(message)`,
                Postgres: `
                        CREATE INDEX IF NOT EXISTS idx_samples_lookup ON samples(gid, type, origin);
            CREATE INDEX IF NOT EXISTS idx_samples_gid_type_origin_ts ON samples(gid, type, origin, timestamp DESC);
                        CREATE INDEX IF NOT EXISTS idx_samples_gid ON samples(gid);
                        CREATE INDEX IF NOT EXISTS idx_samples_origin ON samples(gid,origin);
                        CREATE INDEX IF NOT EXISTS idx_samples_message_hash ON samples(message_hash);`,
        }).
        Add(CmdAddGIDColumn, engine.Query{
                Sqlite:   "ALTER TABLE samples ADD COLUMN gid TEXT DEFAULT ''",
                Postgres: "ALTER TABLE samples ADD COLUMN IF NOT EXISTS gid TEXT DEFAULT ''",
        })

// NewSamples creates a new Samples storage
func NewSamples(ctx context.Context, db *engine.SQL) (*Samples, error) <span class="cov6" title="94">{
        if db == nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("db connection is nil")
        }</span>
        <span class="cov6" title="92">res := &amp;Samples{SQL: db, RWLocker: db.MakeLock()}
        cfg := engine.TableConfig{
                Name:          "samples",
                CreateTable:   CmdCreateSamplesTable,
                CreateIndexes: CmdCreateSamplesIndexes,
                MigrateFunc:   res.migrate,
                QueriesMap:    samplesQueries,
        }
        if err := engine.InitTable(ctx, db, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init samples storage: %w", err)
        }</span>
        <span class="cov6" title="92">return res, nil</span>
}

// Add adds a sample to the storage. Checks if the sample is already present and skips it if it is.
func (s *Samples) Add(ctx context.Context, t SampleType, o SampleOrigin, message string) error <span class="cov9" title="1160">{
        dbgMsg := message
        if len(dbgMsg) &gt; 1024 </span><span class="cov3" title="12">{
                dbgMsg = dbgMsg[:1024] + "..."
        }</span>
        <span class="cov9" title="1160">log.Printf("[DEBUG] adding sample: %s, %s, %q", t, o, dbgMsg)
        if err := t.Validate(); err != nil </span><span class="cov2" title="4">{
                return err
        }</span>
        <span class="cov9" title="1156">if err := o.Validate(); err != nil </span><span class="cov2" title="4">{
                return err
        }</span>

        <span class="cov9" title="1152">if o == SampleOriginAny </span><span class="cov1" title="2">{
                return fmt.Errorf("can't add sample with origin 'any'")
        }</span>
        <span class="cov9" title="1150">if message == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("message can't be empty")
        }</span>

        <span class="cov9" title="1148">s.Lock()
        defer s.Unlock()

        query, err := samplesQueries.Pick(s.Type(), CmdAddSample)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get query: %w", err)
        }</span>
        <span class="cov9" title="1148">if _, err := s.ExecContext(ctx, query, s.GID(), t, o, message); err != nil </span><span class="cov3" title="8">{
                return fmt.Errorf("failed to add sample: %w", err)
        }</span>

        <span class="cov9" title="1140">return nil</span>
}

// Delete removes a sample from the storage by its ID
func (s *Samples) Delete(ctx context.Context, id int64) error <span class="cov2" title="4">{
        log.Printf("[DEBUG] deleting sample: %d", id)
        s.Lock()
        defer s.Unlock()

        result, err := s.ExecContext(ctx, s.Adopt(`DELETE FROM samples WHERE id = ?`), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove sample: %w", err)
        }</span>

        <span class="cov2" title="4">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>
        <span class="cov2" title="4">if affected == 0 </span><span class="cov1" title="2">{
                return fmt.Errorf("sample %d not found", id)
        }</span>
        <span class="cov1" title="2">return nil</span>
}

// DeleteMessage removes a sample from the storage by its message
func (s *Samples) DeleteMessage(ctx context.Context, message string) error <span class="cov5" title="40">{
        log.Printf("[DEBUG] deleting sample: %q", message)
        s.Lock()
        defer s.Unlock()

        // first verify the message exists in this group
        var count int
        gid := s.GID()
        query := s.Adopt(`SELECT COUNT(*) FROM samples WHERE gid = ? AND message = ?`)
        if err := s.GetContext(ctx, &amp;count, query, gid, message); err != nil </span><span class="cov1" title="2">{
                return fmt.Errorf("failed to check sample existence: %w", err)
        }</span>
        <span class="cov5" title="38">if count == 0 </span><span class="cov3" title="6">{
                return fmt.Errorf("sample not found: gid=%s, message=%s", gid, message)
        }</span>

        <span class="cov5" title="32">result, err := s.ExecContext(ctx, s.Adopt(`DELETE FROM samples WHERE gid = ? AND message = ?`), gid, message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove sample: %w", err)
        }</span>

        <span class="cov5" title="32">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>
        <span class="cov5" title="32">if affected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete sample: gid=%s, message=%s not found", gid, message)
        }</span>
        <span class="cov5" title="32">return nil</span>
}

// Read reads samples from storage by type and origin
func (s *Samples) Read(ctx context.Context, t SampleType, o SampleOrigin) ([]string, error) <span class="cov9" title="1054">{
        s.RLock()
        defer s.RUnlock()

        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov9" title="1052">if err := o.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="1050">var (
                query   string
                args    []any
                samples []string
        )
        gid := s.GID()
        if o == SampleOriginAny </span><span class="cov9" title="1002">{
                query = `SELECT message FROM samples WHERE gid = ? AND type = ?`
                args = []any{gid, t}
        }</span> else<span class="cov5" title="48"> {
                query = `SELECT message FROM samples WHERE gid = ? AND type = ? AND origin = ?`
                args = []any{gid, t, o}
        }</span>
        <span class="cov9" title="1050">query = s.Adopt(query)

        if err := s.SelectContext(ctx, &amp;samples, query, args...); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get samples: %w", err)
        }</span>
        <span class="cov9" title="1050">log.Printf("[DEBUG] read %d samples: gid=%s, type=%s, origin=%s", len(samples), gid, t, o)
        return samples, nil</span>
}

// Reader returns a reader for samples by type and origin
// Sorts samples by timestamp in descending order, i.e. from the newest to the oldest
func (s *Samples) Reader(ctx context.Context, t SampleType, o SampleOrigin) (io.ReadCloser, error) <span class="cov4" title="26">{
        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov4" title="24">if err := o.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="24">var query string
        var args []any
        gid := s.GID()

        if o == SampleOriginAny </span><span class="cov0" title="0">{
                query = `SELECT message FROM samples WHERE gid = ? AND  type = ? ORDER BY timestamp DESC`
                args = []any{gid, t}
        }</span> else<span class="cov4" title="24"> {
                query = `SELECT message FROM samples WHERE gid = ? AND type = ? AND origin = ? ORDER BY timestamp DESC`
                args = []any{gid, t, o}
        }</span>
        <span class="cov4" title="24">query = s.Adopt(query)

        s.RLock()
        defer s.RUnlock()
        rows, err := s.QueryxContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query samples: %w", err)
        }</span>

        <span class="cov4" title="24">return &amp;sampleReader{rows: rows}, nil</span>
}

// Iterator returns an iterator for samples by type and origin.
// Sorts samples by timestamp in descending order, i.e. from the newest to the oldest.
// The iterator respects context cancellation.
func (s *Samples) Iterator(ctx context.Context, t SampleType, o SampleOrigin) (iter.Seq[string], error) <span class="cov4" title="14">{
        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov3" title="12">if err := o.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="12">var query string
        var args []any
        gid := s.GID()

        if o == SampleOriginAny </span><span class="cov1" title="2">{
                query = `SELECT message FROM samples WHERE gid = ? AND type = ? ORDER BY timestamp DESC`
                args = []any{gid, t}
        }</span> else<span class="cov3" title="10"> {
                query = `SELECT message FROM samples WHERE gid = ? AND type = ? AND origin = ? ORDER BY timestamp DESC`
                args = []any{gid, t, o}
        }</span>
        <span class="cov3" title="12">query = s.Adopt(query)

        s.RLock()
        rows, err := s.QueryxContext(ctx, query, args...)
        s.RUnlock()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query samples: %w", err)
        }</span>

        <span class="cov3" title="12">return func(yield func(string) bool) </span><span class="cov3" title="12">{
                defer rows.Close()
                for rows.Next() </span><span class="cov4" title="30">{
                        // check context before each row
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="2">
                                return</span>
                        default:<span class="cov4" title="28"></span>
                        }

                        <span class="cov4" title="28">var message string
                        if err := rows.Scan(&amp;message); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[ERROR] scan failed: %v", err)
                                return
                        }</span>

                        // check context after scan but before yield
                        <span class="cov4" title="28">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov4" title="28"></span>
                        }

                        <span class="cov4" title="28">if !yield(message) </span><span class="cov1" title="2">{
                                return
                        }</span>
                }
                <span class="cov3" title="8">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] rows iteration failed: %v", err)
                        return
                }</span>
        }, nil
}

// Import reads samples from the reader and imports them into the storage.
// Returns statistics about imported samples.
// If withCleanup is true removes all samples with the same type and origin before import.
func (s *Samples) Import(ctx context.Context, t SampleType, o SampleOrigin, r io.Reader, withCleanup bool) (*SamplesStats, error) <span class="cov5" title="46">{
        if err := t.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov5" title="44">if err := o.Validate(); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov5" title="42">if o == SampleOriginAny </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("can't import samples with origin 'any'")
        }</span>
        <span class="cov5" title="40">if r == nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("reader cannot be nil")
        }</span>
        <span class="cov5" title="38">gid := s.GID()

        s.Lock()
        defer s.Unlock()

        // start transaction
        tx, err := s.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov5" title="38">defer tx.Rollback()

        // remove all samples with the same type and origin if requested
        if withCleanup </span><span class="cov5" title="36">{
                query := s.Adopt(`DELETE FROM samples WHERE gid = ? AND type = ? AND origin = ?`)
                result, errDel := tx.ExecContext(ctx, query, gid, t, o)
                if errDel != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to remove old samples: %w", errDel)
                }</span>
                <span class="cov5" title="36">affected, errCount := result.RowsAffected()
                if errCount != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get affected rows: %w", errCount)
                }</span>
                <span class="cov5" title="36">log.Printf("[DEBUG] removed %d old samples: gid=%s, type=%s, origin=%s", affected, gid, t, o)</span>
        }

        // add samples
        <span class="cov5" title="38">query, err := samplesQueries.Pick(s.Type(), CmdImportSample)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get import query: %w", err)
        }</span>
        <span class="cov5" title="38">scanner := bufio.NewScanner(r)
        // set custom buffer size and max token size for large lines
        const maxScanTokenSize = 64 * 1024 // 64KB max line length
        buf := make([]byte, maxScanTokenSize)
        scanner.Buffer(buf, maxScanTokenSize)

        added := 0
        for scanner.Scan() </span><span class="cov5" title="64">{
                message := scanner.Text()
                if message == "" </span><span class="cov3" title="12">{ // skip empty lines
                        continue</span>
                }
                <span class="cov5" title="52">if _, err = tx.ExecContext(ctx, query, gid, t, o, message); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add sample: %w", err)
                }</span>
                <span class="cov5" title="52">added++</span>
        }

        // check for scanner errors after the scan is complete
        <span class="cov5" title="38">if err = scanner.Err(); err != nil </span><span class="cov3" title="8">{
                return nil, fmt.Errorf("error reading input: %w", err)
        }</span>

        <span class="cov4" title="30">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>
        <span class="cov4" title="30">log.Printf("[DEBUG] imported %d samples: gid=%s, type=%s, origin=%s", added, gid, t, o)
        return s.stats(ctx)</span>
}

// String implements Stringer interface
func (t SampleType) String() string <span class="cov9" title="2289">{ return string(t) }</span>

// Validate checks if the sample type is valid
func (t SampleType) Validate() error <span class="cov10" title="2303">{
        switch t </span>{
        case SampleTypeHam, SampleTypeSpam:<span class="cov9" title="2290">
                return nil</span>
        }
        <span class="cov3" title="13">return fmt.Errorf("invalid sample type: %s", t)</span>
}

// String implements Stringer interface
func (o SampleOrigin) String() string <span class="cov9" title="2285">{ return string(o) }</span>

// Validate checks if the sample origin is valid
func (o SampleOrigin) Validate() error <span class="cov9" title="2292">{
        switch o </span>{
        case SampleOriginPreset, SampleOriginUser, SampleOriginAny:<span class="cov9" title="2283">
                return nil</span>
        }
        <span class="cov3" title="9">return fmt.Errorf("invalid sample origin: %s", o)</span>
}

// SamplesStats returns statistics about samples
type SamplesStats struct {
        TotalSpam  int `db:"spam_count"`
        TotalHam   int `db:"ham_count"`
        PresetSpam int `db:"preset_spam_count"`
        PresetHam  int `db:"preset_ham_count"`
        UserSpam   int `db:"user_spam_count"`
        UserHam    int `db:"user_ham_count"`
}

// String provides a string representation of the statistics
func (st *SamplesStats) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("spam: %d, ham: %d, preset spam: %d, preset ham: %d, user spam: %d, user ham: %d",
                st.TotalSpam, st.TotalHam, st.PresetSpam, st.PresetHam, st.UserSpam, st.UserHam)
}</span>

// Stats returns statistics about samples
func (s *Samples) Stats(ctx context.Context) (*SamplesStats, error) <span class="cov3" title="6">{
        s.RLock()
        defer s.RUnlock()
        return s.stats(ctx)
}</span>

// stats returns statistics about samples without locking
func (s *Samples) stats(ctx context.Context) (*SamplesStats, error) <span class="cov5" title="36">{
        query := s.Adopt(`
        SELECT 
            COUNT(CASE WHEN type = 'spam' THEN 1 END) as spam_count,
            COUNT(CASE WHEN type = 'ham' THEN 1 END) as ham_count,
            COUNT(CASE WHEN type = 'spam' AND origin = 'preset' THEN 1 END) as preset_spam_count,
            COUNT(CASE WHEN type = 'ham' AND origin = 'preset' THEN 1 END) as preset_ham_count,
            COUNT(CASE WHEN type = 'spam' AND origin = 'user' THEN 1 END) as user_spam_count,
            COUNT(CASE WHEN type = 'ham' AND origin = 'user' THEN 1 END) as user_ham_count
        FROM samples 
        WHERE gid = ?`)

        var stats SamplesStats
        if err := s.GetContext(ctx, &amp;stats, query, s.GID()); err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("failed to get stats: %w", err)
        }</span>
        <span class="cov5" title="34">return &amp;stats, nil</span>
}

func (s *Samples) migrate(_ context.Context, _ *sqlx.Tx, _ string) error <span class="cov6" title="92">{
        // no migration needed for now
        return nil
}</span>

// sampleReader implements io.Reader for database rows and handles partial reads with buffering.
type sampleReader struct {
        rows    *sqlx.Rows // database rows iterator
        buffer  []byte     // partial read buffer for cases when p is smaller than message size
        current string     // current message from the database
        closed  bool       // indicates if the reader has been closed
}

// Read implements io.Reader interface. It reads messages from database rows one by one and
// handles partial reads by maintaining an internal buffer. If the provided buffer p is smaller
// than the message size, it will take multiple Read calls to get the complete message.
// Each message is followed by a newline for proper scanning.
func (r *sampleReader) Read(p []byte) (n int, err error) <span class="cov9" title="1070">{
        if r.closed </span><span class="cov1" title="2">{
                return 0, io.ErrClosedPipe
        }</span>

        // if buffer is empty, try to get next message from database
        <span class="cov9" title="1068">if len(r.buffer) == 0 </span><span class="cov5" title="40">{
                if r.rows == nil || !r.rows.Next() </span><span class="cov4" title="18">{
                        if r.rows != nil &amp;&amp; r.rows.Err() != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("rows iteration failed: %w", r.rows.Err())
                        }</span>
                        <span class="cov4" title="18">return 0, io.EOF</span>
                }

                <span class="cov4" title="22">if err := r.rows.Scan(&amp;r.current); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("scan failed: %w", err)
                }</span>
                // append newline to message for proper scanning
                <span class="cov4" title="22">r.buffer = []byte(r.current + "\n")</span>
        }

        // copy as much as we can to the provided buffer
        <span class="cov9" title="1050">n = copy(p, r.buffer)
        // keep the rest for the next read
        r.buffer = r.buffer[n:]
        return n, nil</span>
}

// Close implements io.Closer interface. Can be called multiple times safely.
func (r *sampleReader) Close() error <span class="cov4" title="26">{
        if r.closed </span><span class="cov2" title="4">{
                return nil
        }</span>
        <span class="cov4" title="22">r.closed = true
        if r.rows != nil </span><span class="cov4" title="22">{
                if err := r.rows.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close rows: %w", err)
                }</span>
                <span class="cov4" title="22">r.rows = nil</span> // prevent double-close
        }
        <span class="cov4" title="22">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package storage

import (
        "context"
        "fmt"
        "strings"

        "github.com/umputun/tg-spam/app/storage/engine"
)

// New creates a new store based on the connection URL and the session duration.
func New(ctx context.Context, connURL, gid string) (*engine.SQL, error) <span class="cov4" title="3">{
        dbType, conn, err := prepareStoreURL(connURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">switch dbType </span>{
        case engine.Sqlite:<span class="cov3" title="2">
                res, err := engine.NewSqlite(conn, gid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create sqlite engine: %w", err)
                }</span>
                <span class="cov3" title="2">return res, nil</span>
        case engine.Postgres:<span class="cov0" title="0">
                res, err := engine.NewPostgres(ctx, conn, gid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create postgres engine: %w", err)
                }</span>
                <span class="cov0" title="0">return res, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database type in connection string")</span>
        }
}

// prepareStoreURL returns the type of the store based on the connection URL and the connection URL.
// supported connection strings for psq, mysql and sqlite
// returns the type of the store and the connection string to use with sqlx
func prepareStoreURL(connURL string) (dbType engine.Type, conn string, err error) <span class="cov10" title="16">{
        if strings.HasPrefix(connURL, "postgres://") </span><span class="cov1" title="1">{
                return engine.Postgres, connURL, nil
        }</span>
        <span class="cov9" title="15">if strings.Contains(connURL, "@tcp(") </span><span class="cov4" title="3">{
                // check if parseTime=true is set in the connection string and add it if not
                if !strings.Contains(connURL, "parseTime=true") </span><span class="cov3" title="2">{
                        if strings.Contains(connURL, "?") </span><span class="cov1" title="1">{
                                connURL += "&amp;parseTime=true"
                        }</span> else<span class="cov1" title="1"> {
                                connURL += "?parseTime=true"
                        }</span>
                }
                <span class="cov4" title="3">return engine.Mysql, connURL, nil</span>
        }
        <span class="cov9" title="12">if strings.HasPrefix(connURL, "sqlite:/") || strings.HasPrefix(connURL, "sqlite3:/") ||
                strings.HasSuffix(connURL, ".sqlite") || strings.HasSuffix(connURL, ".db") </span><span class="cov6" title="5">{
                connURL = strings.Replace(connURL, "sqlite:/", "file:/", 1)
                connURL = strings.Replace(connURL, "sqlite3:/", "file:/", 1)
                return engine.Sqlite, connURL, nil
        }</span>

        <span class="cov7" title="7">if connURL == "memory" || strings.Contains(connURL, ":memory:") ||
                strings.HasPrefix(connURL, "memory://") || strings.HasPrefix(connURL, "mem://") </span><span class="cov6" title="5">{
                return engine.Sqlite, ":memory:", nil
        }</span>

        <span class="cov3" title="2">return engine.Unknown, "", fmt.Errorf("unsupported database type in connection string")</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package webapi

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        log "github.com/go-pkgz/lgr"
        "github.com/go-pkgz/rest"

        "github.com/umputun/tg-spam/app/config"
)

//go:generate moq --out config_store_mock.go --with-resets --skip-ensure . SettingsStore

// SettingsStore provides access to configuration stored in database
type SettingsStore interface {
        Load(ctx context.Context) (*config.Settings, error)
        Save(ctx context.Context, settings *config.Settings) error
        Delete(ctx context.Context) error
        LastUpdated(ctx context.Context) (time.Time, error)
        Exists(ctx context.Context) (bool, error)
}

// saveConfigHandler handles POST /config request.
// It saves the current configuration to the database.
func (s *Server) saveConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov5" title="4">{
        if s.SettingsStore == nil </span><span class="cov1" title="1">{
                http.Error(w, "Configuration storage not available", http.StatusInternalServerError)
                return
        }</span>

        // save current settings to database
        <span class="cov4" title="3">err := s.SettingsStore.Save(r.Context(), s.AppSettings)
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("[ERROR] failed to save configuration: %v", err)
                http.Error(w, fmt.Sprintf("Failed to save configuration: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="2">if r.Header.Get("HX-Request") == "true" </span><span class="cov1" title="1">{
                // return a success message for HTMX
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration saved successfully&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov1" title="1">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration saved successfully"})</span>
}

// loadConfigHandler handles GET /config request.
// It loads configuration from the database.
func (s *Server) loadConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="5">{
        if s.SettingsStore == nil </span><span class="cov1" title="1">{
                http.Error(w, "Configuration storage not available", http.StatusInternalServerError)
                return
        }</span>

        // load settings from database
        <span class="cov5" title="4">settings, err := s.SettingsStore.Load(r.Context())
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("[ERROR] failed to load configuration: %v", err)
                http.Error(w, fmt.Sprintf("Failed to load configuration: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // preserve CLI-provided credentials and transient settings
        // CLI credentials have precedence over database values if provided
        <span class="cov4" title="3">transient := s.AppSettings.Transient
        telegramToken := s.AppSettings.Telegram.Token
        openAIToken := s.AppSettings.OpenAI.Token
        webAuthHash := s.AppSettings.Server.AuthHash
        webAuthPasswd := s.AppSettings.Transient.WebAuthPasswd

        // restore transient values
        settings.Transient = transient

        // restore CLI-provided credentials if they were set
        // these override database values because CLI parameters take precedence
        if telegramToken != "" </span><span class="cov1" title="1">{
                settings.Telegram.Token = telegramToken
        }</span>
        <span class="cov4" title="3">if openAIToken != "" </span><span class="cov1" title="1">{
                settings.OpenAI.Token = openAIToken
        }</span>
        <span class="cov4" title="3">if webAuthHash != "" </span><span class="cov0" title="0">{
                settings.Server.AuthHash = webAuthHash
        }</span>
        <span class="cov4" title="3">if webAuthPasswd != "" </span><span class="cov0" title="0">{
                settings.Transient.WebAuthPasswd = webAuthPasswd
        }</span>

        // update current settings
        <span class="cov4" title="3">s.AppSettings = settings

        if r.Header.Get("HX-Request") == "true" </span><span class="cov1" title="1">{
                // return a success message for HTMX with reload
                w.Header().Set("HX-Refresh", "true") // force page reload to reflect new settings
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration loaded successfully. Refreshing page...&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov3" title="2">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration loaded successfully"})</span>
}

// updateConfigHandler handles PUT /config request.
// It updates specific configuration settings in memory and optionally saves to database.
func (s *Server) updateConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="6">{
        if err := r.ParseForm(); err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf("Failed to parse form: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="5">log.Printf("[DEBUG] updateConfigHandler: saveToDb=%s, SettingsStore=%v", r.FormValue("saveToDb"), s.SettingsStore != nil)

        // update settings based on form values - auth settings are never modified
        updateSettingsFromForm(s.AppSettings, r)

        // save changes to database if requested
        if r.FormValue("saveToDb") == "true" &amp;&amp; s.SettingsStore != nil </span><span class="cov3" title="2">{
                log.Printf("[DEBUG] Saving settings to database")
                err := s.SettingsStore.Save(r.Context(), s.AppSettings)
                if err != nil </span><span class="cov1" title="1">{
                        log.Printf("[ERROR] failed to save updated configuration: %v", err)
                        http.Error(w, fmt.Sprintf("Failed to save configuration: %v", err), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov1" title="1">log.Printf("[DEBUG] Settings saved successfully")</span>
        }

        <span class="cov5" title="4">if r.Header.Get("HX-Request") == "true" </span><span class="cov1" title="1">{
                // return a success message for HTMX
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration updated successfully&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov4" title="3">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration updated successfully"})</span>
}

// deleteConfigHandler handles DELETE /config request.
// It deletes the saved configuration from the database.
func (s *Server) deleteConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov5" title="4">{
        if s.SettingsStore == nil </span><span class="cov1" title="1">{
                http.Error(w, "Configuration storage not available", http.StatusInternalServerError)
                return
        }</span>

        // delete configuration from database
        <span class="cov4" title="3">err := s.SettingsStore.Delete(r.Context())
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("[ERROR] failed to delete configuration: %v", err)
                http.Error(w, fmt.Sprintf("Failed to delete configuration: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="2">if r.Header.Get("HX-Request") == "true" </span><span class="cov1" title="1">{
                // return a success message for HTMX
                if _, err := w.Write([]byte(`&lt;div class="alert alert-success"&gt;Configuration deleted successfully&lt;/div&gt;`)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to write response: %v", err)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        // return JSON response for API calls
        <span class="cov1" title="1">rest.RenderJSON(w, rest.JSON{"status": "ok", "message": "Configuration deleted successfully"})</span>
}

// updateSettingsFromForm updates settings from form values
func updateSettingsFromForm(settings *config.Settings, r *http.Request) <span class="cov10" title="15">{
        // general settings
        if val := r.FormValue("primaryGroup"); val != "" </span><span class="cov5" title="4">{
                settings.Telegram.Group = val
        }</span>
        <span class="cov10" title="15">if val := r.FormValue("adminGroup"); val != "" </span><span class="cov0" title="0">{
                settings.Admin.AdminGroup = val
        }</span>
        <span class="cov10" title="15">settings.Admin.DisableAdminSpamForward = r.FormValue("disableAdminSpamForward") == "on"
        settings.Logger.Enabled = r.FormValue("loggerEnabled") == "on"
        settings.NoSpamReply = r.FormValue("noSpamReply") == "on"

        // handle CasEnabled separately because we need to set CAS.API
        casEnabled := r.FormValue("casEnabled") == "on"
        if casEnabled &amp;&amp; settings.CAS.API == "" </span><span class="cov3" title="2">{
                settings.CAS.API = "https://api.cas.chat" // default CAS API endpoint
        }</span> else<span class="cov9" title="13"> if !casEnabled </span><span class="cov9" title="13">{
                settings.CAS.API = ""
        }</span>

        // parse super users from comma-separated string
        <span class="cov10" title="15">if superUsers := r.FormValue("superUsers"); superUsers != "" </span><span class="cov3" title="2">{
                users := strings.Split(superUsers, ",")
                settings.Admin.SuperUsers = make([]string, 0, len(users))
                for _, user := range users </span><span class="cov6" title="6">{
                        trimmed := strings.TrimSpace(user)
                        if trimmed != "" </span><span class="cov6" title="6">{
                                settings.Admin.SuperUsers = append(settings.Admin.SuperUsers, trimmed)
                        }</span>
                }
        }

        // meta checks
        <span class="cov10" title="15">metaEnabled := r.FormValue("metaEnabled") == "on"

        if val := r.FormValue("metaLinksLimit"); val != "" </span><span class="cov4" title="3">{
                if limit, err := strconv.Atoi(val); err == nil </span><span class="cov4" title="3">{
                        settings.Meta.LinksLimit = limit
                }</span>
        } else<span class="cov9" title="12"> if !metaEnabled </span><span class="cov9" title="12">{
                settings.Meta.LinksLimit = -1
        }</span>

        <span class="cov10" title="15">if val := r.FormValue("metaMentionsLimit"); val != "" </span><span class="cov3" title="2">{
                if limit, err := strconv.Atoi(val); err == nil </span><span class="cov3" title="2">{
                        settings.Meta.MentionsLimit = limit
                }</span>
        } else<span class="cov9" title="13"> if !metaEnabled </span><span class="cov9" title="13">{
                settings.Meta.MentionsLimit = -1
        }</span>

        <span class="cov10" title="15">settings.Meta.LinksOnly = r.FormValue("metaLinksOnly") == "on"
        settings.Meta.ImageOnly = r.FormValue("metaImageOnly") == "on"
        settings.Meta.VideosOnly = r.FormValue("metaVideoOnly") == "on"
        settings.Meta.AudiosOnly = r.FormValue("metaAudioOnly") == "on"
        settings.Meta.Forward = r.FormValue("metaForwarded") == "on"
        settings.Meta.Keyboard = r.FormValue("metaKeyboard") == "on"

        if val := r.FormValue("metaUsernameSymbols"); val != "" </span><span class="cov3" title="2">{
                settings.Meta.UsernameSymbols = val
        }</span> else<span class="cov9" title="13"> if !metaEnabled </span><span class="cov9" title="13">{
                settings.Meta.UsernameSymbols = ""
        }</span>

        // openAI settings
        <span class="cov10" title="15">openAIEnabled := r.FormValue("openAIEnabled") == "on"
        if !openAIEnabled </span><span class="cov9" title="12">{
                settings.OpenAI.APIBase = ""
        }</span>

        <span class="cov10" title="15">settings.OpenAI.Veto = r.FormValue("openAIVeto") == "on"

        if val := r.FormValue("openAIHistorySize"); val != "" </span><span class="cov3" title="2">{
                if size, err := strconv.Atoi(val); err == nil </span><span class="cov3" title="2">{
                        settings.OpenAI.HistorySize = size
                }</span>
        }

        <span class="cov10" title="15">if val := r.FormValue("openAIModel"); val != "" </span><span class="cov3" title="2">{
                settings.OpenAI.Model = val
        }</span>

        // lua plugins
        <span class="cov10" title="15">settings.LuaPlugins.Enabled = r.FormValue("luaPluginsEnabled") == "on"
        settings.LuaPlugins.DynamicReload = r.FormValue("luaDynamicReload") == "on"

        if val := r.FormValue("luaPluginsDir"); val != "" </span><span class="cov3" title="2">{
                settings.LuaPlugins.PluginsDir = val
        }</span>

        // get selected Lua plugins
        <span class="cov10" title="15">settings.LuaPlugins.EnabledPlugins = r.Form["luaEnabledPlugins"]

        // spam detection
        if val := r.FormValue("similarityThreshold"); val != "" </span><span class="cov4" title="3">{
                if threshold, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov4" title="3">{
                        settings.SimilarityThreshold = threshold
                }</span>
        }

        <span class="cov10" title="15">if val := r.FormValue("minMsgLen"); val != "" </span><span class="cov3" title="2">{
                if msgLen, err := strconv.Atoi(val); err == nil </span><span class="cov3" title="2">{
                        settings.MinMsgLen = msgLen
                }</span>
        }

        <span class="cov10" title="15">if val := r.FormValue("maxEmoji"); val != "" </span><span class="cov3" title="2">{
                if count, err := strconv.Atoi(val); err == nil </span><span class="cov3" title="2">{
                        settings.MaxEmoji = count
                }</span>
        }

        <span class="cov10" title="15">if val := r.FormValue("minSpamProbability"); val != "" </span><span class="cov3" title="2">{
                if prob, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov3" title="2">{
                        settings.MinSpamProbability = prob
                }</span>
        }

        <span class="cov10" title="15">settings.ParanoidMode = r.FormValue("paranoidMode") == "on"

        if val := r.FormValue("firstMessagesCount"); val != "" </span><span class="cov1" title="1">{
                if count, err := strconv.Atoi(val); err == nil </span><span class="cov1" title="1">{
                        settings.FirstMessagesCount = count
                }</span>
        }

        // startupMessageEnabled controls Message.Startup
        <span class="cov10" title="15">startupMessageEnabled := r.FormValue("startupMessageEnabled") == "on"
        if startupMessageEnabled &amp;&amp; settings.Message.Startup == "" </span><span class="cov3" title="2">{
                settings.Message.Startup = "Bot started"
        }</span> else<span class="cov9" title="13"> if !startupMessageEnabled </span><span class="cov9" title="13">{
                settings.Message.Startup = ""
        }</span>

        <span class="cov10" title="15">settings.Training = r.FormValue("trainingEnabled") == "on"
        settings.SoftBan = r.FormValue("softBanEnabled") == "on"
        settings.AbnormalSpace.Enabled = r.FormValue("abnormalSpacingEnabled") == "on"

        if val := r.FormValue("multiLangLimit"); val != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                        settings.MultiLangWords = limit
                }</span>
        }

        <span class="cov10" title="15">if val := r.FormValue("historySize"); val != "" </span><span class="cov1" title="1">{
                if size, err := strconv.Atoi(val); err == nil </span><span class="cov1" title="1">{
                        settings.History.Size = size
                }</span>
        }

        // data storage
        <span class="cov10" title="15">if val := r.FormValue("samplesDataPath"); val != "" </span><span class="cov0" title="0">{
                settings.Files.SamplesDataPath = val
        }</span>

        <span class="cov10" title="15">if val := r.FormValue("dynamicDataPath"); val != "" </span><span class="cov0" title="0">{
                settings.Files.DynamicDataPath = val
        }</span>

        <span class="cov10" title="15">if val := r.FormValue("watchIntervalSecs"); val != "" </span><span class="cov1" title="1">{
                if secs, err := strconv.Atoi(val); err == nil </span><span class="cov1" title="1">{
                        settings.Files.WatchInterval = secs
                }</span>
        }

        // debug modes - they're primarily CLI settings but we still update them here
        <span class="cov10" title="15">settings.Transient.Dbg = r.FormValue("debugModeEnabled") == "on"
        settings.Dry = r.FormValue("dryModeEnabled") == "on"
        settings.Transient.TGDbg = r.FormValue("tgDebugModeEnabled") == "on"</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package webapi

import (
        "context"
        "github.com/umputun/tg-spam/app/config"
        "sync"
        "time"
)

// SettingsStoreMock is a mock implementation of SettingsStore.
//
//        func TestSomethingThatUsesSettingsStore(t *testing.T) {
//
//                // make and configure a mocked SettingsStore
//                mockedSettingsStore := &amp;SettingsStoreMock{
//                        DeleteFunc: func(ctx context.Context) error {
//                                panic("mock out the Delete method")
//                        },
//                        ExistsFunc: func(ctx context.Context) (bool, error) {
//                                panic("mock out the Exists method")
//                        },
//                        LastUpdatedFunc: func(ctx context.Context) (time.Time, error) {
//                                panic("mock out the LastUpdated method")
//                        },
//                        LoadFunc: func(ctx context.Context) (*config.Settings, error) {
//                                panic("mock out the Load method")
//                        },
//                        SaveFunc: func(ctx context.Context, settings *config.Settings) error {
//                                panic("mock out the Save method")
//                        },
//                }
//
//                // use mockedSettingsStore in code that requires SettingsStore
//                // and then make assertions.
//
//        }
type SettingsStoreMock struct {
        // DeleteFunc mocks the Delete method.
        DeleteFunc func(ctx context.Context) error

        // ExistsFunc mocks the Exists method.
        ExistsFunc func(ctx context.Context) (bool, error)

        // LastUpdatedFunc mocks the LastUpdated method.
        LastUpdatedFunc func(ctx context.Context) (time.Time, error)

        // LoadFunc mocks the Load method.
        LoadFunc func(ctx context.Context) (*config.Settings, error)

        // SaveFunc mocks the Save method.
        SaveFunc func(ctx context.Context, settings *config.Settings) error

        // calls tracks calls to the methods.
        calls struct {
                // Delete holds details about calls to the Delete method.
                Delete []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Exists holds details about calls to the Exists method.
                Exists []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // LastUpdated holds details about calls to the LastUpdated method.
                LastUpdated []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Load holds details about calls to the Load method.
                Load []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Save holds details about calls to the Save method.
                Save []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // Settings is the settings argument value.
                        Settings *config.Settings
                }
        }
        lockDelete      sync.RWMutex
        lockExists      sync.RWMutex
        lockLastUpdated sync.RWMutex
        lockLoad        sync.RWMutex
        lockSave        sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *SettingsStoreMock) Delete(ctx context.Context) error <span class="cov6" title="3">{
        if mock.DeleteFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.DeleteFunc: method is nil but SettingsStore.Delete was just called")</span>
        }
        <span class="cov6" title="3">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockDelete.Lock()
        mock.calls.Delete = append(mock.calls.Delete, callInfo)
        mock.lockDelete.Unlock()
        return mock.DeleteFunc(ctx)</span>
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//        len(mockedSettingsStore.DeleteCalls())
func (mock *SettingsStoreMock) DeleteCalls() []struct {
        Ctx context.Context
} <span class="cov6" title="3">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockDelete.RLock()
        calls = mock.calls.Delete
        mock.lockDelete.RUnlock()
        return calls
}</span>

// ResetDeleteCalls reset all the calls that were made to Delete.
func (mock *SettingsStoreMock) ResetDeleteCalls() <span class="cov0" title="0">{
        mock.lockDelete.Lock()
        mock.calls.Delete = nil
        mock.lockDelete.Unlock()
}</span>

// Exists calls ExistsFunc.
func (mock *SettingsStoreMock) Exists(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        if mock.ExistsFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.ExistsFunc: method is nil but SettingsStore.Exists was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockExists.Lock()
        mock.calls.Exists = append(mock.calls.Exists, callInfo)
        mock.lockExists.Unlock()
        return mock.ExistsFunc(ctx)</span>
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//        len(mockedSettingsStore.ExistsCalls())
func (mock *SettingsStoreMock) ExistsCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockExists.RLock()
        calls = mock.calls.Exists
        mock.lockExists.RUnlock()
        return calls
}</span>

// ResetExistsCalls reset all the calls that were made to Exists.
func (mock *SettingsStoreMock) ResetExistsCalls() <span class="cov0" title="0">{
        mock.lockExists.Lock()
        mock.calls.Exists = nil
        mock.lockExists.Unlock()
}</span>

// LastUpdated calls LastUpdatedFunc.
func (mock *SettingsStoreMock) LastUpdated(ctx context.Context) (time.Time, error) <span class="cov0" title="0">{
        if mock.LastUpdatedFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.LastUpdatedFunc: method is nil but SettingsStore.LastUpdated was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockLastUpdated.Lock()
        mock.calls.LastUpdated = append(mock.calls.LastUpdated, callInfo)
        mock.lockLastUpdated.Unlock()
        return mock.LastUpdatedFunc(ctx)</span>
}

// LastUpdatedCalls gets all the calls that were made to LastUpdated.
// Check the length with:
//
//        len(mockedSettingsStore.LastUpdatedCalls())
func (mock *SettingsStoreMock) LastUpdatedCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockLastUpdated.RLock()
        calls = mock.calls.LastUpdated
        mock.lockLastUpdated.RUnlock()
        return calls
}</span>

// ResetLastUpdatedCalls reset all the calls that were made to LastUpdated.
func (mock *SettingsStoreMock) ResetLastUpdatedCalls() <span class="cov0" title="0">{
        mock.lockLastUpdated.Lock()
        mock.calls.LastUpdated = nil
        mock.lockLastUpdated.Unlock()
}</span>

// Load calls LoadFunc.
func (mock *SettingsStoreMock) Load(ctx context.Context) (*config.Settings, error) <span class="cov7" title="4">{
        if mock.LoadFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.LoadFunc: method is nil but SettingsStore.Load was just called")</span>
        }
        <span class="cov7" title="4">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockLoad.Lock()
        mock.calls.Load = append(mock.calls.Load, callInfo)
        mock.lockLoad.Unlock()
        return mock.LoadFunc(ctx)</span>
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//        len(mockedSettingsStore.LoadCalls())
func (mock *SettingsStoreMock) LoadCalls() []struct {
        Ctx context.Context
} <span class="cov7" title="4">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockLoad.RLock()
        calls = mock.calls.Load
        mock.lockLoad.RUnlock()
        return calls
}</span>

// ResetLoadCalls reset all the calls that were made to Load.
func (mock *SettingsStoreMock) ResetLoadCalls() <span class="cov0" title="0">{
        mock.lockLoad.Lock()
        mock.calls.Load = nil
        mock.lockLoad.Unlock()
}</span>

// Save calls SaveFunc.
func (mock *SettingsStoreMock) Save(ctx context.Context, settings *config.Settings) error <span class="cov8" title="5">{
        if mock.SaveFunc == nil </span><span class="cov0" title="0">{
                panic("SettingsStoreMock.SaveFunc: method is nil but SettingsStore.Save was just called")</span>
        }
        <span class="cov8" title="5">callInfo := struct {
                Ctx      context.Context
                Settings *config.Settings
        }{
                Ctx:      ctx,
                Settings: settings,
        }
        mock.lockSave.Lock()
        mock.calls.Save = append(mock.calls.Save, callInfo)
        mock.lockSave.Unlock()
        return mock.SaveFunc(ctx, settings)</span>
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//        len(mockedSettingsStore.SaveCalls())
func (mock *SettingsStoreMock) SaveCalls() []struct {
        Ctx      context.Context
        Settings *config.Settings
} <span class="cov10" title="7">{
        var calls []struct {
                Ctx      context.Context
                Settings *config.Settings
        }
        mock.lockSave.RLock()
        calls = mock.calls.Save
        mock.lockSave.RUnlock()
        return calls
}</span>

// ResetSaveCalls reset all the calls that were made to Save.
func (mock *SettingsStoreMock) ResetSaveCalls() <span class="cov0" title="0">{
        mock.lockSave.Lock()
        mock.calls.Save = nil
        mock.lockSave.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SettingsStoreMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockDelete.Lock()
        mock.calls.Delete = nil
        mock.lockDelete.Unlock()

        mock.lockExists.Lock()
        mock.calls.Exists = nil
        mock.lockExists.Unlock()

        mock.lockLastUpdated.Lock()
        mock.calls.LastUpdated = nil
        mock.lockLastUpdated.Unlock()

        mock.lockLoad.Lock()
        mock.calls.Load = nil
        mock.lockLoad.Unlock()

        mock.lockSave.Lock()
        mock.calls.Save = nil
        mock.lockSave.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/umputun/tg-spam/app/storage"
        "sync"
)

// DetectedSpamMock is a mock implementation of webapi.DetectedSpam.
//
//        func TestSomethingThatUsesDetectedSpam(t *testing.T) {
//
//                // make and configure a mocked webapi.DetectedSpam
//                mockedDetectedSpam := &amp;DetectedSpamMock{
//                        FindByUserIDFunc: func(ctx context.Context, userID int64) (*storage.DetectedSpamInfo, error) {
//                                panic("mock out the FindByUserID method")
//                        },
//                        ReadFunc: func(ctx context.Context) ([]storage.DetectedSpamInfo, error) {
//                                panic("mock out the Read method")
//                        },
//                        SetAddedToSamplesFlagFunc: func(ctx context.Context, id int64) error {
//                                panic("mock out the SetAddedToSamplesFlag method")
//                        },
//                }
//
//                // use mockedDetectedSpam in code that requires webapi.DetectedSpam
//                // and then make assertions.
//
//        }
type DetectedSpamMock struct {
        // FindByUserIDFunc mocks the FindByUserID method.
        FindByUserIDFunc func(ctx context.Context, userID int64) (*storage.DetectedSpamInfo, error)

        // ReadFunc mocks the Read method.
        ReadFunc func(ctx context.Context) ([]storage.DetectedSpamInfo, error)

        // SetAddedToSamplesFlagFunc mocks the SetAddedToSamplesFlag method.
        SetAddedToSamplesFlagFunc func(ctx context.Context, id int64) error

        // calls tracks calls to the methods.
        calls struct {
                // FindByUserID holds details about calls to the FindByUserID method.
                FindByUserID []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // UserID is the userID argument value.
                        UserID int64
                }
                // Read holds details about calls to the Read method.
                Read []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // SetAddedToSamplesFlag holds details about calls to the SetAddedToSamplesFlag method.
                SetAddedToSamplesFlag []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // ID is the id argument value.
                        ID int64
                }
        }
        lockFindByUserID          sync.RWMutex
        lockRead                  sync.RWMutex
        lockSetAddedToSamplesFlag sync.RWMutex
}

// FindByUserID calls FindByUserIDFunc.
func (mock *DetectedSpamMock) FindByUserID(ctx context.Context, userID int64) (*storage.DetectedSpamInfo, error) <span class="cov0" title="0">{
        if mock.FindByUserIDFunc == nil </span><span class="cov0" title="0">{
                panic("DetectedSpamMock.FindByUserIDFunc: method is nil but DetectedSpam.FindByUserID was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx    context.Context
                UserID int64
        }{
                Ctx:    ctx,
                UserID: userID,
        }
        mock.lockFindByUserID.Lock()
        mock.calls.FindByUserID = append(mock.calls.FindByUserID, callInfo)
        mock.lockFindByUserID.Unlock()
        return mock.FindByUserIDFunc(ctx, userID)</span>
}

// FindByUserIDCalls gets all the calls that were made to FindByUserID.
// Check the length with:
//
//        len(mockedDetectedSpam.FindByUserIDCalls())
func (mock *DetectedSpamMock) FindByUserIDCalls() []struct {
        Ctx    context.Context
        UserID int64
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx    context.Context
                UserID int64
        }
        mock.lockFindByUserID.RLock()
        calls = mock.calls.FindByUserID
        mock.lockFindByUserID.RUnlock()
        return calls
}</span>

// ResetFindByUserIDCalls reset all the calls that were made to FindByUserID.
func (mock *DetectedSpamMock) ResetFindByUserIDCalls() <span class="cov0" title="0">{
        mock.lockFindByUserID.Lock()
        mock.calls.FindByUserID = nil
        mock.lockFindByUserID.Unlock()
}</span>

// Read calls ReadFunc.
func (mock *DetectedSpamMock) Read(ctx context.Context) ([]storage.DetectedSpamInfo, error) <span class="cov0" title="0">{
        if mock.ReadFunc == nil </span><span class="cov0" title="0">{
                panic("DetectedSpamMock.ReadFunc: method is nil but DetectedSpam.Read was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockRead.Lock()
        mock.calls.Read = append(mock.calls.Read, callInfo)
        mock.lockRead.Unlock()
        return mock.ReadFunc(ctx)</span>
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//        len(mockedDetectedSpam.ReadCalls())
func (mock *DetectedSpamMock) ReadCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockRead.RLock()
        calls = mock.calls.Read
        mock.lockRead.RUnlock()
        return calls
}</span>

// ResetReadCalls reset all the calls that were made to Read.
func (mock *DetectedSpamMock) ResetReadCalls() <span class="cov0" title="0">{
        mock.lockRead.Lock()
        mock.calls.Read = nil
        mock.lockRead.Unlock()
}</span>

// SetAddedToSamplesFlag calls SetAddedToSamplesFlagFunc.
func (mock *DetectedSpamMock) SetAddedToSamplesFlag(ctx context.Context, id int64) error <span class="cov0" title="0">{
        if mock.SetAddedToSamplesFlagFunc == nil </span><span class="cov0" title="0">{
                panic("DetectedSpamMock.SetAddedToSamplesFlagFunc: method is nil but DetectedSpam.SetAddedToSamplesFlag was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                ID  int64
        }{
                Ctx: ctx,
                ID:  id,
        }
        mock.lockSetAddedToSamplesFlag.Lock()
        mock.calls.SetAddedToSamplesFlag = append(mock.calls.SetAddedToSamplesFlag, callInfo)
        mock.lockSetAddedToSamplesFlag.Unlock()
        return mock.SetAddedToSamplesFlagFunc(ctx, id)</span>
}

// SetAddedToSamplesFlagCalls gets all the calls that were made to SetAddedToSamplesFlag.
// Check the length with:
//
//        len(mockedDetectedSpam.SetAddedToSamplesFlagCalls())
func (mock *DetectedSpamMock) SetAddedToSamplesFlagCalls() []struct {
        Ctx context.Context
        ID  int64
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                ID  int64
        }
        mock.lockSetAddedToSamplesFlag.RLock()
        calls = mock.calls.SetAddedToSamplesFlag
        mock.lockSetAddedToSamplesFlag.RUnlock()
        return calls
}</span>

// ResetSetAddedToSamplesFlagCalls reset all the calls that were made to SetAddedToSamplesFlag.
func (mock *DetectedSpamMock) ResetSetAddedToSamplesFlagCalls() <span class="cov0" title="0">{
        mock.lockSetAddedToSamplesFlag.Lock()
        mock.calls.SetAddedToSamplesFlag = nil
        mock.lockSetAddedToSamplesFlag.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *DetectedSpamMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockFindByUserID.Lock()
        mock.calls.FindByUserID = nil
        mock.lockFindByUserID.Unlock()

        mock.lockRead.Lock()
        mock.calls.Read = nil
        mock.lockRead.Unlock()

        mock.lockSetAddedToSamplesFlag.Lock()
        mock.calls.SetAddedToSamplesFlag = nil
        mock.lockSetAddedToSamplesFlag.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "github.com/umputun/tg-spam/lib/approved"
        "github.com/umputun/tg-spam/lib/spamcheck"
        "sync"
)

// DetectorMock is a mock implementation of webapi.Detector.
//
//        func TestSomethingThatUsesDetector(t *testing.T) {
//
//                // make and configure a mocked webapi.Detector
//                mockedDetector := &amp;DetectorMock{
//                        AddApprovedUserFunc: func(user approved.UserInfo) error {
//                                panic("mock out the AddApprovedUser method")
//                        },
//                        ApprovedUsersFunc: func() []approved.UserInfo {
//                                panic("mock out the ApprovedUsers method")
//                        },
//                        CheckFunc: func(req spamcheck.Request) (bool, []spamcheck.Response) {
//                                panic("mock out the Check method")
//                        },
//                        GetLuaPluginNamesFunc: func() []string {
//                                panic("mock out the GetLuaPluginNames method")
//                        },
//                        RemoveApprovedUserFunc: func(id string) error {
//                                panic("mock out the RemoveApprovedUser method")
//                        },
//                }
//
//                // use mockedDetector in code that requires webapi.Detector
//                // and then make assertions.
//
//        }
type DetectorMock struct {
        // AddApprovedUserFunc mocks the AddApprovedUser method.
        AddApprovedUserFunc func(user approved.UserInfo) error

        // ApprovedUsersFunc mocks the ApprovedUsers method.
        ApprovedUsersFunc func() []approved.UserInfo

        // CheckFunc mocks the Check method.
        CheckFunc func(req spamcheck.Request) (bool, []spamcheck.Response)

        // GetLuaPluginNamesFunc mocks the GetLuaPluginNames method.
        GetLuaPluginNamesFunc func() []string

        // RemoveApprovedUserFunc mocks the RemoveApprovedUser method.
        RemoveApprovedUserFunc func(id string) error

        // calls tracks calls to the methods.
        calls struct {
                // AddApprovedUser holds details about calls to the AddApprovedUser method.
                AddApprovedUser []struct {
                        // User is the user argument value.
                        User approved.UserInfo
                }
                // ApprovedUsers holds details about calls to the ApprovedUsers method.
                ApprovedUsers []struct {
                }
                // Check holds details about calls to the Check method.
                Check []struct {
                        // Req is the req argument value.
                        Req spamcheck.Request
                }
                // GetLuaPluginNames holds details about calls to the GetLuaPluginNames method.
                GetLuaPluginNames []struct {
                }
                // RemoveApprovedUser holds details about calls to the RemoveApprovedUser method.
                RemoveApprovedUser []struct {
                        // ID is the id argument value.
                        ID string
                }
        }
        lockAddApprovedUser    sync.RWMutex
        lockApprovedUsers      sync.RWMutex
        lockCheck              sync.RWMutex
        lockGetLuaPluginNames  sync.RWMutex
        lockRemoveApprovedUser sync.RWMutex
}

// AddApprovedUser calls AddApprovedUserFunc.
func (mock *DetectorMock) AddApprovedUser(user approved.UserInfo) error <span class="cov0" title="0">{
        if mock.AddApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.AddApprovedUserFunc: method is nil but Detector.AddApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                User approved.UserInfo
        }{
                User: user,
        }
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = append(mock.calls.AddApprovedUser, callInfo)
        mock.lockAddApprovedUser.Unlock()
        return mock.AddApprovedUserFunc(user)</span>
}

// AddApprovedUserCalls gets all the calls that were made to AddApprovedUser.
// Check the length with:
//
//        len(mockedDetector.AddApprovedUserCalls())
func (mock *DetectorMock) AddApprovedUserCalls() []struct {
        User approved.UserInfo
} <span class="cov0" title="0">{
        var calls []struct {
                User approved.UserInfo
        }
        mock.lockAddApprovedUser.RLock()
        calls = mock.calls.AddApprovedUser
        mock.lockAddApprovedUser.RUnlock()
        return calls
}</span>

// ResetAddApprovedUserCalls reset all the calls that were made to AddApprovedUser.
func (mock *DetectorMock) ResetAddApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = nil
        mock.lockAddApprovedUser.Unlock()
}</span>

// ApprovedUsers calls ApprovedUsersFunc.
func (mock *DetectorMock) ApprovedUsers() []approved.UserInfo <span class="cov0" title="0">{
        if mock.ApprovedUsersFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.ApprovedUsersFunc: method is nil but Detector.ApprovedUsers was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockApprovedUsers.Lock()
        mock.calls.ApprovedUsers = append(mock.calls.ApprovedUsers, callInfo)
        mock.lockApprovedUsers.Unlock()
        return mock.ApprovedUsersFunc()</span>
}

// ApprovedUsersCalls gets all the calls that were made to ApprovedUsers.
// Check the length with:
//
//        len(mockedDetector.ApprovedUsersCalls())
func (mock *DetectorMock) ApprovedUsersCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockApprovedUsers.RLock()
        calls = mock.calls.ApprovedUsers
        mock.lockApprovedUsers.RUnlock()
        return calls
}</span>

// ResetApprovedUsersCalls reset all the calls that were made to ApprovedUsers.
func (mock *DetectorMock) ResetApprovedUsersCalls() <span class="cov0" title="0">{
        mock.lockApprovedUsers.Lock()
        mock.calls.ApprovedUsers = nil
        mock.lockApprovedUsers.Unlock()
}</span>

// Check calls CheckFunc.
func (mock *DetectorMock) Check(req spamcheck.Request) (bool, []spamcheck.Response) <span class="cov0" title="0">{
        if mock.CheckFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.CheckFunc: method is nil but Detector.Check was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Req spamcheck.Request
        }{
                Req: req,
        }
        mock.lockCheck.Lock()
        mock.calls.Check = append(mock.calls.Check, callInfo)
        mock.lockCheck.Unlock()
        return mock.CheckFunc(req)</span>
}

// CheckCalls gets all the calls that were made to Check.
// Check the length with:
//
//        len(mockedDetector.CheckCalls())
func (mock *DetectorMock) CheckCalls() []struct {
        Req spamcheck.Request
} <span class="cov0" title="0">{
        var calls []struct {
                Req spamcheck.Request
        }
        mock.lockCheck.RLock()
        calls = mock.calls.Check
        mock.lockCheck.RUnlock()
        return calls
}</span>

// ResetCheckCalls reset all the calls that were made to Check.
func (mock *DetectorMock) ResetCheckCalls() <span class="cov0" title="0">{
        mock.lockCheck.Lock()
        mock.calls.Check = nil
        mock.lockCheck.Unlock()
}</span>

// GetLuaPluginNames calls GetLuaPluginNamesFunc.
func (mock *DetectorMock) GetLuaPluginNames() []string <span class="cov0" title="0">{
        if mock.GetLuaPluginNamesFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.GetLuaPluginNamesFunc: method is nil but Detector.GetLuaPluginNames was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockGetLuaPluginNames.Lock()
        mock.calls.GetLuaPluginNames = append(mock.calls.GetLuaPluginNames, callInfo)
        mock.lockGetLuaPluginNames.Unlock()
        return mock.GetLuaPluginNamesFunc()</span>
}

// GetLuaPluginNamesCalls gets all the calls that were made to GetLuaPluginNames.
// Check the length with:
//
//        len(mockedDetector.GetLuaPluginNamesCalls())
func (mock *DetectorMock) GetLuaPluginNamesCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockGetLuaPluginNames.RLock()
        calls = mock.calls.GetLuaPluginNames
        mock.lockGetLuaPluginNames.RUnlock()
        return calls
}</span>

// ResetGetLuaPluginNamesCalls reset all the calls that were made to GetLuaPluginNames.
func (mock *DetectorMock) ResetGetLuaPluginNamesCalls() <span class="cov0" title="0">{
        mock.lockGetLuaPluginNames.Lock()
        mock.calls.GetLuaPluginNames = nil
        mock.lockGetLuaPluginNames.Unlock()
}</span>

// RemoveApprovedUser calls RemoveApprovedUserFunc.
func (mock *DetectorMock) RemoveApprovedUser(id string) error <span class="cov0" title="0">{
        if mock.RemoveApprovedUserFunc == nil </span><span class="cov0" title="0">{
                panic("DetectorMock.RemoveApprovedUserFunc: method is nil but Detector.RemoveApprovedUser was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                ID string
        }{
                ID: id,
        }
        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = append(mock.calls.RemoveApprovedUser, callInfo)
        mock.lockRemoveApprovedUser.Unlock()
        return mock.RemoveApprovedUserFunc(id)</span>
}

// RemoveApprovedUserCalls gets all the calls that were made to RemoveApprovedUser.
// Check the length with:
//
//        len(mockedDetector.RemoveApprovedUserCalls())
func (mock *DetectorMock) RemoveApprovedUserCalls() []struct {
        ID string
} <span class="cov0" title="0">{
        var calls []struct {
                ID string
        }
        mock.lockRemoveApprovedUser.RLock()
        calls = mock.calls.RemoveApprovedUser
        mock.lockRemoveApprovedUser.RUnlock()
        return calls
}</span>

// ResetRemoveApprovedUserCalls reset all the calls that were made to RemoveApprovedUser.
func (mock *DetectorMock) ResetRemoveApprovedUserCalls() <span class="cov0" title="0">{
        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = nil
        mock.lockRemoveApprovedUser.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *DetectorMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockAddApprovedUser.Lock()
        mock.calls.AddApprovedUser = nil
        mock.lockAddApprovedUser.Unlock()

        mock.lockApprovedUsers.Lock()
        mock.calls.ApprovedUsers = nil
        mock.lockApprovedUsers.Unlock()

        mock.lockCheck.Lock()
        mock.calls.Check = nil
        mock.lockCheck.Unlock()

        mock.lockGetLuaPluginNames.Lock()
        mock.calls.GetLuaPluginNames = nil
        mock.lockGetLuaPluginNames.Unlock()

        mock.lockRemoveApprovedUser.Lock()
        mock.calls.RemoveApprovedUser = nil
        mock.lockRemoveApprovedUser.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "sync"
)

// LocatorMock is a mock implementation of webapi.Locator.
//
//        func TestSomethingThatUsesLocator(t *testing.T) {
//
//                // make and configure a mocked webapi.Locator
//                mockedLocator := &amp;LocatorMock{
//                        UserIDByNameFunc: func(ctx context.Context, userName string) int64 {
//                                panic("mock out the UserIDByName method")
//                        },
//                        UserNameByIDFunc: func(ctx context.Context, userID int64) string {
//                                panic("mock out the UserNameByID method")
//                        },
//                }
//
//                // use mockedLocator in code that requires webapi.Locator
//                // and then make assertions.
//
//        }
type LocatorMock struct {
        // UserIDByNameFunc mocks the UserIDByName method.
        UserIDByNameFunc func(ctx context.Context, userName string) int64

        // UserNameByIDFunc mocks the UserNameByID method.
        UserNameByIDFunc func(ctx context.Context, userID int64) string

        // calls tracks calls to the methods.
        calls struct {
                // UserIDByName holds details about calls to the UserIDByName method.
                UserIDByName []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // UserName is the userName argument value.
                        UserName string
                }
                // UserNameByID holds details about calls to the UserNameByID method.
                UserNameByID []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // UserID is the userID argument value.
                        UserID int64
                }
        }
        lockUserIDByName sync.RWMutex
        lockUserNameByID sync.RWMutex
}

// UserIDByName calls UserIDByNameFunc.
func (mock *LocatorMock) UserIDByName(ctx context.Context, userName string) int64 <span class="cov0" title="0">{
        if mock.UserIDByNameFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.UserIDByNameFunc: method is nil but Locator.UserIDByName was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx      context.Context
                UserName string
        }{
                Ctx:      ctx,
                UserName: userName,
        }
        mock.lockUserIDByName.Lock()
        mock.calls.UserIDByName = append(mock.calls.UserIDByName, callInfo)
        mock.lockUserIDByName.Unlock()
        return mock.UserIDByNameFunc(ctx, userName)</span>
}

// UserIDByNameCalls gets all the calls that were made to UserIDByName.
// Check the length with:
//
//        len(mockedLocator.UserIDByNameCalls())
func (mock *LocatorMock) UserIDByNameCalls() []struct {
        Ctx      context.Context
        UserName string
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx      context.Context
                UserName string
        }
        mock.lockUserIDByName.RLock()
        calls = mock.calls.UserIDByName
        mock.lockUserIDByName.RUnlock()
        return calls
}</span>

// ResetUserIDByNameCalls reset all the calls that were made to UserIDByName.
func (mock *LocatorMock) ResetUserIDByNameCalls() <span class="cov0" title="0">{
        mock.lockUserIDByName.Lock()
        mock.calls.UserIDByName = nil
        mock.lockUserIDByName.Unlock()
}</span>

// UserNameByID calls UserNameByIDFunc.
func (mock *LocatorMock) UserNameByID(ctx context.Context, userID int64) string <span class="cov0" title="0">{
        if mock.UserNameByIDFunc == nil </span><span class="cov0" title="0">{
                panic("LocatorMock.UserNameByIDFunc: method is nil but Locator.UserNameByID was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx    context.Context
                UserID int64
        }{
                Ctx:    ctx,
                UserID: userID,
        }
        mock.lockUserNameByID.Lock()
        mock.calls.UserNameByID = append(mock.calls.UserNameByID, callInfo)
        mock.lockUserNameByID.Unlock()
        return mock.UserNameByIDFunc(ctx, userID)</span>
}

// UserNameByIDCalls gets all the calls that were made to UserNameByID.
// Check the length with:
//
//        len(mockedLocator.UserNameByIDCalls())
func (mock *LocatorMock) UserNameByIDCalls() []struct {
        Ctx    context.Context
        UserID int64
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx    context.Context
                UserID int64
        }
        mock.lockUserNameByID.RLock()
        calls = mock.calls.UserNameByID
        mock.lockUserNameByID.RUnlock()
        return calls
}</span>

// ResetUserNameByIDCalls reset all the calls that were made to UserNameByID.
func (mock *LocatorMock) ResetUserNameByIDCalls() <span class="cov0" title="0">{
        mock.lockUserNameByID.Lock()
        mock.calls.UserNameByID = nil
        mock.lockUserNameByID.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *LocatorMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockUserIDByName.Lock()
        mock.calls.UserIDByName = nil
        mock.lockUserIDByName.Unlock()

        mock.lockUserNameByID.Lock()
        mock.calls.UserNameByID = nil
        mock.lockUserNameByID.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "sync"
)

// SpamFilterMock is a mock implementation of webapi.SpamFilter.
//
//        func TestSomethingThatUsesSpamFilter(t *testing.T) {
//
//                // make and configure a mocked webapi.SpamFilter
//                mockedSpamFilter := &amp;SpamFilterMock{
//                        DynamicSamplesFunc: func() ([]string, []string, error) {
//                                panic("mock out the DynamicSamples method")
//                        },
//                        ReloadSamplesFunc: func() error {
//                                panic("mock out the ReloadSamples method")
//                        },
//                        RemoveDynamicHamSampleFunc: func(sample string) error {
//                                panic("mock out the RemoveDynamicHamSample method")
//                        },
//                        RemoveDynamicSpamSampleFunc: func(sample string) error {
//                                panic("mock out the RemoveDynamicSpamSample method")
//                        },
//                        UpdateHamFunc: func(msg string) error {
//                                panic("mock out the UpdateHam method")
//                        },
//                        UpdateSpamFunc: func(msg string) error {
//                                panic("mock out the UpdateSpam method")
//                        },
//                }
//
//                // use mockedSpamFilter in code that requires webapi.SpamFilter
//                // and then make assertions.
//
//        }
type SpamFilterMock struct {
        // DynamicSamplesFunc mocks the DynamicSamples method.
        DynamicSamplesFunc func() ([]string, []string, error)

        // ReloadSamplesFunc mocks the ReloadSamples method.
        ReloadSamplesFunc func() error

        // RemoveDynamicHamSampleFunc mocks the RemoveDynamicHamSample method.
        RemoveDynamicHamSampleFunc func(sample string) error

        // RemoveDynamicSpamSampleFunc mocks the RemoveDynamicSpamSample method.
        RemoveDynamicSpamSampleFunc func(sample string) error

        // UpdateHamFunc mocks the UpdateHam method.
        UpdateHamFunc func(msg string) error

        // UpdateSpamFunc mocks the UpdateSpam method.
        UpdateSpamFunc func(msg string) error

        // calls tracks calls to the methods.
        calls struct {
                // DynamicSamples holds details about calls to the DynamicSamples method.
                DynamicSamples []struct {
                }
                // ReloadSamples holds details about calls to the ReloadSamples method.
                ReloadSamples []struct {
                }
                // RemoveDynamicHamSample holds details about calls to the RemoveDynamicHamSample method.
                RemoveDynamicHamSample []struct {
                        // Sample is the sample argument value.
                        Sample string
                }
                // RemoveDynamicSpamSample holds details about calls to the RemoveDynamicSpamSample method.
                RemoveDynamicSpamSample []struct {
                        // Sample is the sample argument value.
                        Sample string
                }
                // UpdateHam holds details about calls to the UpdateHam method.
                UpdateHam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // UpdateSpam holds details about calls to the UpdateSpam method.
                UpdateSpam []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
        }
        lockDynamicSamples          sync.RWMutex
        lockReloadSamples           sync.RWMutex
        lockRemoveDynamicHamSample  sync.RWMutex
        lockRemoveDynamicSpamSample sync.RWMutex
        lockUpdateHam               sync.RWMutex
        lockUpdateSpam              sync.RWMutex
}

// DynamicSamples calls DynamicSamplesFunc.
func (mock *SpamFilterMock) DynamicSamples() ([]string, []string, error) <span class="cov0" title="0">{
        if mock.DynamicSamplesFunc == nil </span><span class="cov0" title="0">{
                panic("SpamFilterMock.DynamicSamplesFunc: method is nil but SpamFilter.DynamicSamples was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockDynamicSamples.Lock()
        mock.calls.DynamicSamples = append(mock.calls.DynamicSamples, callInfo)
        mock.lockDynamicSamples.Unlock()
        return mock.DynamicSamplesFunc()</span>
}

// DynamicSamplesCalls gets all the calls that were made to DynamicSamples.
// Check the length with:
//
//        len(mockedSpamFilter.DynamicSamplesCalls())
func (mock *SpamFilterMock) DynamicSamplesCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockDynamicSamples.RLock()
        calls = mock.calls.DynamicSamples
        mock.lockDynamicSamples.RUnlock()
        return calls
}</span>

// ResetDynamicSamplesCalls reset all the calls that were made to DynamicSamples.
func (mock *SpamFilterMock) ResetDynamicSamplesCalls() <span class="cov0" title="0">{
        mock.lockDynamicSamples.Lock()
        mock.calls.DynamicSamples = nil
        mock.lockDynamicSamples.Unlock()
}</span>

// ReloadSamples calls ReloadSamplesFunc.
func (mock *SpamFilterMock) ReloadSamples() error <span class="cov0" title="0">{
        if mock.ReloadSamplesFunc == nil </span><span class="cov0" title="0">{
                panic("SpamFilterMock.ReloadSamplesFunc: method is nil but SpamFilter.ReloadSamples was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockReloadSamples.Lock()
        mock.calls.ReloadSamples = append(mock.calls.ReloadSamples, callInfo)
        mock.lockReloadSamples.Unlock()
        return mock.ReloadSamplesFunc()</span>
}

// ReloadSamplesCalls gets all the calls that were made to ReloadSamples.
// Check the length with:
//
//        len(mockedSpamFilter.ReloadSamplesCalls())
func (mock *SpamFilterMock) ReloadSamplesCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockReloadSamples.RLock()
        calls = mock.calls.ReloadSamples
        mock.lockReloadSamples.RUnlock()
        return calls
}</span>

// ResetReloadSamplesCalls reset all the calls that were made to ReloadSamples.
func (mock *SpamFilterMock) ResetReloadSamplesCalls() <span class="cov0" title="0">{
        mock.lockReloadSamples.Lock()
        mock.calls.ReloadSamples = nil
        mock.lockReloadSamples.Unlock()
}</span>

// RemoveDynamicHamSample calls RemoveDynamicHamSampleFunc.
func (mock *SpamFilterMock) RemoveDynamicHamSample(sample string) error <span class="cov0" title="0">{
        if mock.RemoveDynamicHamSampleFunc == nil </span><span class="cov0" title="0">{
                panic("SpamFilterMock.RemoveDynamicHamSampleFunc: method is nil but SpamFilter.RemoveDynamicHamSample was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Sample string
        }{
                Sample: sample,
        }
        mock.lockRemoveDynamicHamSample.Lock()
        mock.calls.RemoveDynamicHamSample = append(mock.calls.RemoveDynamicHamSample, callInfo)
        mock.lockRemoveDynamicHamSample.Unlock()
        return mock.RemoveDynamicHamSampleFunc(sample)</span>
}

// RemoveDynamicHamSampleCalls gets all the calls that were made to RemoveDynamicHamSample.
// Check the length with:
//
//        len(mockedSpamFilter.RemoveDynamicHamSampleCalls())
func (mock *SpamFilterMock) RemoveDynamicHamSampleCalls() []struct {
        Sample string
} <span class="cov0" title="0">{
        var calls []struct {
                Sample string
        }
        mock.lockRemoveDynamicHamSample.RLock()
        calls = mock.calls.RemoveDynamicHamSample
        mock.lockRemoveDynamicHamSample.RUnlock()
        return calls
}</span>

// ResetRemoveDynamicHamSampleCalls reset all the calls that were made to RemoveDynamicHamSample.
func (mock *SpamFilterMock) ResetRemoveDynamicHamSampleCalls() <span class="cov0" title="0">{
        mock.lockRemoveDynamicHamSample.Lock()
        mock.calls.RemoveDynamicHamSample = nil
        mock.lockRemoveDynamicHamSample.Unlock()
}</span>

// RemoveDynamicSpamSample calls RemoveDynamicSpamSampleFunc.
func (mock *SpamFilterMock) RemoveDynamicSpamSample(sample string) error <span class="cov0" title="0">{
        if mock.RemoveDynamicSpamSampleFunc == nil </span><span class="cov0" title="0">{
                panic("SpamFilterMock.RemoveDynamicSpamSampleFunc: method is nil but SpamFilter.RemoveDynamicSpamSample was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Sample string
        }{
                Sample: sample,
        }
        mock.lockRemoveDynamicSpamSample.Lock()
        mock.calls.RemoveDynamicSpamSample = append(mock.calls.RemoveDynamicSpamSample, callInfo)
        mock.lockRemoveDynamicSpamSample.Unlock()
        return mock.RemoveDynamicSpamSampleFunc(sample)</span>
}

// RemoveDynamicSpamSampleCalls gets all the calls that were made to RemoveDynamicSpamSample.
// Check the length with:
//
//        len(mockedSpamFilter.RemoveDynamicSpamSampleCalls())
func (mock *SpamFilterMock) RemoveDynamicSpamSampleCalls() []struct {
        Sample string
} <span class="cov0" title="0">{
        var calls []struct {
                Sample string
        }
        mock.lockRemoveDynamicSpamSample.RLock()
        calls = mock.calls.RemoveDynamicSpamSample
        mock.lockRemoveDynamicSpamSample.RUnlock()
        return calls
}</span>

// ResetRemoveDynamicSpamSampleCalls reset all the calls that were made to RemoveDynamicSpamSample.
func (mock *SpamFilterMock) ResetRemoveDynamicSpamSampleCalls() <span class="cov0" title="0">{
        mock.lockRemoveDynamicSpamSample.Lock()
        mock.calls.RemoveDynamicSpamSample = nil
        mock.lockRemoveDynamicSpamSample.Unlock()
}</span>

// UpdateHam calls UpdateHamFunc.
func (mock *SpamFilterMock) UpdateHam(msg string) error <span class="cov0" title="0">{
        if mock.UpdateHamFunc == nil </span><span class="cov0" title="0">{
                panic("SpamFilterMock.UpdateHamFunc: method is nil but SpamFilter.UpdateHam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = append(mock.calls.UpdateHam, callInfo)
        mock.lockUpdateHam.Unlock()
        return mock.UpdateHamFunc(msg)</span>
}

// UpdateHamCalls gets all the calls that were made to UpdateHam.
// Check the length with:
//
//        len(mockedSpamFilter.UpdateHamCalls())
func (mock *SpamFilterMock) UpdateHamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockUpdateHam.RLock()
        calls = mock.calls.UpdateHam
        mock.lockUpdateHam.RUnlock()
        return calls
}</span>

// ResetUpdateHamCalls reset all the calls that were made to UpdateHam.
func (mock *SpamFilterMock) ResetUpdateHamCalls() <span class="cov0" title="0">{
        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = nil
        mock.lockUpdateHam.Unlock()
}</span>

// UpdateSpam calls UpdateSpamFunc.
func (mock *SpamFilterMock) UpdateSpam(msg string) error <span class="cov0" title="0">{
        if mock.UpdateSpamFunc == nil </span><span class="cov0" title="0">{
                panic("SpamFilterMock.UpdateSpamFunc: method is nil but SpamFilter.UpdateSpam was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = append(mock.calls.UpdateSpam, callInfo)
        mock.lockUpdateSpam.Unlock()
        return mock.UpdateSpamFunc(msg)</span>
}

// UpdateSpamCalls gets all the calls that were made to UpdateSpam.
// Check the length with:
//
//        len(mockedSpamFilter.UpdateSpamCalls())
func (mock *SpamFilterMock) UpdateSpamCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockUpdateSpam.RLock()
        calls = mock.calls.UpdateSpam
        mock.lockUpdateSpam.RUnlock()
        return calls
}</span>

// ResetUpdateSpamCalls reset all the calls that were made to UpdateSpam.
func (mock *SpamFilterMock) ResetUpdateSpamCalls() <span class="cov0" title="0">{
        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = nil
        mock.lockUpdateSpam.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SpamFilterMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockDynamicSamples.Lock()
        mock.calls.DynamicSamples = nil
        mock.lockDynamicSamples.Unlock()

        mock.lockReloadSamples.Lock()
        mock.calls.ReloadSamples = nil
        mock.lockReloadSamples.Unlock()

        mock.lockRemoveDynamicHamSample.Lock()
        mock.calls.RemoveDynamicHamSample = nil
        mock.lockRemoveDynamicHamSample.Unlock()

        mock.lockRemoveDynamicSpamSample.Lock()
        mock.calls.RemoveDynamicSpamSample = nil
        mock.lockRemoveDynamicSpamSample.Unlock()

        mock.lockUpdateHam.Lock()
        mock.calls.UpdateHam = nil
        mock.lockUpdateHam.Unlock()

        mock.lockUpdateSpam.Lock()
        mock.calls.UpdateSpam = nil
        mock.lockUpdateSpam.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/umputun/tg-spam/app/storage/engine"
        "io"
        "sync"
)

// StorageEngineMock is a mock implementation of webapi.StorageEngine.
//
//        func TestSomethingThatUsesStorageEngine(t *testing.T) {
//
//                // make and configure a mocked webapi.StorageEngine
//                mockedStorageEngine := &amp;StorageEngineMock{
//                        BackupFunc: func(ctx context.Context, w io.Writer) error {
//                                panic("mock out the Backup method")
//                        },
//                        BackupSqliteAsPostgresFunc: func(ctx context.Context, w io.Writer) error {
//                                panic("mock out the BackupSqliteAsPostgres method")
//                        },
//                        TypeFunc: func() engine.Type {
//                                panic("mock out the Type method")
//                        },
//                }
//
//                // use mockedStorageEngine in code that requires webapi.StorageEngine
//                // and then make assertions.
//
//        }
type StorageEngineMock struct {
        // BackupFunc mocks the Backup method.
        BackupFunc func(ctx context.Context, w io.Writer) error

        // BackupSqliteAsPostgresFunc mocks the BackupSqliteAsPostgres method.
        BackupSqliteAsPostgresFunc func(ctx context.Context, w io.Writer) error

        // TypeFunc mocks the Type method.
        TypeFunc func() engine.Type

        // calls tracks calls to the methods.
        calls struct {
                // Backup holds details about calls to the Backup method.
                Backup []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // W is the w argument value.
                        W io.Writer
                }
                // BackupSqliteAsPostgres holds details about calls to the BackupSqliteAsPostgres method.
                BackupSqliteAsPostgres []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // W is the w argument value.
                        W io.Writer
                }
                // Type holds details about calls to the Type method.
                Type []struct {
                }
        }
        lockBackup                 sync.RWMutex
        lockBackupSqliteAsPostgres sync.RWMutex
        lockType                   sync.RWMutex
}

// Backup calls BackupFunc.
func (mock *StorageEngineMock) Backup(ctx context.Context, w io.Writer) error <span class="cov0" title="0">{
        if mock.BackupFunc == nil </span><span class="cov0" title="0">{
                panic("StorageEngineMock.BackupFunc: method is nil but StorageEngine.Backup was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                W   io.Writer
        }{
                Ctx: ctx,
                W:   w,
        }
        mock.lockBackup.Lock()
        mock.calls.Backup = append(mock.calls.Backup, callInfo)
        mock.lockBackup.Unlock()
        return mock.BackupFunc(ctx, w)</span>
}

// BackupCalls gets all the calls that were made to Backup.
// Check the length with:
//
//        len(mockedStorageEngine.BackupCalls())
func (mock *StorageEngineMock) BackupCalls() []struct {
        Ctx context.Context
        W   io.Writer
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                W   io.Writer
        }
        mock.lockBackup.RLock()
        calls = mock.calls.Backup
        mock.lockBackup.RUnlock()
        return calls
}</span>

// ResetBackupCalls reset all the calls that were made to Backup.
func (mock *StorageEngineMock) ResetBackupCalls() <span class="cov0" title="0">{
        mock.lockBackup.Lock()
        mock.calls.Backup = nil
        mock.lockBackup.Unlock()
}</span>

// BackupSqliteAsPostgres calls BackupSqliteAsPostgresFunc.
func (mock *StorageEngineMock) BackupSqliteAsPostgres(ctx context.Context, w io.Writer) error <span class="cov0" title="0">{
        if mock.BackupSqliteAsPostgresFunc == nil </span><span class="cov0" title="0">{
                panic("StorageEngineMock.BackupSqliteAsPostgresFunc: method is nil but StorageEngine.BackupSqliteAsPostgres was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                W   io.Writer
        }{
                Ctx: ctx,
                W:   w,
        }
        mock.lockBackupSqliteAsPostgres.Lock()
        mock.calls.BackupSqliteAsPostgres = append(mock.calls.BackupSqliteAsPostgres, callInfo)
        mock.lockBackupSqliteAsPostgres.Unlock()
        return mock.BackupSqliteAsPostgresFunc(ctx, w)</span>
}

// BackupSqliteAsPostgresCalls gets all the calls that were made to BackupSqliteAsPostgres.
// Check the length with:
//
//        len(mockedStorageEngine.BackupSqliteAsPostgresCalls())
func (mock *StorageEngineMock) BackupSqliteAsPostgresCalls() []struct {
        Ctx context.Context
        W   io.Writer
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                W   io.Writer
        }
        mock.lockBackupSqliteAsPostgres.RLock()
        calls = mock.calls.BackupSqliteAsPostgres
        mock.lockBackupSqliteAsPostgres.RUnlock()
        return calls
}</span>

// ResetBackupSqliteAsPostgresCalls reset all the calls that were made to BackupSqliteAsPostgres.
func (mock *StorageEngineMock) ResetBackupSqliteAsPostgresCalls() <span class="cov0" title="0">{
        mock.lockBackupSqliteAsPostgres.Lock()
        mock.calls.BackupSqliteAsPostgres = nil
        mock.lockBackupSqliteAsPostgres.Unlock()
}</span>

// Type calls TypeFunc.
func (mock *StorageEngineMock) Type() engine.Type <span class="cov0" title="0">{
        if mock.TypeFunc == nil </span><span class="cov0" title="0">{
                panic("StorageEngineMock.TypeFunc: method is nil but StorageEngine.Type was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockType.Lock()
        mock.calls.Type = append(mock.calls.Type, callInfo)
        mock.lockType.Unlock()
        return mock.TypeFunc()</span>
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//
//        len(mockedStorageEngine.TypeCalls())
func (mock *StorageEngineMock) TypeCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockType.RLock()
        calls = mock.calls.Type
        mock.lockType.RUnlock()
        return calls
}</span>

// ResetTypeCalls reset all the calls that were made to Type.
func (mock *StorageEngineMock) ResetTypeCalls() <span class="cov0" title="0">{
        mock.lockType.Lock()
        mock.calls.Type = nil
        mock.lockType.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *StorageEngineMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockBackup.Lock()
        mock.calls.Backup = nil
        mock.lockBackup.Unlock()

        mock.lockBackupSqliteAsPostgres.Lock()
        mock.calls.BackupSqliteAsPostgres = nil
        mock.lockBackupSqliteAsPostgres.Unlock()

        mock.lockType.Lock()
        mock.calls.Type = nil
        mock.lockType.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package webapi provides a web API spam detection service.
package webapi

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/rand"
        "crypto/sha1" //nolint
        "embed"
        "encoding/json"
        "errors"
        "fmt"
        "html/template"
        "io"
        "io/fs"
        "math/big"
        "net/http"
        "path"
        "strconv"
        "strings"
        "time"

        "github.com/didip/tollbooth/v8"
        log "github.com/go-pkgz/lgr"
        "github.com/go-pkgz/rest"
        "github.com/go-pkgz/rest/logger"
        "github.com/go-pkgz/routegroup"

        "github.com/umputun/tg-spam/app/config"
        "github.com/umputun/tg-spam/app/storage"
        "github.com/umputun/tg-spam/app/storage/engine"
        "github.com/umputun/tg-spam/lib/approved"
        "github.com/umputun/tg-spam/lib/spamcheck"
)

//go:generate moq --out mocks/detector.go --pkg mocks --with-resets --skip-ensure . Detector
//go:generate moq --out mocks/spam_filter.go --pkg mocks --with-resets --skip-ensure . SpamFilter
//go:generate moq --out mocks/locator.go --pkg mocks --with-resets --skip-ensure . Locator
//go:generate moq --out mocks/detected_spam.go --pkg mocks --with-resets --skip-ensure . DetectedSpam
//go:generate moq --out mocks/storage_engine.go --pkg mocks --with-resets --skip-ensure . StorageEngine

//go:embed assets/* assets/components/*
var templateFS embed.FS
var tmpl = template.Must(template.ParseFS(templateFS, "assets/*.html", "assets/components/*.html"))

// startTime tracks when the server started
var startTime = time.Now()

// Server is a web API server.
type Server struct {
        Config
}

// Config defines  server parameters
type Config struct {
        Version       string           // version to show in /ping
        ListenAddr    string           // listen address
        Detector      Detector         // spam detector
        SpamFilter    SpamFilter       // spam filter (bot)
        DetectedSpam  DetectedSpam     // detected spam accessor
        Locator       Locator          // locator for user info
        StorageEngine StorageEngine    // database engine access for backups
        SettingsStore SettingsStore    // configuration storage interface
        AuthUser      string           // basic auth username (default: "tg-spam")
        AuthPasswd    string           // basic auth password
        AuthHash      string           // basic auth hash. If both AuthPasswd and AuthHash are provided, AuthHash is used
        Dbg           bool             // debug mode
        AppSettings   *config.Settings // application settings
        ConfigDBMode  bool             // indicates if app is running with database config
}

// Settings contains all application settings
type Settings struct {
        InstanceID              string        `json:"instance_id"`
        PrimaryGroup            string        `json:"primary_group"`
        AdminGroup              string        `json:"admin_group"`
        DisableAdminSpamForward bool          `json:"disable_admin_spam_forward"`
        LoggerEnabled           bool          `json:"logger_enabled"`
        SuperUsers              []string      `json:"super_users"`
        NoSpamReply             bool          `json:"no_spam_reply"`
        CasEnabled              bool          `json:"cas_enabled"`
        MetaEnabled             bool          `json:"meta_enabled"`
        MetaLinksLimit          int           `json:"meta_links_limit"`
        MetaMentionsLimit       int           `json:"meta_mentions_limit"`
        MetaLinksOnly           bool          `json:"meta_links_only"`
        MetaImageOnly           bool          `json:"meta_image_only"`
        MetaVideoOnly           bool          `json:"meta_video_only"`
        MetaAudioOnly           bool          `json:"meta_audio_only"`
        MetaForwarded           bool          `json:"meta_forwarded"`
        MetaKeyboard            bool          `json:"meta_keyboard"`
        MetaUsernameSymbols     string        `json:"meta_username_symbols"`
        MultiLangLimit          int           `json:"multi_lang_limit"`
        OpenAIEnabled           bool          `json:"openai_enabled"`
        LuaPluginsEnabled       bool          `json:"lua_plugins_enabled"`
        LuaPluginsDir           string        `json:"lua_plugins_dir"`
        LuaEnabledPlugins       []string      `json:"lua_enabled_plugins"`
        LuaDynamicReload        bool          `json:"lua_dynamic_reload"`
        LuaAvailablePlugins     []string      `json:"lua_available_plugins"` // the list of all available Lua plugins
        SamplesDataPath         string        `json:"samples_data_path"`
        DynamicDataPath         string        `json:"dynamic_data_path"`
        WatchIntervalSecs       int           `json:"watch_interval_secs"`
        SimilarityThreshold     float64       `json:"similarity_threshold"`
        MinMsgLen               int           `json:"min_msg_len"`
        MaxEmoji                int           `json:"max_emoji"`
        MinSpamProbability      float64       `json:"min_spam_probability"`
        ParanoidMode            bool          `json:"paranoid_mode"`
        FirstMessagesCount      int           `json:"first_messages_count"`
        StartupMessageEnabled   bool          `json:"startup_message_enabled"`
        TrainingEnabled         bool          `json:"training_enabled"`
        StorageTimeout          time.Duration `json:"storage_timeout"`
        OpenAIVeto              bool          `json:"openai_veto"`
        OpenAIHistorySize       int           `json:"openai_history_size"`
        OpenAIModel             string        `json:"openai_model"`
        SoftBanEnabled          bool          `json:"soft_ban_enabled"`
        AbnormalSpacingEnabled  bool          `json:"abnormal_spacing_enabled"`
        HistorySize             int           `json:"history_size"`
        DebugModeEnabled        bool          `json:"debug_mode_enabled"`
        DryModeEnabled          bool          `json:"dry_mode_enabled"`
        TGDebugModeEnabled      bool          `json:"tg_debug_mode_enabled"`
}

// Detector is a spam detector interface.
type Detector interface {
        Check(req spamcheck.Request) (spam bool, cr []spamcheck.Response)
        ApprovedUsers() []approved.UserInfo
        AddApprovedUser(user approved.UserInfo) error
        RemoveApprovedUser(id string) error
        GetLuaPluginNames() []string // Returns the list of available Lua plugin names
}

// SpamFilter is a spam filter, bot interface.
type SpamFilter interface {
        UpdateSpam(msg string) error
        UpdateHam(msg string) error
        ReloadSamples() (err error)
        DynamicSamples() (spam, ham []string, err error)
        RemoveDynamicSpamSample(sample string) error
        RemoveDynamicHamSample(sample string) error
}

// Locator is a storage interface used to get user id by name and vice versa.
type Locator interface {
        UserIDByName(ctx context.Context, userName string) int64
        UserNameByID(ctx context.Context, userID int64) string
}

// DetectedSpam is a storage interface used to get detected spam messages and set added flag.
type DetectedSpam interface {
        Read(ctx context.Context) ([]storage.DetectedSpamInfo, error)
        SetAddedToSamplesFlag(ctx context.Context, id int64) error
        FindByUserID(ctx context.Context, userID int64) (*storage.DetectedSpamInfo, error)
}

// StorageEngine provides access to the database engine for operations like backup
type StorageEngine interface {
        Backup(ctx context.Context, w io.Writer) error
        Type() engine.Type
        BackupSqliteAsPostgres(ctx context.Context, w io.Writer) error
}

// NewServer creates a new web API server.
func NewServer(cfg Config) *Server <span class="cov9" title="46">{
        return &amp;Server{Config: cfg}
}</span>

// Run starts server and accepts requests checking for spam messages.
func (s *Server) Run(ctx context.Context) error <span class="cov3" title="3">{
        router := routegroup.New(http.NewServeMux())
        router.Use(rest.Recoverer(log.Default()))
        router.Use(logger.New(logger.Log(log.Default()), logger.Prefix("[DEBUG]")).Handler)
        router.Use(rest.Throttle(1000))
        router.Use(rest.AppInfo("tg-spam", "umputun", s.Version), rest.Ping)
        router.Use(tollbooth.HTTPMiddleware(tollbooth.NewLimiter(50, nil)))
        router.Use(rest.SizeLimit(1024 * 1024)) // 1M max request size

        // set default username if not provided
        if s.AuthUser == "" </span><span class="cov3" title="3">{
                s.AuthUser = "tg-spam" // default username
        }</span>

        // hash-based authentication for maximum security
        <span class="cov3" title="3">if s.AuthHash != "" </span><span class="cov1" title="1">{
                log.Printf("[INFO] basic auth enabled for webapi server (user: %s)", s.AuthUser)
                router.Use(rest.BasicAuthWithBcryptHashAndPrompt(s.AuthUser, s.AuthHash))
        }</span> else<span class="cov2" title="2"> {
                log.Printf("[WARN] basic auth disabled, access to webapi is not protected")
        }</span>

        <span class="cov3" title="3">router = s.routes(router) // setup routes

        srv := &amp;http.Server{Addr: s.ListenAddr, Handler: router, ReadTimeout: 5 * time.Second, WriteTimeout: 5 * time.Second}
        go func() </span><span class="cov3" title="3">{
                &lt;-ctx.Done()
                if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to shutdown webapi server: %v", err)
                }</span> else<span class="cov3" title="3"> {
                        log.Printf("[INFO] webapi server stopped")
                }</span>
        }()

        <span class="cov3" title="3">log.Printf("[INFO] start webapi server on %s", s.ListenAddr)
        if err := srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run server: %w", err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

func (s *Server) routes(router *routegroup.Bundle) *routegroup.Bundle <span class="cov4" title="5">{
        // auth api routes
        router.Route(func(authApi *routegroup.Bundle) </span><span class="cov4" title="5">{
                if s.AuthHash != "" </span><span class="cov1" title="1">{
                        authApi.Use(s.authMiddleware(rest.BasicAuthWithBcryptHashAndPrompt(s.AuthUser, s.AuthHash)))
                }</span>
                <span class="cov4" title="5">authApi.HandleFunc("POST /check", s.checkMsgHandler)         // check a message for spam
                authApi.HandleFunc("GET /check/{user_id}", s.checkIDHandler) // check user id for spam

                authApi.Mount("/update").Route(func(r *routegroup.Bundle) </span><span class="cov4" title="5">{
                        // update spam/ham samples
                        r.HandleFunc("POST /spam", s.updateSampleHandler(s.SpamFilter.UpdateSpam)) // update spam samples
                        r.HandleFunc("POST /ham", s.updateSampleHandler(s.SpamFilter.UpdateHam))   // update ham samples
                }</span>)

                <span class="cov4" title="5">authApi.Mount("/delete").Route(func(r *routegroup.Bundle) </span><span class="cov4" title="5">{
                        // delete spam/ham samples
                        r.HandleFunc("POST /spam", s.deleteSampleHandler(s.SpamFilter.RemoveDynamicSpamSample))
                        r.HandleFunc("POST /ham", s.deleteSampleHandler(s.SpamFilter.RemoveDynamicHamSample))
                }</span>)

                <span class="cov4" title="5">authApi.Mount("/download").Route(func(r *routegroup.Bundle) </span><span class="cov4" title="5">{
                        r.HandleFunc("GET /spam", s.downloadSampleHandler(func(spam, _ []string) ([]string, string) </span><span class="cov0" title="0">{
                                return spam, "spam.txt"
                        }</span>))
                        <span class="cov4" title="5">r.HandleFunc("GET /ham", s.downloadSampleHandler(func(_, ham []string) ([]string, string) </span><span class="cov0" title="0">{
                                return ham, "ham.txt"
                        }</span>))
                        <span class="cov4" title="5">r.HandleFunc("GET /detected_spam", s.downloadDetectedSpamHandler)
                        r.HandleFunc("GET /backup", s.downloadBackupHandler)
                        r.HandleFunc("GET /export-to-postgres", s.downloadExportToPostgresHandler)</span>
                })

                <span class="cov4" title="5">authApi.HandleFunc("GET /samples", s.getDynamicSamplesHandler)    // get dynamic samples
                authApi.HandleFunc("PUT /samples", s.reloadDynamicSamplesHandler) // reload samples

                authApi.Mount("/users").Route(func(r *routegroup.Bundle) </span><span class="cov4" title="5">{ // manage approved users
                        // add user to the approved list and storage
                        r.HandleFunc("POST /add", s.updateApprovedUsersHandler(s.Detector.AddApprovedUser))
                        // remove user from an approved list and storage
                        r.HandleFunc("POST /delete", s.updateApprovedUsersHandler(s.removeApprovedUser))
                        // get approved users
                        r.HandleFunc("GET /", s.getApprovedUsersHandler)
                }</span>)

                <span class="cov4" title="5">authApi.HandleFunc("GET /settings", s.getSettingsHandler)</span> // get application settings
        })

        <span class="cov4" title="5">router.Route(func(webUI *routegroup.Bundle) </span><span class="cov4" title="5">{
                if s.AuthHash != "" </span><span class="cov1" title="1">{
                        webUI.Use(s.authMiddleware(rest.BasicAuthWithBcryptHashAndPrompt(s.AuthUser, s.AuthHash)))
                }</span>
                <span class="cov4" title="5">webUI.HandleFunc("GET /", s.htmlSpamCheckHandler)                         // serve template for webUI UI
                webUI.HandleFunc("GET /manage_samples", s.htmlManageSamplesHandler)       // serve manage samples page
                webUI.HandleFunc("GET /manage_users", s.htmlManageUsersHandler)           // serve manage users page
                webUI.HandleFunc("GET /detected_spam", s.htmlDetectedSpamHandler)         // serve detected spam page
                webUI.HandleFunc("GET /list_settings", s.htmlSettingsHandler)             // serve settings
                webUI.HandleFunc("POST /detected_spam/add", s.htmlAddDetectedSpamHandler) // add detected spam to samples

                // configuration management endpoints
                if s.SettingsStore != nil &amp;&amp; s.ConfigDBMode </span><span class="cov0" title="0">{
                        webUI.Route(func(config *routegroup.Bundle) </span><span class="cov0" title="0">{
                                config.HandleFunc("POST /config", s.saveConfigHandler)     // save current configuration to database
                                config.HandleFunc("GET /config", s.loadConfigHandler)      // load configuration from database
                                config.HandleFunc("PUT /config", s.updateConfigHandler)    // update configuration
                                config.HandleFunc("DELETE /config", s.deleteConfigHandler) // delete configuration
                        }</span>)
                }

                // handle logout - force Basic Auth re-authentication
                <span class="cov4" title="5">webUI.HandleFunc("GET /logout", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                        w.Header().Set("WWW-Authenticate", `Basic realm="tg-spam"`)
                        w.WriteHeader(http.StatusUnauthorized)
                        fmt.Fprintln(w, "Logged out successfully")
                }</span>)

                // serve only specific static files at root level
                <span class="cov4" title="5">staticFiles := newStaticFS(templateFS,
                        staticFileMapping{urlPath: "styles.css", filesysPath: "assets/styles.css"},
                        staticFileMapping{urlPath: "logo.png", filesysPath: "assets/logo.png"},
                        staticFileMapping{urlPath: "spinner.svg", filesysPath: "assets/spinner.svg"},
                )
                webUI.HandleFiles("/", http.FS(staticFiles))</span>
        })

        <span class="cov4" title="5">return router</span>
}

// checkMsgHandler handles POST /check request.
// it gets message text and user id from request body and returns spam status and check results.
func (s *Server) checkMsgHandler(w http.ResponseWriter, r *http.Request) <span class="cov5" title="7">{
        type CheckResultDisplay struct {
                Spam   bool
                Checks []spamcheck.Response
        }

        isHtmxRequest := r.Header.Get("HX-Request") == "true"

        req := spamcheck.Request{CheckOnly: true}
        if !isHtmxRequest </span><span class="cov4" title="6">{
                // API request
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusBadRequest)
                        rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                        log.Printf("[WARN] can't decode request: %v", err)
                        return
                }</span>
        } else<span class="cov1" title="1"> {
                // for hx-request (HTMX) we need to get the values from the form
                req.UserID = r.FormValue("user_id")
                req.UserName = r.FormValue("user_name")
                req.Msg = r.FormValue("msg")
        }</span>

        <span class="cov4" title="6">spam, cr := s.Detector.Check(req)
        if !isHtmxRequest </span><span class="cov4" title="5">{
                // for API request return JSON
                rest.RenderJSON(w, rest.JSON{"spam": spam, "checks": cr})
                return
        }</span>

        <span class="cov1" title="1">if req.Msg == "" </span><span class="cov0" title="0">{
                w.Header().Set("HX-Retarget", "#error-message")
                fmt.Fprintln(w, "&lt;div class='alert alert-danger'&gt;Valid message required.&lt;/div&gt;")
                return
        }</span>

        // render result for HTMX request
        <span class="cov1" title="1">resultDisplay := CheckResultDisplay{
                Spam:   spam,
                Checks: cr,
        }

        if err := tmpl.ExecuteTemplate(w, "check_results", resultDisplay); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] can't execute result template: %v", err)
                http.Error(w, "Error rendering result", http.StatusInternalServerError)
                return
        }</span>
}

// checkIDHandler handles GET /check/{user_id} request.
// it returns JSON with the status "spam" or "ham" for a given user id.
// if user is spammer, it also returns check results.
func (s *Server) checkIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        type info struct {
                UserName  string               `json:"user_name,omitempty"`
                Message   string               `json:"message,omitempty"`
                Timestamp time.Time            `json:"timestamp,omitempty"`
                Checks    []spamcheck.Response `json:"checks,omitempty"`
        }
        resp := struct {
                Status string `json:"status"`
                Info   *info  `json:"info,omitempty"`
        }{
                Status: "ham",
        }

        userID, err := strconv.ParseInt(r.PathValue("user_id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                rest.RenderJSON(w, rest.JSON{"error": "can't parse user id", "details": err.Error()})
                return
        }</span>

        <span class="cov2" title="2">si, err := s.DetectedSpam.FindByUserID(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't get user info", "details": err.Error()})
                return
        }</span>
        <span class="cov2" title="2">if si != nil </span><span class="cov1" title="1">{
                resp.Status = "spam"
                resp.Info = &amp;info{
                        UserName:  si.UserName,
                        Message:   si.Text,
                        Timestamp: si.Timestamp,
                        Checks:    si.Checks,
                }
        }</span>
        <span class="cov2" title="2">rest.RenderJSON(w, resp)</span>
}

// getDynamicSamplesHandler handles GET /samples request. It returns dynamic samples both for spam and ham.
func (s *Server) getDynamicSamplesHandler(w http.ResponseWriter, _ *http.Request) <span class="cov2" title="2">{
        spam, ham, err := s.SpamFilter.DynamicSamples()
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't get dynamic samples", "details": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">rest.RenderJSON(w, rest.JSON{"spam": spam, "ham": ham})</span>
}

// downloadSampleHandler handles GET /download/spam|ham request. It returns dynamic samples both for spam and ham.
func (s *Server) downloadSampleHandler(pickFn func(spam, ham []string) ([]string, string)) func(w http.ResponseWriter, r *http.Request) <span class="cov6" title="13">{
        return func(w http.ResponseWriter, _ *http.Request) </span><span class="cov3" title="3">{
                spam, ham, err := s.SpamFilter.DynamicSamples()
                if err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't get dynamic samples", "details": err.Error()})
                        return
                }</span>
                <span class="cov2" title="2">samples, name := pickFn(spam, ham)
                body := strings.Join(samples, "\n")
                w.Header().Set("Content-Type", "text/plain; charset=utf-8")
                w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", name))
                w.Header().Set("Content-Length", strconv.Itoa(len(body)))
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte(body))</span>
        }
}

// updateSampleHandler handles POST /update/spam|ham request. It updates dynamic samples both for spam and ham.
func (s *Server) updateSampleHandler(updFn func(msg string) error) func(w http.ResponseWriter, r *http.Request) <span class="cov6" title="13">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="5">{
                var req struct {
                        Msg string `json:"msg"`
                }

                isHtmxRequest := r.Header.Get("HX-Request") == "true"

                if isHtmxRequest </span><span class="cov0" title="0">{
                        req.Msg = r.FormValue("msg")
                }</span> else<span class="cov4" title="5"> {
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                                w.WriteHeader(http.StatusBadRequest)
                                rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                                return
                        }</span>
                }

                <span class="cov4" title="4">err := updFn(req.Msg)
                if err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't update samples", "details": err.Error()})
                        return
                }</span>

                <span class="cov3" title="3">if isHtmxRequest </span><span class="cov0" title="0">{
                        s.renderSamples(w, "samples_list")
                }</span> else<span class="cov3" title="3"> {
                        rest.RenderJSON(w, rest.JSON{"updated": true, "msg": req.Msg})
                }</span>
        }
}

// deleteSampleHandler handles DELETE /samples request. It deletes dynamic samples both for spam and ham.
func (s *Server) deleteSampleHandler(delFn func(msg string) error) func(w http.ResponseWriter, r *http.Request) <span class="cov6" title="13">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="5">{
                var req struct {
                        Msg string `json:"msg"`
                }
                isHtmxRequest := r.Header.Get("HX-Request") == "true"
                if isHtmxRequest </span><span class="cov1" title="1">{
                        req.Msg = r.FormValue("msg")
                }</span> else<span class="cov4" title="4"> {
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusBadRequest)
                                rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                                return
                        }</span>
                }

                <span class="cov4" title="5">if err := delFn(req.Msg); err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't delete sample", "details": err.Error()})
                        return
                }</span>

                <span class="cov4" title="4">if isHtmxRequest </span><span class="cov1" title="1">{
                        s.renderSamples(w, "samples_list")
                }</span> else<span class="cov3" title="3"> {
                        rest.RenderJSON(w, rest.JSON{"deleted": true, "msg": req.Msg, "count": 1})
                }</span>
        }
}

// reloadDynamicSamplesHandler handles PUT /samples request. It reloads dynamic samples from db storage.
func (s *Server) reloadDynamicSamplesHandler(w http.ResponseWriter, _ *http.Request) <span class="cov2" title="2">{
        if err := s.SpamFilter.ReloadSamples(); err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't reload samples", "details": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">rest.RenderJSON(w, rest.JSON{"reloaded": true})</span>
}

// updateApprovedUsersHandler handles POST /users/add and /users/delete requests, it adds or removes users from approved list.
func (s *Server) updateApprovedUsersHandler(updFn func(ui approved.UserInfo) error) func(w http.ResponseWriter, r *http.Request) <span class="cov6" title="14">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="9">{
                req := approved.UserInfo{}
                isHtmxRequest := r.Header.Get("HX-Request") == "true"
                if isHtmxRequest </span><span class="cov1" title="1">{
                        req.UserID = r.FormValue("user_id")
                        req.UserName = r.FormValue("user_name")
                }</span> else<span class="cov5" title="8"> {
                        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                                w.WriteHeader(http.StatusBadRequest)
                                rest.RenderJSON(w, rest.JSON{"error": "can't decode request", "details": err.Error()})
                                return
                        }</span>
                }

                // try to get userID from request and fallback to userName lookup if it's empty
                <span class="cov5" title="8">if req.UserID == "" </span><span class="cov4" title="4">{
                        req.UserID = strconv.FormatInt(s.Locator.UserIDByName(r.Context(), req.UserName), 10)
                }</span>

                <span class="cov5" title="8">if req.UserID == "" || req.UserID == "0" </span><span class="cov1" title="1">{
                        if isHtmxRequest </span><span class="cov0" title="0">{
                                w.Header().Set("HX-Retarget", "#error-message")
                                fmt.Fprintln(w, "&lt;div class='alert alert-danger'&gt;Either userid or valid username required.&lt;/div&gt;")
                                return
                        }</span>
                        <span class="cov1" title="1">w.WriteHeader(http.StatusBadRequest)
                        rest.RenderJSON(w, rest.JSON{"error": "user ID is required"})
                        return</span>
                }

                // add or remove user from the approved list of detector
                <span class="cov5" title="7">if err := updFn(req); err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't update approved users", "details": err.Error()})
                        return
                }</span>

                <span class="cov5" title="7">if isHtmxRequest </span><span class="cov1" title="1">{
                        users := s.Detector.ApprovedUsers()
                        tmplData := struct {
                                ApprovedUsers      []approved.UserInfo
                                TotalApprovedUsers int
                        }{
                                ApprovedUsers:      users,
                                TotalApprovedUsers: len(users),
                        }

                        if err := tmpl.ExecuteTemplate(w, "users_list", tmplData); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>

                } else<span class="cov4" title="6"> {
                        rest.RenderJSON(w, rest.JSON{"updated": true, "user_id": req.UserID, "user_name": req.UserName})
                }</span>
        }
}

// removeApprovedUser is adopter for updateApprovedUsersHandler updFn
func (s *Server) removeApprovedUser(req approved.UserInfo) error <span class="cov2" title="2">{
        if err := s.Detector.RemoveApprovedUser(req.UserID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove approved user %s: %w", req.UserID, err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// getApprovedUsersHandler handles GET /users request. It returns list of approved users.
func (s *Server) getApprovedUsersHandler(w http.ResponseWriter, _ *http.Request) <span class="cov1" title="1">{
        rest.RenderJSON(w, rest.JSON{"user_ids": s.Detector.ApprovedUsers()})
}</span>

// getSettingsHandler returns application settings, including the list of available Lua plugins
func (s *Server) getSettingsHandler(w http.ResponseWriter, _ *http.Request) <span class="cov3" title="3">{
        // get available Lua plugins and store them directly in AppSettings
        s.AppSettings.LuaPlugins.EnabledPlugins = s.Detector.GetLuaPluginNames()

        // return the application settings directly - sensitive info is protected by json tags
        rest.RenderJSON(w, s.AppSettings)
}</span>

// htmlSpamCheckHandler handles GET / request.
// It returns rendered spam_check.html template with all the components.
func (s *Server) htmlSpamCheckHandler(w http.ResponseWriter, _ *http.Request) <span class="cov3" title="3">{
        tmplData := struct {
                Version string
        }{
                Version: s.Version,
        }

        if err := tmpl.ExecuteTemplate(w, "spam_check.html", tmplData); err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

// htmlManageSamplesHandler handles GET /manage_samples request.
// It returns rendered manage_samples.html template with all the components.
func (s *Server) htmlManageSamplesHandler(w http.ResponseWriter, _ *http.Request) <span class="cov1" title="1">{
        s.renderSamples(w, "manage_samples.html")
}</span>

func (s *Server) htmlManageUsersHandler(w http.ResponseWriter, _ *http.Request) <span class="cov3" title="3">{
        users := s.Detector.ApprovedUsers()
        tmplData := struct {
                ApprovedUsers      []approved.UserInfo
                TotalApprovedUsers int
        }{
                ApprovedUsers:      users,
                TotalApprovedUsers: len(users),
        }
        tmplData.TotalApprovedUsers = len(tmplData.ApprovedUsers)

        if err := tmpl.ExecuteTemplate(w, "manage_users.html", tmplData); err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

func (s *Server) htmlDetectedSpamHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        ds, err := s.DetectedSpam.Read(r.Context())
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("[ERROR] Failed to fetch detected spam: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>

        // clean up detected spam entries
        <span class="cov1" title="1">for i, d := range ds </span><span class="cov2" title="2">{
                d.Text = strings.ReplaceAll(d.Text, "'", " ")
                d.Text = strings.ReplaceAll(d.Text, "\n", " ")
                d.Text = strings.ReplaceAll(d.Text, "\r", " ")
                d.Text = strings.ReplaceAll(d.Text, "\t", " ")
                d.Text = strings.ReplaceAll(d.Text, "\"", " ")
                d.Text = strings.ReplaceAll(d.Text, "\\", " ")
                ds[i] = d
        }</span>

        // get filter from query param, default to "all"
        <span class="cov1" title="1">filter := r.URL.Query().Get("filter")
        if filter == "" </span><span class="cov1" title="1">{
                filter = "all"
        }</span>

        // apply filtering
        <span class="cov1" title="1">var filteredDS []storage.DetectedSpamInfo
        switch filter </span>{
        case "non-classified":<span class="cov0" title="0">
                for _, entry := range ds </span><span class="cov0" title="0">{
                        hasClassifierHam := false
                        for _, check := range entry.Checks </span><span class="cov0" title="0">{
                                if check.Name == "classifier" &amp;&amp; !check.Spam </span><span class="cov0" title="0">{
                                        hasClassifierHam = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasClassifierHam </span><span class="cov0" title="0">{
                                filteredDS = append(filteredDS, entry)
                        }</span>
                }
        case "openai":<span class="cov0" title="0">
                for _, entry := range ds </span><span class="cov0" title="0">{
                        hasOpenAI := false
                        for _, check := range entry.Checks </span><span class="cov0" title="0">{
                                if check.Name == "openai" </span><span class="cov0" title="0">{
                                        hasOpenAI = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasOpenAI </span><span class="cov0" title="0">{
                                filteredDS = append(filteredDS, entry)
                        }</span>
                }
        default:<span class="cov1" title="1"> // "all" or any other value
                filteredDS = ds</span>
        }

        <span class="cov1" title="1">tmplData := struct {
                DetectedSpamEntries []storage.DetectedSpamInfo
                TotalDetectedSpam   int
                FilteredCount       int
                Filter              string
                OpenAIEnabled       bool
        }{
                DetectedSpamEntries: filteredDS,
                TotalDetectedSpam:   len(ds),
                FilteredCount:       len(filteredDS),
                Filter:              filter,
                OpenAIEnabled:       s.AppSettings != nil &amp;&amp; s.AppSettings.IsOpenAIEnabled(),
        }

        // if it's an HTMX request, render both content and count display for OOB swap
        if r.Header.Get("HX-Request") == "true" </span><span class="cov0" title="0">{
                var buf bytes.Buffer

                // first render the content template
                if err := tmpl.ExecuteTemplate(&amp;buf, "detected_spam_content", tmplData); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] can't execute content template: %v", err)
                        http.Error(w, "Error executing template", http.StatusInternalServerError)
                        return
                }</span>

                // then append OOB swap for the count display
                <span class="cov0" title="0">countHTML := ""
                if filter != "all" </span><span class="cov0" title="0">{
                        countHTML = fmt.Sprintf("(%d/%d)", len(filteredDS), len(ds))
                }</span> else<span class="cov0" title="0"> {
                        countHTML = fmt.Sprintf("(%d)", len(ds))
                }</span>

                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf(`&lt;span id="count-display" hx-swap-oob="true"&gt;%s&lt;/span&gt;`, countHTML))

                // write the combined response
                if _, err := buf.WriteTo(w); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to write response: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // full page render for normal requests
        <span class="cov1" title="1">if err := tmpl.ExecuteTemplate(w, "detected_spam.html", tmplData); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

func (s *Server) htmlAddDetectedSpamHandler(w http.ResponseWriter, r *http.Request) <span class="cov4" title="5">{
        reportErr := func(err error, _ int) </span><span class="cov4" title="4">{
                w.Header().Set("HX-Retarget", "#error-message")
                fmt.Fprintf(w, "&lt;div class='alert alert-danger'&gt;%s&lt;/div&gt;", err)
        }</span>
        <span class="cov4" title="5">msg := r.FormValue("msg")

        id, err := strconv.ParseInt(r.FormValue("id"), 10, 64)
        if err != nil || msg == "" </span><span class="cov2" title="2">{
                log.Printf("[WARN] bad request: %v", err)
                reportErr(fmt.Errorf("bad request: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="3">if err := s.SpamFilter.UpdateSpam(msg); err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] failed to update spam samples: %v", err)
                reportErr(fmt.Errorf("can't update spam samples: %v", err), http.StatusInternalServerError)
                return

        }</span>
        <span class="cov2" title="2">if err := s.DetectedSpam.SetAddedToSamplesFlag(r.Context(), id); err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] failed to update detected spam: %v", err)
                reportErr(fmt.Errorf("can't update detected spam: %v", err), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)</span>
}

func (s *Server) htmlSettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov4" title="4">{
        // get database information if StorageEngine is available
        var dbInfo struct {
                DatabaseType   string `json:"database_type"`
                GID            string `json:"gid"`
                DatabaseStatus string `json:"database_status"`
        }

        if s.StorageEngine != nil </span><span class="cov2" title="2">{
                // try to cast to SQL engine to get type information
                if sqlEngine, ok := s.StorageEngine.(*engine.SQL); ok </span><span class="cov0" title="0">{
                        dbInfo.DatabaseType = string(sqlEngine.Type())
                        dbInfo.GID = sqlEngine.GID()
                        dbInfo.DatabaseStatus = "Connected"
                }</span> else<span class="cov2" title="2"> {
                        dbInfo.DatabaseType = "Unknown"
                        dbInfo.DatabaseStatus = "Connected (unknown type)"
                }</span>
        } else<span class="cov2" title="2"> {
                dbInfo.DatabaseStatus = "Not connected"
        }</span>

        // get backup information
        <span class="cov4" title="4">backupURL := "/download/backup"
        backupFilename := fmt.Sprintf("tg-spam-backup-%s-%s.sql.gz", dbInfo.DatabaseType, time.Now().Format("20060102-150405"))

        // get system info - uptime since server start
        uptime := time.Since(startTime)

        // get the list of available Lua plugins
        luaPlugins := s.Detector.GetLuaPluginNames()

        // get configuration DB status
        configAvailable := false
        var lastUpdated time.Time
        if s.SettingsStore != nil </span><span class="cov0" title="0">{
                configAvailable = true
                if lu, err := s.SettingsStore.LastUpdated(r.Context()); err == nil </span><span class="cov0" title="0">{
                        lastUpdated = lu
                }</span>
        }

        <span class="cov4" title="4">data := struct {
                *config.Settings
                LuaAvailablePlugins []string
                Version             string
                Database            struct {
                        Type   string
                        GID    string
                        Status string
                }
                Backup struct {
                        URL      string
                        Filename string
                }
                System struct {
                        Uptime string
                }
                ConfigAvailable bool
                LastUpdated     time.Time
                ConfigDBMode    bool
        }{
                Settings:            s.AppSettings,
                LuaAvailablePlugins: luaPlugins,
                Version:             s.Version,
                Database: struct {
                        Type   string
                        GID    string
                        Status string
                }{
                        Type:   dbInfo.DatabaseType,
                        GID:    dbInfo.GID,
                        Status: dbInfo.DatabaseStatus,
                },
                Backup: struct {
                        URL      string
                        Filename string
                }{
                        URL:      backupURL,
                        Filename: backupFilename,
                },
                System: struct {
                        Uptime string
                }{
                        Uptime: formatDuration(uptime),
                },
                ConfigAvailable: configAvailable,
                LastUpdated:     lastUpdated,
                ConfigDBMode:    s.ConfigDBMode,
        }

        if err := tmpl.ExecuteTemplate(w, "settings.html", data); err != nil </span><span class="cov1" title="1">{
                log.Printf("[WARN] can't execute template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

// formatDuration formats a duration in a human-readable way
func formatDuration(d time.Duration) string <span class="cov6" title="12">{
        days := int(d.Hours() / 24)
        hours := int(d.Hours()) % 24
        minutes := int(d.Minutes()) % 60

        if days &gt; 0 </span><span class="cov3" title="3">{
                return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
        }</span>

        <span class="cov5" title="9">if hours &gt; 0 </span><span class="cov2" title="2">{
                return fmt.Sprintf("%dh %dm", hours, minutes)
        }</span>

        <span class="cov5" title="7">return fmt.Sprintf("%dm", minutes)</span>
}

func (s *Server) downloadDetectedSpamHandler(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        ctx := r.Context()
        spam, err := s.DetectedSpam.Read(ctx)
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't get detected spam", "details": err.Error()})
                return
        }</span>

        <span class="cov2" title="2">type jsonSpamInfo struct {
                ID        int64                `json:"id"`
                GID       string               `json:"gid"`
                Text      string               `json:"text"`
                UserID    int64                `json:"user_id"`
                UserName  string               `json:"user_name"`
                Timestamp time.Time            `json:"timestamp"`
                Added     bool                 `json:"added"`
                Checks    []spamcheck.Response `json:"checks"`
        }

        // convert entries to jsonl format with lowercase fields
        lines := make([]string, 0, len(spam))
        for _, entry := range spam </span><span class="cov3" title="3">{
                data, err := json.Marshal(jsonSpamInfo{
                        ID:        entry.ID,
                        GID:       entry.GID,
                        Text:      entry.Text,
                        UserID:    entry.UserID,
                        UserName:  entry.UserName,
                        Timestamp: entry.Timestamp,
                        Added:     entry.Added,
                        Checks:    entry.Checks,
                })
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        rest.RenderJSON(w, rest.JSON{"error": "can't marshal entry", "details": err.Error()})
                        return
                }</span>
                <span class="cov3" title="3">lines = append(lines, string(data))</span>
        }

        <span class="cov2" title="2">body := strings.Join(lines, "\n")
        w.Header().Set("Content-Type", "application/x-jsonlines")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", "detected_spam.jsonl"))
        w.Header().Set("Content-Length", strconv.Itoa(len(body)))
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(body))</span>
}

// downloadBackupHandler streams a database backup as an SQL file with gzip compression
// Files are always compressed and always have .gz extension to ensure consistency
func (s *Server) downloadBackupHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if s.StorageEngine == nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "storage engine not available"})
                return
        }</span>

        // set filename based on database type and timestamp
        <span class="cov1" title="1">dbType := "db"
        sqlEng, ok := s.StorageEngine.(*engine.SQL)
        if ok </span><span class="cov0" title="0">{
                dbType = string(sqlEng.Type())
        }</span>
        <span class="cov1" title="1">timestamp := time.Now().Format("20060102-150405")

        // always use a .gz extension as the content is always compressed
        filename := fmt.Sprintf("tg-spam-backup-%s-%s.sql.gz", dbType, timestamp)

        // set headers for file download - note we're using application/octet-stream
        // instead of application/sql to prevent browsers from trying to interpret the file
        w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")

        // create a gzip writer that streams to response
        gzipWriter := gzip.NewWriter(w)
        defer func() </span><span class="cov1" title="1">{
                if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to close gzip writer: %v", err)
                }</span>
        }()

        // stream backup directly to response through gzip
        <span class="cov1" title="1">if err := s.StorageEngine.Backup(r.Context(), gzipWriter); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to create backup: %v", err)
                // we've already started writing the response, so we can't send a proper error response
                return
        }</span>

        // flush the gzip writer to ensure all data is written
        <span class="cov1" title="1">if err := gzipWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to flush gzip writer: %v", err)
        }</span>
}

// downloadExportToPostgresHandler streams a PostgreSQL-compatible export from a SQLite database
func (s *Server) downloadExportToPostgresHandler(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        if s.StorageEngine == nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "storage engine not available"})
                return
        }</span>

        // check if the database is SQLite
        <span class="cov2" title="2">if s.StorageEngine.Type() != engine.Sqlite </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                rest.RenderJSON(w, rest.JSON{"error": "source database must be SQLite"})
                return
        }</span>

        // set filename based on timestamp
        <span class="cov1" title="1">timestamp := time.Now().Format("20060102-150405")
        filename := fmt.Sprintf("tg-spam-sqlite-to-postgres-%s.sql.gz", timestamp)

        // set headers for file download
        w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")

        // create a gzip writer that streams to response
        gzipWriter := gzip.NewWriter(w)
        defer func() </span><span class="cov1" title="1">{
                if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to close gzip writer: %v", err)
                }</span>
        }()

        // stream export directly to response through gzip
        <span class="cov1" title="1">if err := s.StorageEngine.BackupSqliteAsPostgres(r.Context(), gzipWriter); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to create export: %v", err)
                // we've already started writing the response, so we can't send a proper error response
                return
        }</span>

        // flush the gzip writer to ensure all data is written
        <span class="cov1" title="1">if err := gzipWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to flush gzip writer: %v", err)
        }</span>
}

func (s *Server) renderSamples(w http.ResponseWriter, tmplName string) <span class="cov4" title="6">{
        spam, ham, err := s.SpamFilter.DynamicSamples()
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't fetch samples", "details": err.Error()})
                return
        }</span>

        <span class="cov4" title="5">spam, ham = s.reverseSamples(spam, ham)

        type smpleWithID struct {
                ID     string
                Sample string
        }

        makeID := func(s string) string </span><span class="cov6" title="14">{
                hash := sha1.New() //nolint
                if _, err := hash.Write([]byte(s)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%x", s)
                }</span>
                <span class="cov6" title="14">return fmt.Sprintf("%x", hash.Sum(nil))</span>
        }

        <span class="cov4" title="5">tmplData := struct {
                SpamSamples      []smpleWithID
                HamSamples       []smpleWithID
                TotalHamSamples  int
                TotalSpamSamples int
        }{
                TotalHamSamples:  len(ham),
                TotalSpamSamples: len(spam),
        }
        for _, s := range spam </span><span class="cov5" title="7">{
                tmplData.SpamSamples = append(tmplData.SpamSamples, smpleWithID{ID: makeID(s), Sample: s})
        }</span>
        <span class="cov4" title="5">for _, h := range ham </span><span class="cov5" title="7">{
                tmplData.HamSamples = append(tmplData.HamSamples, smpleWithID{ID: makeID(h), Sample: h})
        }</span>

        <span class="cov4" title="5">if err := tmpl.ExecuteTemplate(w, tmplName, tmplData); err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                rest.RenderJSON(w, rest.JSON{"error": "can't execute template", "details": err.Error()})
                return
        }</span>
}

func (s *Server) authMiddleware(mw func(next http.Handler) http.Handler) func(next http.Handler) http.Handler <span class="cov2" title="2">{
        if s.AuthHash == "" </span><span class="cov0" title="0">{
                // if no hash is provided, authentication is disabled
                return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return next
                }</span>
        }
        <span class="cov2" title="2">return func(next http.Handler) http.Handler </span><span class="cov8" title="33">{
                return mw(next)
        }</span>
}

// reverseSamples returns reversed lists of spam and ham samples
func (s *Server) reverseSamples(spam, ham []string) (revSpam, revHam []string) <span class="cov5" title="8">{
        revSpam = make([]string, len(spam))
        revHam = make([]string, len(ham))

        for i, j := 0, len(spam)-1; i &lt; len(spam); i, j = i+1, j-1 </span><span class="cov6" title="11">{
                revSpam[i] = spam[j]
        }</span>
        <span class="cov5" title="8">for i, j := 0, len(ham)-1; i &lt; len(ham); i, j = i+1, j-1 </span><span class="cov6" title="11">{
                revHam[i] = ham[j]
        }</span>
        <span class="cov5" title="8">return revSpam, revHam</span>
}

// staticFS is a filtered filesystem that only exposes specific static files
type staticFS struct {
        fs        fs.FS
        urlToPath map[string]string
}

// staticFileMapping defines a mapping between URL path and filesystem path
type staticFileMapping struct {
        urlPath     string
        filesysPath string
}

func newStaticFS(fsys fs.FS, files ...staticFileMapping) *staticFS <span class="cov4" title="5">{
        urlToPath := make(map[string]string)
        for _, f := range files </span><span class="cov6" title="15">{
                urlToPath[f.urlPath] = f.filesysPath
        }</span>

        <span class="cov4" title="5">return &amp;staticFS{
                fs:        fsys,
                urlToPath: urlToPath,
        }</span>
}

func (sfs *staticFS) Open(name string) (fs.File, error) <span class="cov4" title="6">{
        cleanName := path.Clean("/" + name)[1:]

        fsPath, ok := sfs.urlToPath[cleanName]
        if !ok </span><span class="cov3" title="3">{
                return nil, fs.ErrNotExist
        }</span>

        <span class="cov3" title="3">file, err := sfs.fs.Open(fsPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open static file %s: %w", fsPath, err)
        }</span>
        <span class="cov3" title="3">return file, nil</span>
}

// GenerateRandomPassword generates a random password of a given length
func GenerateRandomPassword(length int) (string, error) <span class="cov2" title="2">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()_+"
        const charsetLen = int64(len(charset))

        result := make([]byte, length)
        for i := 0; i &lt; length; i++ </span><span class="cov10" title="64">{
                n, err := rand.Int(rand.Reader, big.NewInt(charsetLen))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to generate random number: %w", err)
                }</span>
                <span class="cov10" title="64">result[i] = charset[n.Int64()]</span>
        }
        <span class="cov2" title="2">return string(result), nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package approved

import (
        "fmt"
        "time"
)

// UserInfo is a struct for approved user info.
type UserInfo struct {
        UserID    string    `json:"user_id"`
        UserName  string    `json:"user_name"`
        Timestamp time.Time `json:"timestamp"`
        Count     int       `json:"-"`
}

func (u *UserInfo) String() string <span class="cov10" title="2">{
        if u.UserName == "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("%q", u.UserID)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%q (%s)", u.UserName, u.UserID)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package spamcheck

import (
        "container/ring"
        "sync"
)

// LastRequests keeps track of last N requests, thread-safe.
type LastRequests struct {
        requests *ring.Ring
        size     int
        lock     sync.RWMutex
}

const maxMsgLen = 1024

// NewLastRequests creates new requests tracker
func NewLastRequests(size int) *LastRequests <span class="cov4" title="9">{
        // minimum size is 1
        if size &lt; 1 </span><span class="cov1" title="1">{
                size = 1
        }</span>
        <span class="cov4" title="9">return &amp;LastRequests{
                requests: ring.New(size),
                size:     size,
        }</span>
}

// Push adds new request to the history
func (h *LastRequests) Push(req Request) <span class="cov7" title="112">{
        h.lock.Lock()
        defer h.lock.Unlock()

        if len(req.Msg) &gt; maxMsgLen </span><span class="cov1" title="1">{
                // truncate the message if it's too long to prevent memory exhaustion attacks
                req.Msg = req.Msg[:maxMsgLen]
        }</span>

        <span class="cov7" title="112">h.requests.Value = req
        h.requests = h.requests.Next()</span>
}

// Last returns up to n last requests in chronological order (oldest to newest)
func (h *LastRequests) Last(n int) []Request <span class="cov7" title="108">{
        if n &lt; 1 </span><span class="cov1" title="1">{
                return []Request{}
        }</span>

        <span class="cov7" title="107">h.lock.RLock()
        defer h.lock.RUnlock()

        if n &gt; h.size </span><span class="cov1" title="1">{
                n = h.size
        }</span>

        <span class="cov7" title="107">result := make([]Request, 0, n)
        h.requests.Do(func(v interface{}) </span><span class="cov10" title="522">{
                if v != nil </span><span class="cov9" title="470">{
                        if req, ok := v.(Request); ok </span><span class="cov9" title="470">{
                                result = append(result, req)
                        }</span>
                }
        })

        <span class="cov7" title="107">if len(result) &gt; n </span><span class="cov1" title="1">{
                result = result[:n]
        }</span>
        <span class="cov7" title="107">return result</span>
}

// Size returns the size of request history
func (h *LastRequests) Size() int <span class="cov1" title="1">{
        return h.size
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package spamcheck

import (
        "fmt"
        "strings"
)

// Request is a request to check a message for spam.
type Request struct {
        Msg       string   `json:"msg"`        // message to check
        UserID    string   `json:"user_id"`    // user id
        UserName  string   `json:"user_name"`  // user name
        Meta      MetaData `json:"meta"`       // meta-info, provided by the client
        CheckOnly bool     `json:"check_only"` // if true, only check the message, do not write newly approved user to the database
}

// MetaData is a meta-info about the message, provided by the client.
type MetaData struct {
        Images      int  `json:"images"`       // number of images in the message
        Links       int  `json:"links"`        // number of links in the message
        Mentions    int  `json:"mentions"`     // number of mentions (@username) in the message
        HasVideo    bool `json:"has_video"`    // true if the message has a video or video note
        HasAudio    bool `json:"has_audio"`    // true if the message has an audio
        HasForward  bool `json:"has_forward"`  // true if the message has a forward
        HasKeyboard bool `json:"has_keyboard"` // true if the message has a keyboard (buttons)
}

func (r *Request) String() string <span class="cov7" title="3">{
        return fmt.Sprintf("msg:%q, user:%q, id:%s, images:%d, links:%d, mentions:%d, has_video:%v, has_audio:%v, has_forward:%v, has_keyboard:%v",
                r.Msg, r.UserName, r.UserID, r.Meta.Images, r.Meta.Links, r.Meta.Mentions, r.Meta.HasVideo, r.Meta.HasAudio, r.Meta.HasForward, r.Meta.HasKeyboard)
}</span>

// Response is a result of spam check.
type Response struct {
        Name    string `json:"name"`    // name of the check
        Spam    bool   `json:"spam"`    // true if spam
        Details string `json:"details"` // details of the check
        Error   error  `json:"-"`       // error message, if any. Do not serialize it
}

func (r *Response) String() string <span class="cov10" title="5">{
        spamOrHam := "ham"
        if r.Spam </span><span class="cov7" title="3">{
                spamOrHam = "spam"
        }</span>
        <span class="cov10" title="5">return fmt.Sprintf("%s: %s, %s", r.Name, spamOrHam, r.Details)</span>
}

// ChecksToString converts a slice of checks to a string
func ChecksToString(checks []Response) string <span class="cov7" title="3">{
        elems := []string{}
        for _, r := range checks </span><span class="cov7" title="3">{
                elems = append(elems, "{"+r.String()+"}")

        }</span>
        <span class="cov7" title="3">return fmt.Sprintf("[%s] ", strings.Join(elems, ", "))</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package tgspam

import (
        "fmt"
        "math"
)

// based on the code from https://github.com/RadhiFadlillah/go-bayesian/blob/master/classifier.go

// spamClass is alias of string, representing class of a document
type spamClass string

// enum for spamClass
const (
        ClassSpam spamClass = "spam"
        ClassHam  spamClass = "ham"
)

// document is a group of tokens with certain class
type document struct {
        spamClass spamClass
        tokens    []string
}

// newDocument return new document
func newDocument(class spamClass, tokens ...string) document <span class="cov6" title="31">{
        return document{
                spamClass: class,
                tokens:    tokens,
        }
}</span>

// classifier is object for a classifying document
type classifier struct {
        learningResults    map[string]map[spamClass]int
        priorProbabilities map[spamClass]float64
        nDocumentByClass   map[spamClass]int
        nFrequencyByClass  map[spamClass]int
        nAllDocument       int
}

// newClassifier returns new classifier
func newClassifier() classifier <span class="cov7" title="69">{
        return classifier{
                learningResults:    make(map[string]map[spamClass]int),
                priorProbabilities: make(map[spamClass]float64),
                nDocumentByClass:   make(map[spamClass]int),
                nFrequencyByClass:  make(map[spamClass]int),
        }
}</span>

// learn executes the learning process for this classifier
func (c *classifier) learn(docs ...document) <span class="cov6" title="27">{
        c.nAllDocument += len(docs)

        for _, doc := range docs </span><span class="cov7" title="63">{
                c.nDocumentByClass[doc.spamClass]++
                tokens := c.removeDuplicate(doc.tokens...)

                for _, token := range tokens </span><span class="cov8" title="150">{
                        c.nFrequencyByClass[doc.spamClass]++

                        if _, exist := c.learningResults[token]; !exist </span><span class="cov8" title="149">{
                                c.learningResults[token] = make(map[spamClass]int)
                        }</span>

                        <span class="cov8" title="150">c.learningResults[token][doc.spamClass]++</span>
                }
        }

        <span class="cov6" title="27">for class, nDocument := range c.nDocumentByClass </span><span class="cov6" title="42">{
                c.priorProbabilities[class] = math.Log(float64(nDocument) / float64(c.nAllDocument))
        }</span>
}

// unlearn removes the learning results for given documents
func (c *classifier) unlearn(docs ...document) error <span class="cov4" title="12">{
        if len(docs) &gt; c.nAllDocument </span><span class="cov2" title="2">{
                return fmt.Errorf("trying to unlearn more documents than learned")
        }</span>

        <span class="cov4" title="10">c.nAllDocument -= len(docs)

        for _, doc := range docs </span><span class="cov4" title="10">{
                if c.nDocumentByClass[doc.spamClass] &lt;= 0 </span><span class="cov1" title="1">{
                        return fmt.Errorf("no documents of class %v to unlearn", doc.spamClass)
                }</span>

                <span class="cov4" title="9">c.nDocumentByClass[doc.spamClass]--
                tokens := c.removeDuplicate(doc.tokens...)

                for _, token := range tokens </span><span class="cov5" title="15">{
                        if c.nFrequencyByClass[doc.spamClass] &lt;= 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("no tokens of class %v to unlearn", doc.spamClass)
                        }</span>
                        <span class="cov5" title="15">c.nFrequencyByClass[doc.spamClass]--

                        if c.learningResults[token][doc.spamClass] &lt;= 0 </span><span class="cov1" title="1">{
                                return fmt.Errorf("token %q not found in class %v", token, doc.spamClass)
                        }</span>
                        <span class="cov5" title="14">c.learningResults[token][doc.spamClass]--

                        // cleanup empty entries
                        if c.learningResults[token][doc.spamClass] == 0 </span><span class="cov5" title="14">{
                                delete(c.learningResults[token], doc.spamClass)
                        }</span>
                        <span class="cov5" title="14">if len(c.learningResults[token]) == 0 </span><span class="cov5" title="13">{
                                delete(c.learningResults, token)
                        }</span>
                }

                // cleanup empty class entries
                <span class="cov4" title="8">if c.nDocumentByClass[doc.spamClass] == 0 </span><span class="cov3" title="6">{
                        delete(c.nDocumentByClass, doc.spamClass)
                        delete(c.nFrequencyByClass, doc.spamClass)
                        delete(c.priorProbabilities, doc.spamClass)
                }</span> else<span class="cov2" title="2"> {
                        // update prior probability for the class
                        c.priorProbabilities[doc.spamClass] = math.Log(float64(c.nDocumentByClass[doc.spamClass]) / float64(c.nAllDocument))
                }</span>
        }

        <span class="cov4" title="8">return nil</span>
}

// reset resets all learning results
func (c *classifier) reset() <span class="cov5" title="16">{
        c.learningResults = make(map[string]map[spamClass]int)
        c.priorProbabilities = make(map[spamClass]float64)
        c.nDocumentByClass = make(map[spamClass]int)
        c.nFrequencyByClass = make(map[spamClass]int)
        c.nAllDocument = 0
}</span>

// classify executes the classifying process for tokens
func (c *classifier) classify(tokens ...string) (spamClass, float64, bool) <span class="cov6" title="34">{
        nVocabulary := len(c.learningResults)
        posteriorProbabilities := make(map[spamClass]float64)

        for class, priorProb := range c.priorProbabilities </span><span class="cov7" title="67">{
                posteriorProbabilities[class] = priorProb
        }</span>
        <span class="cov6" title="34">tokens = c.removeDuplicate(tokens...)

        for class, freqByClass := range c.nFrequencyByClass </span><span class="cov7" title="67">{
                for _, token := range tokens </span><span class="cov9" title="272">{
                        nToken := c.learningResults[token][class]
                        posteriorProbabilities[class] += math.Log(float64(nToken+1) / float64(freqByClass+nVocabulary))
                }</span>
        }

        <span class="cov6" title="34">probabilities := softmax(posteriorProbabilities) // apply softmax to posterior probabilities

        // find the best class and its probability
        var certain bool
        var bestClass spamClass
        var highestProb float64
        for class, prob := range probabilities </span><span class="cov7" title="67">{
                if highestProb == 0 || prob &gt; highestProb </span><span class="cov7" title="46">{
                        certain = true
                        bestClass = class
                        highestProb = prob
                }</span> else<span class="cov5" title="21"> if prob == highestProb </span><span class="cov4" title="9">{
                        certain = false
                }</span>
        }

        <span class="cov6" title="34">highestProb *= 100 // convert probability to percentage
        return bestClass, highestProb, certain</span>
}

func (c *classifier) removeDuplicate(tokens ...string) []string <span class="cov8" title="106">{
        mapTokens := make(map[string]struct{})
        newTokens := []string{}

        for _, token := range tokens </span><span class="cov10" title="308">{
                mapTokens[token] = struct{}{}
        }</span>

        <span class="cov8" title="106">for key := range mapTokens </span><span class="cov9" title="304">{
                newTokens = append(newTokens, key)
        }</span>

        <span class="cov8" title="106">return newTokens</span>
}

// softmax converts log probabilities to normalized probabilities
func softmax(logProbs map[spamClass]float64) map[spamClass]float64 <span class="cov6" title="42">{
        if len(logProbs) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // step 1: Find the max value to subtract (prevents overflow)
        <span class="cov6" title="41">maxVal := math.Inf(-1) // start with negative infinity
        for _, v := range logProbs </span><span class="cov7" title="81">{
                if !math.IsInf(v, -1) &amp;&amp; v &gt; maxVal </span><span class="cov7" title="54">{
                        maxVal = v
                }</span>
        }

        // handle case where all values are -Inf
        <span class="cov6" title="41">if math.IsInf(maxVal, -1) </span><span class="cov1" title="1">{
                // return uniform distribution
                probs := make(map[spamClass]float64)
                uniformProb := 1.0 / float64(len(logProbs))
                for cat := range logProbs </span><span class="cov2" title="2">{
                        probs[cat] = uniformProb
                }</span>
                <span class="cov1" title="1">return probs</span>
        }

        // step 2: Compute exp(x - maxVal) and sum for normalization
        <span class="cov6" title="40">expSum := 0.0
        exps := make(map[spamClass]float64)
        for cat, v := range logProbs </span><span class="cov7" title="79">{
                if math.IsInf(v, -1) </span><span class="cov1" title="1">{
                        exps[cat] = 0.0
                }</span> else<span class="cov7" title="78"> {
                        exps[cat] = math.Exp(v - maxVal) // shift by maxVal keeps exp safe
                }</span>
                <span class="cov7" title="79">expSum += exps[cat]</span>
        }

        // handle case where expSum is 0 or very small
        <span class="cov6" title="40">if expSum == 0 || math.IsNaN(expSum) </span><span class="cov0" title="0">{
                // return uniform distribution
                probs := make(map[spamClass]float64)
                uniformProb := 1.0 / float64(len(logProbs))
                for cat := range logProbs </span><span class="cov0" title="0">{
                        probs[cat] = uniformProb
                }</span>
                <span class="cov0" title="0">return probs</span>
        }

        // step 3: Normalize to get probabilities
        <span class="cov6" title="40">probs := make(map[spamClass]float64)
        for cat, v := range exps </span><span class="cov7" title="79">{
                probs[cat] = v / expSum
        }</span>
        <span class="cov6" title="40">return probs</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package tgspam

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "iter"
        "log"
        "math"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"
        "unicode"

        "github.com/forPelevin/gomoji"

        "github.com/umputun/tg-spam/lib/approved"
        "github.com/umputun/tg-spam/lib/spamcheck"
        "github.com/umputun/tg-spam/lib/tgspam/plugin"
)

//go:generate moq --out mocks/sample_updater.go --pkg mocks --skip-ensure --with-resets . SampleUpdater
//go:generate moq --out mocks/http_client.go --pkg mocks --skip-ensure --with-resets . HTTPClient
//go:generate moq --out mocks/user_storage.go --pkg mocks --skip-ensure --with-resets . UserStorage
//go:generate moq --out mocks/lua_plugin_engine.go --pkg mocks --skip-ensure --with-resets . LuaPluginEngine

// Detector is a spam detector, thread-safe.
// It uses a set of checks to determine if a message is spam, and also keeps a list of approved users.
type Detector struct {
        Config
        classifier     classifier
        openaiChecker  *openAIChecker
        metaChecks     []MetaCheck
        luaChecks      []plugin.Check // separate field for Lua plugin checks
        tokenizedSpam  []map[string]int
        approvedUsers  map[string]approved.UserInfo
        stopWords      []string
        excludedTokens map[string]struct{}
        luaEngine      LuaPluginEngine

        spamSamplesUpd SampleUpdater
        hamSamplesUpd  SampleUpdater
        userStorage    UserStorage

        // history of recent messages to keep in memory
        // can be passed to checkers supporting history
        hamHistory  *spamcheck.LastRequests
        spamHistory *spamcheck.LastRequests

        lock sync.RWMutex
}

// Config is a set of parameters for Detector.
type Config struct {
        SimilarityThreshold float64       // threshold for spam similarity, 0.0 - 1.0
        MinMsgLen           int           // minimum message length to check
        MaxAllowedEmoji     int           // maximum number of emojis allowed in a message
        CasAPI              string        // CAS API URL
        CasUserAgent        string        // CAS API User-Agent header value, set only if non-empty
        FirstMessageOnly    bool          // if true, only the first message from a user is checked
        FirstMessagesCount  int           // number of first messages to check for spam
        HTTPClient          HTTPClient    // http client to use for requests
        MinSpamProbability  float64       // minimum spam probability to consider a message spam with classifier, if 0 - ignored
        OpenAIVeto          bool          // if true, openai will be used to veto spam messages, otherwise it will be used to veto ham messages
        OpenAIHistorySize   int           // history size for openai
        MultiLangWords      int           // if true, check for number of multi-lingual words
        StorageTimeout      time.Duration // timeout for storage operations, if not set - no timeout

        LuaPlugins struct {
                Enabled        bool     // if true, enable Lua plugins
                PluginsDir     string   // directory with Lua plugins
                EnabledPlugins []string // list of enabled plugins (by name, without .lua extension)
                DynamicReload  bool     // if true, enable dynamic reloading of Lua plugins when files change
        }

        AbnormalSpacing struct {
                Enabled                 bool    // if true, enable check for abnormal spacing
                MinWordsCount           int     // the minimum number of words in the message to be considered
                ShortWordLen            int     // the length of the word to be considered short (in rune characters)
                ShortWordRatioThreshold float64 // the ratio of short words to all words in the message
                SpaceRatioThreshold     float64 // the ratio of spaces to all characters in the message
        }
        HistorySize int // history of recent messages to keep in memory
}

// SampleUpdater is an interface for updating spam/ham samples on the fly.
type SampleUpdater interface {
        Append(msg string) error        // append a message to the samples storage
        Remove(msg string) error        // remove a message from the samples storage
        Reader() (io.ReadCloser, error) // return a reader for the samples storage
}

// UserStorage is an interface for approved users storage.
type UserStorage interface {
        Read(ctx context.Context) ([]approved.UserInfo, error) // read approved users from storage
        Write(ctx context.Context, au approved.UserInfo) error // write approved user to storage
        Delete(ctx context.Context, id string) error           // delete approved user from storage
}

// HTTPClient is an interface for http client, satisfied by http.Client.
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// LuaPluginEngine defines an interface for the Lua plugin system
type LuaPluginEngine interface {
        LoadScript(path string) error               // loads a single Lua script
        ReloadScript(path string) error             // reloads a single Lua script
        LoadDirectory(dir string) error             // loads all Lua scripts from a directory
        GetCheck(name string) (plugin.Check, error) // returns a specific named plugin check
        GetAllChecks() map[string]plugin.Check      // returns all loaded plugin checks
        Close()                                     // cleans up resources
}

// LoadResult is a result of loading samples.
type LoadResult struct {
        ExcludedTokens int // number of excluded tokens
        SpamSamples    int // number of spam samples
        HamSamples     int // number of ham samples
        StopWords      int // number of stop words (phrases)
}

// NewDetector makes a new Detector with the given config.
func NewDetector(p Config) *Detector <span class="cov4" title="60">{
        res := &amp;Detector{
                Config:        p,
                classifier:    newClassifier(),
                approvedUsers: make(map[string]approved.UserInfo),
                tokenizedSpam: []map[string]int{},
                metaChecks:    []MetaCheck{},
                luaChecks:     []plugin.Check{},
                hamHistory:    spamcheck.NewLastRequests(p.HistorySize),
                spamHistory:   spamcheck.NewLastRequests(p.HistorySize),
                luaEngine:     nil, // will be set with WithLuaEngine if needed
        }
        // if FirstMessagesCount is set, FirstMessageOnly enforced to true.
        // this is to avoid confusion when FirstMessagesCount is set but FirstMessageOnly is false.
        // the reason for the redundant FirstMessageOnly flag is to avoid breaking api compatibility.
        if p.FirstMessagesCount &gt; 0 </span><span class="cov2" title="5">{
                res.FirstMessageOnly = true
        }</span>
        <span class="cov4" title="60">if p.FirstMessageOnly &amp;&amp; p.FirstMessagesCount == 0 </span><span class="cov3" title="21">{
                res.FirstMessagesCount = 1 // default value for FirstMessagesCount if FirstMessageOnly is set
        }</span>
        <span class="cov4" title="60">return res</span>
}

// Check checks if a given message is spam. Returns true if spam and also returns a list of check results.
func (d *Detector) Check(req spamcheck.Request) (spam bool, cr []spamcheck.Response) <span class="cov5" title="154">{

        isSpamDetected := func(cr []spamcheck.Response) bool </span><span class="cov5" title="146">{
                for _, r := range cr </span><span class="cov5" title="165">{
                        if r.Spam </span><span class="cov4" title="55">{
                                return true
                        }</span>
                }
                <span class="cov4" title="91">return false</span>
        }

        <span class="cov5" title="154">cleanMsg := d.cleanText(req.Msg)
        d.lock.RLock()
        defer d.lock.RUnlock()

        // approved user don't need to be checked
        if req.UserID != "" &amp;&amp; d.FirstMessageOnly &amp;&amp; d.approvedUsers[req.UserID].Count &gt;= d.FirstMessagesCount </span><span class="cov2" title="8">{
                return false, []spamcheck.Response{{Name: "pre-approved", Spam: false, Details: "user already approved"}}
        }</span>

        // all the checks are performed sequentially, so we can collect all the results

        // check for stop words if any stop words are loaded
        <span class="cov5" title="146">if len(d.stopWords) &gt; 0 </span><span class="cov3" title="23">{
                cr = append(cr, d.isStopWord(cleanMsg, req))
        }</span>

        // check for emojis if max allowed emojis is set
        <span class="cov5" title="146">if d.MaxAllowedEmoji &gt;= 0 </span><span class="cov4" title="45">{
                cr = append(cr, d.isManyEmojis(req.Msg))
        }</span>

        // check for spam with meta-checks
        <span class="cov5" title="146">for _, mc := range d.metaChecks </span><span class="cov3" title="18">{
                cr = append(cr, mc(req))
        }</span>

        // check for spam with Lua plugin checks
        <span class="cov5" title="146">for _, lc := range d.luaChecks </span><span class="cov3" title="25">{
                cr = append(cr, lc(req))
        }</span>

        // check for spam with CAS API if CAS API URL is set
        <span class="cov5" title="146">if d.CasAPI != "" </span><span class="cov2" title="8">{
                cr = append(cr, d.isCasSpam(req.UserID))
        }</span>

        <span class="cov5" title="146">if d.MultiLangWords &gt; 0 </span><span class="cov3" title="15">{
                cr = append(cr, d.isMultiLang(req.Msg))
        }</span>

        <span class="cov5" title="146">if d.AbnormalSpacing.Enabled </span><span class="cov3" title="13">{
                cr = append(cr, d.isAbnormalSpacing(req.Msg))
        }</span>

        // check for message length exceed the minimum size, if min message length is set.
        // the check is done after first simple checks, because stop words and emojis can be triggered by short messages as well.
        <span class="cov5" title="146">if len([]rune(req.Msg)) &lt; d.MinMsgLen </span><span class="cov2" title="4">{
                cr = append(cr, spamcheck.Response{Name: "message length", Spam: false, Details: "too short"})
                if isSpamDetected(cr) </span><span class="cov1" title="3">{
                        d.spamHistory.Push(req)
                        return true, cr // spam from the checks above
                }</span>
                <span class="cov1" title="1">d.hamHistory.Push(req)
                return false, cr</span>
        }

        // check for spam similarity if a similarity threshold is set and spam samples are loaded
        <span class="cov5" title="142">if d.SimilarityThreshold &gt; 0 &amp;&amp; len(d.tokenizedSpam) &gt; 0 </span><span class="cov2" title="6">{
                cr = append(cr, d.isSpamSimilarityHigh(cleanMsg))
        }</span>

        // check for spam with classifier if classifier is loaded
        <span class="cov5" title="142">if d.classifier.nAllDocument &gt; 0 &amp;&amp; d.classifier.nDocumentByClass["ham"] &gt; 0 &amp;&amp; d.classifier.nDocumentByClass["spam"] &gt; 0 </span><span class="cov3" title="21">{
                cr = append(cr, d.isSpamClassified(cleanMsg))
        }</span>

        <span class="cov5" title="142">spamDetected := isSpamDetected(cr)

        // we hit openai in two cases:
        //  - all other checks passed (ham result) and OpenAIVeto is false. In this case, openai primary used to improve false negative rate
        //  - one of the checks failed (spam result) and OpenAIVeto is true. In this case, openai primary used to improve false positive rate
        // FirstMessageOnly or FirstMessagesCount has to be set to use openai, because it's slow and expensive to run on all messages
        if d.openaiChecker != nil &amp;&amp; (d.FirstMessageOnly || d.FirstMessagesCount &gt; 0) </span><span class="cov2" title="6">{
                if !spamDetected &amp;&amp; !d.OpenAIVeto || spamDetected &amp;&amp; d.OpenAIVeto </span><span class="cov2" title="5">{
                        var hist []spamcheck.Request // by default, openai doesn't use history
                        if d.OpenAIHistorySize &gt; 0 &amp;&amp; d.HistorySize &gt; 0 </span><span class="cov0" title="0">{
                                // if history size is set, we use the last N messages for openai
                                hist = d.hamHistory.Last(d.OpenAIHistorySize)
                        }</span>
                        <span class="cov2" title="5">spam, details := d.openaiChecker.check(cleanMsg, hist)
                        cr = append(cr, details)
                        if spamDetected &amp;&amp; details.Error != nil </span><span class="cov1" title="1">{
                                // spam detected with other checks, but openai failed. in this case, we still return spam, but log the error
                                log.Printf("[WARN] openai error: %v", details.Error)
                        }</span> else<span class="cov2" title="4"> {
                                log.Printf("[DEBUG] openai result: {%s}", details.String())
                                spamDetected = spam
                        }</span>

                        // log if veto is enabled, and openai detected no spam for message that was detected as spam by other checks
                        <span class="cov2" title="5">if d.OpenAIVeto &amp;&amp; !spam </span><span class="cov1" title="2">{
                                log.Printf("[DEBUG] openai vetoed ham message: %q, checks: %s", req.Msg, spamcheck.ChecksToString(cr))
                        }</span>
                }
        }

        <span class="cov5" title="142">if spamDetected </span><span class="cov4" title="53">{
                d.spamHistory.Push(req)
                return true, cr
        }</span>

        // update approved users only if it's not paranoid mode and not a check-only request
        <span class="cov4" title="89">if (d.FirstMessageOnly || d.FirstMessagesCount &gt; 0) &amp;&amp; !req.CheckOnly </span><span class="cov3" title="13">{
                ctx, cancel := d.ctxWithStoreTimeout()
                defer cancel()
                au := approved.UserInfo{
                        Count:     d.approvedUsers[req.UserID].Count + 1,
                        UserID:    req.UserID,
                        UserName:  req.UserName,
                        Timestamp: time.Now(),
                }
                d.approvedUsers[req.UserID] = au // update approved users status in memory
                if d.userStorage != nil </span><span class="cov0" title="0">{
                        // update approved users status in storage
                        _ = d.userStorage.Write(ctx, au) // ignore error, failed to write to storage is not critical here
                }</span>
        }
        <span class="cov4" title="89">d.hamHistory.Push(req)
        return false, cr</span>
}

// Reset resets spam samples/classifier, excluded tokens, stop words and approved users.
func (d *Detector) Reset() <span class="cov1" title="2">{
        d.lock.Lock()
        defer d.lock.Unlock()

        d.tokenizedSpam = []map[string]int{}
        d.excludedTokens = map[string]struct{}{}
        d.classifier.reset()
        d.approvedUsers = make(map[string]approved.UserInfo)
        d.stopWords = []string{}

        // close the Lua engine and reset Lua checks if it exists
        if d.luaEngine != nil </span><span class="cov1" title="1">{
                d.luaEngine.Close()
                d.luaEngine = nil
                d.luaChecks = nil
        }</span>
}

// WithOpenAIChecker sets an openAIChecker for spam checking.
func (d *Detector) WithOpenAIChecker(client openAIClient, config OpenAIConfig) <span class="cov2" title="7">{
        d.openaiChecker = newOpenAIChecker(client, config)
}</span>

// WithLuaEngine sets a Lua plugin engine and loads plugins
func (d *Detector) WithLuaEngine(engine LuaPluginEngine) error <span class="cov2" title="9">{
        d.luaEngine = engine

        if !d.LuaPlugins.Enabled || d.LuaPlugins.PluginsDir == "" </span><span class="cov1" title="3">{
                return nil
        }</span>

        // load all plugins from the directory
        <span class="cov2" title="6">if err := d.luaEngine.LoadDirectory(d.LuaPlugins.PluginsDir); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to load Lua plugins: %w", err)
        }</span>

        // register enabled plugins as Lua checks
        <span class="cov2" title="5">if len(d.LuaPlugins.EnabledPlugins) &gt; 0 </span><span class="cov1" title="3">{
                for _, name := range d.LuaPlugins.EnabledPlugins </span><span class="cov2" title="6">{
                        pluginCheck, err := d.luaEngine.GetCheck(name)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to get Lua check %q: %w", name, err)
                        }</span>
                        // add to luaChecks
                        <span class="cov2" title="5">d.luaChecks = append(d.luaChecks, pluginCheck)</span>
                }
        } else<span class="cov1" title="2"> {
                // if no specific plugins are enabled, load all
                allChecks := d.luaEngine.GetAllChecks()
                for _, pluginCheck := range allChecks </span><span class="cov1" title="3">{
                        // add to luaChecks
                        d.luaChecks = append(d.luaChecks, pluginCheck)
                }</span>
        }

        // set up a watcher for dynamic plugin reloading if enabled
        <span class="cov2" title="4">if d.LuaPlugins.DynamicReload </span><span class="cov1" title="1">{
                // we need to cast the luaEngine to a *plugin.Checker to access the watcher methods
                checker, ok := d.luaEngine.(*plugin.Checker)
                if !ok </span><span class="cov0" title="0">{
                        log.Printf("[WARN] dynamic Lua plugin reloading enabled but engine doesn't support it")
                        return nil
                }</span>

                // create a watcher for the plugins directory
                <span class="cov1" title="1">watcher, err := plugin.NewWatcher(checker, d.LuaPlugins.PluginsDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create watcher for Lua plugins: %w", err)
                }</span>

                // set the watcher on the checker
                <span class="cov1" title="1">checker.SetWatcher(watcher)

                // start the watcher
                if err := watcher.Start(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start watcher for Lua plugins: %w", err)
                }</span>
        }

        <span class="cov2" title="4">return nil</span>
}

// WithUserStorage sets a UserStorage for approved users and loads approved users from it.
func (d *Detector) WithUserStorage(storage UserStorage) (count int, err error) <span class="cov2" title="6">{
        d.lock.Lock()
        defer d.lock.Unlock()
        d.approvedUsers = make(map[string]approved.UserInfo) // reset approved users
        d.userStorage = storage

        ctx, cancel := d.ctxWithStoreTimeout()
        defer cancel()

        users, err := d.userStorage.Read(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read approved users from storage: %w", err)
        }</span>
        <span class="cov2" title="6">for _, user := range users </span><span class="cov3" title="12">{
                user.Count = d.FirstMessagesCount + 1 // +1 to skip first message check if count is 0
                d.approvedUsers[user.UserID] = user
        }</span>
        <span class="cov2" title="6">return len(users), nil</span>
}

// WithMetaChecks sets a list of meta-checkers.
func (d *Detector) WithMetaChecks(mc ...MetaCheck) <span class="cov1" title="1">{
        d.metaChecks = append(d.metaChecks, mc...)
}</span>

// WithSpamUpdater sets a SampleUpdater for spam samples.
func (d *Detector) WithSpamUpdater(s SampleUpdater) <span class="cov1" title="3">{ d.spamSamplesUpd = s }</span>

// WithHamUpdater sets a SampleUpdater for ham samples.
func (d *Detector) WithHamUpdater(s SampleUpdater) <span class="cov1" title="2">{ d.hamSamplesUpd = s }</span>

// ApprovedUsers returns a list of approved users.
func (d *Detector) ApprovedUsers() (res []approved.UserInfo) <span class="cov1" title="1">{
        d.lock.RLock()
        defer d.lock.RUnlock()
        res = make([]approved.UserInfo, 0, len(d.approvedUsers))
        for _, info := range d.approvedUsers </span><span class="cov1" title="3">{
                res = append(res, info)
        }</span>
        <span class="cov1" title="1">sort.Slice(res, func(i, j int) bool </span><span class="cov1" title="2">{
                return res[i].Timestamp.After(res[j].Timestamp)
        }</span>)
        <span class="cov1" title="1">return res</span>
}

// IsApprovedUser checks if a given user ID is approved.
// It uses memory cache for approved users and compares the count of messages sent by the user.
func (d *Detector) IsApprovedUser(userID string) bool <span class="cov2" title="9">{
        d.lock.RLock()
        defer d.lock.RUnlock()

        ui, ok := d.approvedUsers[userID]
        if !ok </span><span class="cov1" title="3">{
                return false
        }</span>
        <span class="cov2" title="6">return ui.Count &gt; d.FirstMessagesCount</span>
}

// AddApprovedUser adds user IDs to the list of approved users.
func (d *Detector) AddApprovedUser(user approved.UserInfo) error <span class="cov2" title="5">{
        d.lock.Lock()
        defer d.lock.Unlock()
        ts := user.Timestamp
        if ts.IsZero() </span><span class="cov2" title="5">{
                ts = time.Now()
        }</span>
        <span class="cov2" title="5">d.approvedUsers[user.UserID] = approved.UserInfo{
                UserID:    user.UserID,
                UserName:  user.UserName,
                Count:     d.FirstMessagesCount + 1, // +1 to skip first message check if count is 0
                Timestamp: ts,
        }

        if d.userStorage != nil </span><span class="cov1" title="3">{
                ctx, cancel := d.ctxWithStoreTimeout()
                defer cancel()
                if err := d.userStorage.Write(ctx, user); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write approved user %+v to storage: %w", user, err)
                }</span>
        }
        <span class="cov2" title="5">return nil</span>
}

// RemoveApprovedUser removes approved user for given IDs
func (d *Detector) RemoveApprovedUser(id string) error <span class="cov1" title="2">{
        d.lock.Lock()
        delete(d.approvedUsers, id)
        d.lock.Unlock()

        if d.userStorage != nil </span><span class="cov1" title="1">{
                ctx, cancel := d.ctxWithStoreTimeout()
                defer cancel()
                if err := d.userStorage.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete approved user %s from storage: %w", id, err)
                }</span>
        }
        <span class="cov1" title="2">return nil</span>
}

// GetLuaPluginNames returns the list of available Lua plugin names.
func (d *Detector) GetLuaPluginNames() []string <span class="cov2" title="5">{
        d.lock.RLock()
        defer d.lock.RUnlock()

        if d.luaEngine == nil || !d.LuaPlugins.Enabled </span><span class="cov1" title="2">{
                return []string{}
        }</span>

        <span class="cov1" title="3">allChecks := d.luaEngine.GetAllChecks()
        result := make([]string, 0, len(allChecks))

        for name := range allChecks </span><span class="cov2" title="5">{
                result = append(result, name)
        }</span>

        // sort the result for consistent output
        <span class="cov1" title="3">sort.Strings(result)
        return result</span>
}

// LoadSamples loads spam samples from a reader and updates the classifier.
// Reset spam, ham samples/classifier, and excluded tokens.
func (d *Detector) LoadSamples(exclReader io.Reader, spamReaders, hamReaders []io.Reader) (LoadResult, error) <span class="cov3" title="12">{
        d.lock.Lock()
        defer d.lock.Unlock()

        d.tokenizedSpam = []map[string]int{}
        d.excludedTokens = map[string]struct{}{}
        d.classifier.reset()

        // excluded tokens should be loaded before spam samples to exclude them from spam tokenization
        for t := range d.readerIterator(exclReader) </span><span class="cov3" title="11">{
                d.excludedTokens[strings.ToLower(t)] = struct{}{}
        }</span>
        <span class="cov3" title="12">lr := LoadResult{ExcludedTokens: len(d.excludedTokens)}

        // load spam samples and update the classifier with them
        docs := []document{}
        for token := range d.readerIterator(spamReaders...) </span><span class="cov3" title="18">{
                tokenizedSpam := d.tokenize(token)
                d.tokenizedSpam = append(d.tokenizedSpam, tokenizedSpam) // add to list of samples
                tokens := make([]string, 0, len(tokenizedSpam))
                for token := range tokenizedSpam </span><span class="cov4" title="44">{
                        tokens = append(tokens, token)
                }</span>
                <span class="cov3" title="18">docs = append(docs, newDocument(ClassSpam, tokens...))
                lr.SpamSamples++</span>
        }

        // load ham samples and update the classifier with them
        <span class="cov3" title="12">for token := range d.readerIterator(hamReaders...) </span><span class="cov3" title="26">{
                tokenizedSpam := d.tokenize(token)
                tokens := make([]string, 0, len(tokenizedSpam))
                for token := range tokenizedSpam </span><span class="cov4" title="67">{
                        tokens = append(tokens, token)
                }</span>
                <span class="cov3" title="26">docs = append(docs, document{spamClass: ClassHam, tokens: tokens})
                lr.HamSamples++</span>
        }

        <span class="cov3" title="12">d.classifier.learn(docs...)
        return lr, nil</span>
}

// LoadStopWords loads stop words from a reader. Reset stop words list before loading.
func (d *Detector) LoadStopWords(readers ...io.Reader) (LoadResult, error) <span class="cov3" title="16">{
        d.lock.Lock()
        defer d.lock.Unlock()

        d.stopWords = []string{}
        for t := range d.readerIterator(readers...) </span><span class="cov3" title="29">{
                d.stopWords = append(d.stopWords, strings.ToLower(t))
        }</span>
        <span class="cov3" title="16">return LoadResult{StopWords: len(d.stopWords)}, nil</span>
}

// UpdateSpam appends a message to the spam samples file and updates the classifier
func (d *Detector) UpdateSpam(msg string) error <span class="cov1" title="2">{
        return d.updateSample(msg, d.spamSamplesUpd, ClassSpam)
}</span>

// UpdateHam appends a message to the ham samples file and updates the classifier
func (d *Detector) UpdateHam(msg string) error <span class="cov1" title="1">{
        return d.updateSample(msg, d.hamSamplesUpd, ClassHam)
}</span>

// RemoveSpam removes a message from the spam samples file and updates the classifier by unlearning
func (d *Detector) RemoveSpam(msg string) error <span class="cov1" title="3">{
        return d.removeSample(msg, d.spamSamplesUpd, ClassSpam)
}</span>

// RemoveHam removes a message from the ham samples file and updates the classifier by unlearning
func (d *Detector) RemoveHam(msg string) error <span class="cov1" title="2">{
        return d.removeSample(msg, d.hamSamplesUpd, ClassHam)
}</span>

// updateSample appends a message to the samples store and updates the classifier
// doesn't reset state, update append samples
func (d *Detector) updateSample(msg string, upd SampleUpdater, sc spamClass) error <span class="cov1" title="3">{
        d.lock.Lock()
        defer d.lock.Unlock()

        if upd == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // write to dynamic samples storage
        <span class="cov1" title="3">if err := upd.Append(msg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't update %s samples: %w", sc, err)
        }</span>

        // load samples and update the classifier with them
        <span class="cov1" title="3">docs := d.buildDocs(msg, sc)
        d.classifier.learn(docs...)

        // update tokenized spam samples for similarity check
        if sc == ClassSpam </span><span class="cov1" title="2">{
                tokenizedSpam := d.tokenize(msg)
                d.tokenizedSpam = append(d.tokenizedSpam, tokenizedSpam)
        }</span>

        <span class="cov1" title="3">return nil</span>
}

// removeSample removes a message from the spam samples file and updates the classifier by unlearning
func (d *Detector) removeSample(msg string, upd SampleUpdater, sc spamClass) error <span class="cov2" title="5">{
        d.lock.Lock()
        defer d.lock.Unlock()

        if upd == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // first validate that we can unlearn this sample
        <span class="cov2" title="5">docs := d.buildDocs(msg, sc)
        if err := d.classifier.unlearn(docs...); err != nil </span><span class="cov1" title="2">{
                return fmt.Errorf("can't unlearn %s samples: %w", sc, err)
        }</span>

        // if unlearn succeeded, remove from storage
        <span class="cov1" title="3">if err := upd.Remove(msg); err != nil </span><span class="cov1" title="1">{
                // try to relearn since storage update failed
                d.classifier.learn(docs...)
                return fmt.Errorf("can't remove %s samples: %w", sc, err)
        }</span>
        <span class="cov1" title="2">return nil</span>
}

// buildDocs builds a list of classifier documents from a message
func (d *Detector) buildDocs(msg string, sc spamClass) []document <span class="cov2" title="9">{
        docs := []document{}
        for token := range d.readerIterator(bytes.NewBufferString(msg)) </span><span class="cov2" title="9">{
                tokenizedSample := d.tokenize(token)
                tokens := make([]string, 0, len(tokenizedSample))
                for token := range tokenizedSample </span><span class="cov3" title="24">{
                        tokens = append(tokens, token)
                }</span>
                <span class="cov2" title="9">docs = append(docs, document{spamClass: sc, tokens: tokens})</span>
        }
        <span class="cov2" title="9">return docs</span>
}

// readerIterator parses readers and returns an iterator of data elements, each line is an element.
func (d *Detector) readerIterator(readers ...io.Reader) iter.Seq[string] <span class="cov4" title="69">{
        return func(yield func(string) bool) </span><span class="cov4" title="69">{
                for _, reader := range readers </span><span class="cov4" title="69">{
                        scanner := bufio.NewScanner(reader)
                        for scanner.Scan() </span><span class="cov4" title="112">{
                                line := scanner.Text()
                                // each line with a single element
                                cleanToken := strings.Trim(line, " \n\r\t")
                                if cleanToken != "" </span><span class="cov4" title="108">{
                                        if !yield(cleanToken) </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                        }

                        <span class="cov4" title="69">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[WARN] failed to read tokens, error=%v", err)
                        }</span>
                }
        }
}

// tokenize takes a string and returns a map where the keys are unique words (tokens)
// and the values are the frequencies of those words in the string.
// exclude tokens representing common words.
func (d *Detector) tokenize(inp string) map[string]int <span class="cov4" title="87">{
        isExcludedToken := func(token string) bool </span><span class="cov5" title="310">{
                if _, ok := d.excludedTokens[strings.ToLower(token)]; ok </span><span class="cov3" title="13">{
                        return true
                }</span>
                <span class="cov5" title="297">return false</span>
        }

        <span class="cov4" title="87">tokenFrequency := make(map[string]int)
        tokens := strings.Fields(inp)
        for _, token := range tokens </span><span class="cov5" title="310">{
                if isExcludedToken(token) </span><span class="cov3" title="13">{
                        continue</span>
                }
                <span class="cov5" title="297">token = cleanEmoji(token)
                token = strings.Trim(token, ".,!?-:;()#")
                token = strings.ToLower(token)
                if len([]rune(token)) &lt; 3 </span><span class="cov3" title="22">{
                        continue</span>
                }
                <span class="cov5" title="275">tokenFrequency[strings.ToLower(token)]++</span>
        }
        <span class="cov4" title="87">return tokenFrequency</span>
}

// isSpam checks if a given message is similar to any of the known bad messages
func (d *Detector) isSpamSimilarityHigh(msg string) spamcheck.Response <span class="cov2" title="6">{
        // check for spam similarity
        tokenizedMessage := d.tokenize(msg)
        maxSimilarity := 0.0
        for _, spam := range d.tokenizedSpam </span><span class="cov2" title="10">{
                similarity := d.cosineSimilarity(tokenizedMessage, spam)
                if similarity &gt; maxSimilarity </span><span class="cov2" title="5">{
                        maxSimilarity = similarity
                }</span>
                <span class="cov2" title="10">if similarity &gt;= d.SimilarityThreshold </span><span class="cov1" title="3">{
                        return spamcheck.Response{Spam: true, Name: "similarity",
                                Details: fmt.Sprintf("%0.2f/%0.2f", maxSimilarity, d.SimilarityThreshold)}
                }</span>
        }
        <span class="cov1" title="3">return spamcheck.Response{Spam: false, Name: "similarity", Details: fmt.Sprintf("%0.2f/%0.2f", maxSimilarity, d.SimilarityThreshold)}</span>
}

// cosineSimilarity calculates the cosine similarity between two token frequency maps.
func (d *Detector) cosineSimilarity(a, b map[string]int) float64 <span class="cov2" title="10">{
        if len(a) == 0 || len(b) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov2" title="10">dotProduct := 0      // sum of product of corresponding frequencies
        normA, normB := 0, 0 // square root of sum of squares of frequencies

        for key, val := range a </span><span class="cov3" title="34">{
                dotProduct += val * b[key]
                normA += val * val
        }</span>
        <span class="cov2" title="10">for _, val := range b </span><span class="cov3" title="26">{
                normB += val * val
        }</span>

        <span class="cov2" title="10">if normA == 0 || normB == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // cosine similarity formula
        <span class="cov2" title="10">return float64(dotProduct) / (math.Sqrt(float64(normA)) * math.Sqrt(float64(normB)))</span>
}

// isCasSpam checks if a given user ID is a spammer with CAS API.
func (d *Detector) isCasSpam(msgID string) spamcheck.Response <span class="cov2" title="8">{
        if msgID == "" </span><span class="cov1" title="1">{
                return spamcheck.Response{Spam: false, Name: "cas", Details: "check disabled"}
        }</span>
        <span class="cov2" title="7">if _, err := strconv.ParseInt(msgID, 10, 64); err != nil </span><span class="cov0" title="0">{
                return spamcheck.Response{Spam: false, Name: "cas", Details: fmt.Sprintf("invalid user id %q", msgID)}
        }</span>
        <span class="cov2" title="7">reqURL := fmt.Sprintf("%s/check?user_id=%s", d.CasAPI, msgID)
        req, err := http.NewRequest("GET", reqURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return spamcheck.Response{Spam: false, Name: "cas", Details: fmt.Sprintf("failed to make request %s: %v", reqURL, err)}
        }</span>

        <span class="cov2" title="7">if d.CasUserAgent != "" </span><span class="cov1" title="1">{
                req.Header.Set("User-Agent", d.CasUserAgent)
        }</span>

        <span class="cov2" title="7">resp, err := d.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return spamcheck.Response{Spam: false, Name: "cas", Details: fmt.Sprintf("ffailed to send request %s: %v", reqURL, err)}
        }</span>
        <span class="cov2" title="7">defer resp.Body.Close()

        respData := struct {
                OK          bool   `json:"ok"` // ok means user is a spammer
                Description string `json:"description"`
        }{}

        if err := json.NewDecoder(resp.Body).Decode(&amp;respData); err != nil </span><span class="cov0" title="0">{
                return spamcheck.Response{Spam: false, Name: "cas", Details: fmt.Sprintf("failed to parse response from %s: %v", reqURL, err)}
        }</span>
        <span class="cov2" title="7">respData.Description = strings.ToLower(respData.Description)
        respData.Description = strings.TrimSuffix(respData.Description, ".")

        if respData.OK </span><span class="cov1" title="2">{
                // may return empty description on detected spam
                if respData.Description == "" </span><span class="cov1" title="1">{
                        respData.Description = "spam detected"
                }</span>
                <span class="cov1" title="2">return spamcheck.Response{Name: "cas", Spam: true, Details: respData.Description}</span>
        }
        <span class="cov2" title="5">details := respData.Description
        if details == "" </span><span class="cov0" title="0">{
                details = "not found"
        }</span>
        <span class="cov2" title="5">return spamcheck.Response{Name: "cas", Spam: false, Details: details}</span>
}

// isSpamClassified classify tokens from a document
func (d *Detector) isSpamClassified(msg string) spamcheck.Response <span class="cov3" title="21">{
        tm := d.tokenize(msg)
        tokens := make([]string, 0, len(tm))
        for token := range tm </span><span class="cov4" title="100">{
                tokens = append(tokens, token)
        }</span>
        <span class="cov3" title="21">class, prob, certain := d.classifier.classify(tokens...)
        isSpam := class == ClassSpam &amp;&amp; certain &amp;&amp; (d.MinSpamProbability == 0 || prob &gt;= d.MinSpamProbability)

        // handle NaN or infinite probability values
        probStr := "0.00"
        if !math.IsNaN(prob) &amp;&amp; !math.IsInf(prob, 0) </span><span class="cov3" title="21">{
                probStr = fmt.Sprintf("%.2f", prob)
        }</span>

        <span class="cov3" title="21">return spamcheck.Response{Name: "classifier", Spam: isSpam,
                Details: fmt.Sprintf("probability of %s: %s%%", class, probStr)}</span>
}

// isStopWord checks if a given message or username contains any of the stop words.
func (d *Detector) isStopWord(msg string, req spamcheck.Request) spamcheck.Response <span class="cov3" title="23">{
        // check message text
        cleanMsg := cleanEmoji(strings.ToLower(msg))
        for _, word := range d.stopWords </span><span class="cov4" title="46">{ // stop words are already lowercased
                if strings.Contains(cleanMsg, strings.ToLower(word)) </span><span class="cov3" title="13">{
                        return spamcheck.Response{Name: "stopword", Spam: true, Details: word}
                }</span>
        }

        // check username and user id if they are not empty for stop words
        <span class="cov2" title="10">names := []string{}
        if req.UserName != "" </span><span class="cov2" title="5">{
                names = append(names, req.UserName)
        }</span>
        <span class="cov2" title="10">if req.UserID != "" </span><span class="cov2" title="7">{
                names = append(names, req.UserID)
        }</span>
        <span class="cov2" title="10">for _, name := range names </span><span class="cov2" title="10">{
                for _, word := range d.stopWords </span><span class="cov3" title="34">{
                        if strings.Contains(strings.ToLower(name), strings.ToLower(word)) </span><span class="cov1" title="3">{
                                return spamcheck.Response{Name: "stopword", Spam: true, Details: word}
                        }</span>
                }
        }

        <span class="cov2" title="7">return spamcheck.Response{Name: "stopword", Spam: false, Details: "not found"}</span>
}

// isManyEmojis checks if a given message contains more than MaxAllowedEmoji emojis.
func (d *Detector) isManyEmojis(msg string) spamcheck.Response <span class="cov4" title="45">{
        count := countEmoji(msg)
        return spamcheck.Response{Name: "emoji", Spam: count &gt; d.MaxAllowedEmoji, Details: fmt.Sprintf("%d/%d", count, d.MaxAllowedEmoji)}
}</span>

// isMultiLang checks if a given message contains more than MultiLangWords multi-lingual words.
func (d *Detector) isMultiLang(msg string) spamcheck.Response <span class="cov3" title="15">{
        isMultiLingual := func(word string) bool </span><span class="cov5" title="158">{
                scripts := make(map[string]bool)
                for _, r := range word </span><span class="cov6" title="662">{
                        if r == 'i' || unicode.IsSpace(r) || unicode.IsNumber(r) </span><span class="cov4" title="41">{ // skip 'i' (common in many langs) and spaces
                                continue</span>
                        }

                        <span class="cov6" title="621">scriptFound := false
                        for name, table := range unicode.Scripts </span><span class="cov10" title="48482">{
                                if unicode.Is(table, r) </span><span class="cov6" title="621">{
                                        if name != "Common" &amp;&amp; name != "Inherited" </span><span class="cov6" title="566">{
                                                scripts[name] = true
                                                if len(scripts) &gt; 1 </span><span class="cov4" title="58">{
                                                        return true
                                                }</span>
                                                <span class="cov6" title="508">scriptFound = true</span>
                                        }
                                        <span class="cov6" title="563">break</span>
                                }
                        }

                        // if no specific script was found, it might be a symbol or punctuation
                        <span class="cov6" title="563">if !scriptFound </span><span class="cov4" title="55">{
                                // check for mathematical alphanumeric symbols and letterlike symbols
                                if unicode.In(r, unicode.Other_Math, unicode.Other_Alphabetic) ||
                                        (r &gt;= '\U0001D400' &amp;&amp; r &lt;= '\U0001D7FF') || // mathematical Alphanumeric Symbols
                                        (r &gt;= '\u2100' &amp;&amp; r &lt;= '\u214F') </span><span class="cov2" title="10">{ // letterlike Symbols
                                        scripts["Mathematical"] = true
                                        if len(scripts) &gt; 1 </span><span class="cov2" title="5">{
                                                return true
                                        }</span>
                                } else<span class="cov4" title="45"> if !unicode.IsPunct(r) &amp;&amp; !unicode.IsSymbol(r) </span><span class="cov1" title="1">{
                                        // if it's not punctuation or a symbol, count it as "Other"
                                        scripts["Other"] = true
                                        if len(scripts) &gt; 1 </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
                <span class="cov4" title="95">return false</span>
        }

        <span class="cov3" title="15">count := 0
        words := strings.FieldsFunc(msg, func(r rune) bool </span><span class="cov6" title="1032">{
                return unicode.IsSpace(r) || r == '-'
        }</span>)
        <span class="cov3" title="15">for _, word := range words </span><span class="cov5" title="158">{
                if isMultiLingual(word) </span><span class="cov4" title="63">{
                        count++
                }</span>
        }
        <span class="cov3" title="15">if count &gt;= d.MultiLangWords </span><span class="cov2" title="7">{
                return spamcheck.Response{Name: "multi-lingual", Spam: true, Details: fmt.Sprintf("%d/%d", count, d.MultiLangWords)}
        }</span>
        <span class="cov2" title="8">return spamcheck.Response{Name: "multi-lingual", Spam: false, Details: fmt.Sprintf("%d/%d", count, d.MultiLangWords)}</span>
}

// isAbnormalSpacing detects abnormal spacing patterns used to evade filters
// things like this: "w o r d s p a c i n g some thing he re blah blah"
func (d *Detector) isAbnormalSpacing(msg string) spamcheck.Response <span class="cov3" title="13">{
        text := strings.ToUpper(msg)

        // quick check for empty or very short text
        if len(text) &lt; 10 </span><span class="cov1" title="2">{
                return spamcheck.Response{
                        Name:    "word-spacing",
                        Spam:    false,
                        Details: "too short",
                }
        }</span>

        <span class="cov3" title="11">words := strings.Fields(text)
        // check for minimum number of words
        if len(words) &lt; d.AbnormalSpacing.MinWordsCount </span><span class="cov1" title="1">{
                return spamcheck.Response{
                        Name:    "word-spacing",
                        Spam:    false,
                        Details: fmt.Sprintf("too few words (%d)", len(words)),
                }
        }</span>

        // count letters and spaces in original text
        <span class="cov2" title="10">var totalChars, spaces int
        for _, r := range text </span><span class="cov6" title="1329">{
                if unicode.IsLetter(r) </span><span class="cov6" title="995">{
                        totalChars++
                }</span> else<span class="cov5" title="334"> if unicode.IsSpace(r) </span><span class="cov5" title="311">{
                        spaces++
                }</span>
        }

        // look for suspicious word lengths and spacing patterns
        <span class="cov2" title="10">shortWords := 0
        if d.AbnormalSpacing.ShortWordLen &gt; 0 </span><span class="cov2" title="9">{ // if ShortWordLen is 0, skip short word detection
                for _, word := range words </span><span class="cov5" title="278">{
                        wordRunes := []rune(word)
                        if len(wordRunes) &lt;= d.AbnormalSpacing.ShortWordLen &amp;&amp; len(wordRunes) &gt; 0 </span><span class="cov5" title="165">{
                                shortWords++
                        }</span>
                }
        }

        // safety check
        <span class="cov2" title="10">if spaces == 0 || totalChars == 0 </span><span class="cov0" title="0">{
                return spamcheck.Response{
                        Name:    "word-spacing",
                        Spam:    false,
                        Details: "no spaces or letters",
                }
        }</span>

        // calculate ratios
        <span class="cov2" title="10">spaceRatio := float64(spaces) / float64(totalChars)
        shortWordRatio := float64(shortWords) / float64(len(words))
        if shortWordRatio &gt; d.AbnormalSpacing.ShortWordRatioThreshold || spaceRatio &gt; d.AbnormalSpacing.SpaceRatioThreshold </span><span class="cov2" title="6">{
                return spamcheck.Response{
                        Name:    "word-spacing",
                        Spam:    true,
                        Details: fmt.Sprintf("abnormal (ratio: %.2f, short: %.0f%%)", spaceRatio, shortWordRatio*100),
                }
        }</span>

        <span class="cov2" title="4">return spamcheck.Response{
                Name:    "word-spacing",
                Spam:    false,
                Details: fmt.Sprintf("normal (ratio: %.2f, short: %.0f%%)", spaceRatio, shortWordRatio*100),
        }</span>
}

// cleanText removes control and format characters from a given text
func (d *Detector) cleanText(text string) string <span class="cov5" title="162">{
        var result strings.Builder
        result.Grow(len(text))
        for _, r := range text </span><span class="cov9" title="16422">{
                // skip control and format characters
                if unicode.Is(unicode.Cc, r) || unicode.Is(unicode.Cf, r) </span><span class="cov4" title="45">{
                        continue</span>
                }
                // skip specific ranges of invisible characters
                <span class="cov9" title="16377">if (r &gt;= 0x200B &amp;&amp; r &lt;= 0x200F) || (r &gt;= 0x2060 &amp;&amp; r &lt;= 0x206F) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="16377">result.WriteRune(r)</span>
        }
        <span class="cov5" title="162">return result.String()</span>
}

func (d *Detector) ctxWithStoreTimeout() (context.Context, context.CancelFunc) <span class="cov3" title="23">{
        if d.StorageTimeout == 0 </span><span class="cov3" title="23">{
                return context.Background(), func() </span>{<span class="cov3" title="23">}</span>
        }
        <span class="cov0" title="0">return context.WithTimeout(context.Background(), d.StorageTimeout)</span>
}

func cleanEmoji(s string) string <span class="cov5" title="328">{
        return gomoji.RemoveEmojis(s)
}</span>

func countEmoji(s string) int <span class="cov4" title="56">{
        return len(gomoji.CollectAll(s))
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package tgspam

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/umputun/tg-spam/lib/spamcheck"
)

// MetaCheck represents a function type that takes a `spamcheck.Request` as input and returns a boolean value and a `spamcheck.Response`.
// The boolean value indicates whether the check. It checks the message's meta.
type MetaCheck func(req spamcheck.Request) spamcheck.Response

// LinksCheck is a function that returns a MetaCheck function that checks the number of links in the message.
// It uses custom meta-info if it is provided, otherwise it counts the number of links in the message.
func LinksCheck(limit int) MetaCheck <span class="cov7" title="5">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov9" title="10">{
                links := req.Meta.Links
                if links == 0 </span><span class="cov8" title="8">{
                        links = strings.Count(req.Msg, "http://") + strings.Count(req.Msg, "https://")
                }</span>
                <span class="cov9" title="10">if links &gt; limit </span><span class="cov5" title="3">{
                        return spamcheck.Response{
                                Name:    "links",
                                Spam:    true,
                                Details: fmt.Sprintf("too many links %d/%d", links, limit),
                        }
                }</span>
                <span class="cov8" title="7">return spamcheck.Response{Spam: false, Name: "links", Details: fmt.Sprintf("links %d/%d", links, limit)}</span>
        }
}

var linkRe = regexp.MustCompile(`https?://\S+`)

// LinkOnlyCheck is a function that returns a MetaCheck function that checks if the req.Msg contains only links.
func LinkOnlyCheck() MetaCheck <span class="cov7" title="6">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov10" title="11">{
                if strings.TrimSpace(req.Msg) == "" </span><span class="cov3" title="2">{
                        return spamcheck.Response{
                                Name:    "link-only",
                                Spam:    false,
                                Details: "empty message",
                        }
                }</span>
                <span class="cov9" title="9">msgWithoutLinks := linkRe.ReplaceAllString(req.Msg, "")
                msgWithoutLinks = strings.TrimSpace(msgWithoutLinks)

                if msgWithoutLinks == "" </span><span class="cov5" title="3">{
                        return spamcheck.Response{
                                Name:    "link-only",
                                Spam:    true,
                                Details: "message contains links only",
                        }
                }</span>
                <span class="cov7" title="6">return spamcheck.Response{Spam: false, Name: "link-only", Details: "message contains text"}</span>
        }
}

// ImagesCheck is a function that returns a MetaCheck function.
// It checks if the number of images in the message is greater than zero and the message is empty (i.e. it contains only images).
func ImagesCheck() MetaCheck <span class="cov7" title="5">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov9" title="10">{
                if req.Meta.Images &gt; 0 &amp;&amp; req.Msg == "" </span><span class="cov5" title="3">{
                        return spamcheck.Response{
                                Name:    "images",
                                Spam:    true,
                                Details: "images without text",
                        }
                }</span>
                <span class="cov8" title="7">return spamcheck.Response{Spam: false, Name: "images", Details: "no images without text"}</span>
        }
}

// VideosCheck is a function that returns a MetaCheck function.
// It checks if the message has a video or video note and the message is empty (i.e. it contains only videos).
func VideosCheck() MetaCheck <span class="cov6" title="4">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov6" title="4">{
                if req.Meta.HasVideo &amp;&amp; req.Msg == "" </span><span class="cov3" title="2">{
                        return spamcheck.Response{
                                Name:    "videos",
                                Spam:    true,
                                Details: "videos without text",
                        }
                }</span>
                <span class="cov3" title="2">return spamcheck.Response{Spam: false, Name: "videos", Details: "no videos without text"}</span>
        }
}

// AudioCheck is a function that returns a MetaCheck function.
// It checks if the message has an audio and the message is empty (i.e. it contains only audio).
func AudioCheck() MetaCheck <span class="cov5" title="3">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov5" title="3">{
                if req.Meta.HasAudio &amp;&amp; req.Msg == "" </span><span class="cov1" title="1">{
                        return spamcheck.Response{
                                Name:    "audio",
                                Spam:    true,
                                Details: "audio without text",
                        }
                }</span>
                <span class="cov3" title="2">return spamcheck.Response{Spam: false, Name: "audio", Details: "no audio without text"}</span>
        }
}

// ForwardedCheck is a function that returns a MetaCheck function.
// It checks if the message is a forwarded message.
func ForwardedCheck() MetaCheck <span class="cov3" title="2">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov3" title="2">{
                if req.Meta.HasForward </span><span class="cov1" title="1">{
                        return spamcheck.Response{
                                Name:    "forward",
                                Spam:    true,
                                Details: "forwarded message",
                        }
                }</span>
                <span class="cov1" title="1">return spamcheck.Response{
                        Name:    "forward",
                        Spam:    false,
                        Details: "not a forwarded message",
                }</span>
        }
}

// KeyboardCheck is a function that returns a MetaCheck function.
// It checks if the message has a keyboard (buttons).
func KeyboardCheck() MetaCheck <span class="cov5" title="3">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov5" title="3">{
                if req.Meta.HasKeyboard </span><span class="cov3" title="2">{
                        return spamcheck.Response{
                                Name:    "keyboard",
                                Spam:    true,
                                Details: "message with keyboard",
                        }
                }</span>
                <span class="cov1" title="1">return spamcheck.Response{
                        Name:    "keyboard",
                        Spam:    false,
                        Details: "no keyboard",
                }</span>
        }
}

// MentionsCheck is a function that returns a MetaCheck function.
// It checks if the number of mentions in the message exceeds the specified limit.
// If limit is negative, the check is disabled.
func MentionsCheck(limit int) MetaCheck <span class="cov8" title="7">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov8" title="7">{
                if limit &lt; 0 </span><span class="cov1" title="1">{
                        return spamcheck.Response{
                                Name:    "mentions",
                                Spam:    false,
                                Details: "check disabled",
                        }
                }</span>
                <span class="cov7" title="6">if req.Meta.Mentions &gt; limit </span><span class="cov3" title="2">{
                        return spamcheck.Response{
                                Name:    "mentions",
                                Spam:    true,
                                Details: fmt.Sprintf("too many mentions %d/%d", req.Meta.Mentions, limit),
                        }
                }</span>
                <span class="cov6" title="4">return spamcheck.Response{
                        Name:    "mentions",
                        Spam:    false,
                        Details: fmt.Sprintf("mentions %d/%d", req.Meta.Mentions, limit),
                }</span>
        }
}

// UsernameSymbolsCheck is a function that returns a MetaCheck function.
// It checks if the username contains any of the prohibited symbols.
// If symbols is empty, the check is disabled.
func UsernameSymbolsCheck(symbols string) MetaCheck <span class="cov7" title="6">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov7" title="6">{
                if symbols == "" </span><span class="cov1" title="1">{
                        return spamcheck.Response{
                                Name:    "username-symbols",
                                Spam:    false,
                                Details: "check disabled",
                        }
                }</span>

                <span class="cov7" title="5">if req.UserName == "" </span><span class="cov1" title="1">{
                        return spamcheck.Response{
                                Name:    "username-symbols",
                                Spam:    false,
                                Details: "no username",
                        }
                }</span>

                <span class="cov6" title="4">for _, symbol := range symbols </span><span class="cov9" title="9">{
                        if strings.ContainsRune(req.UserName, symbol) </span><span class="cov3" title="2">{
                                return spamcheck.Response{
                                        Name:    "username-symbols",
                                        Spam:    true,
                                        Details: fmt.Sprintf("username contains prohibited symbol '%c'", symbol),
                                }
                        }</span>
                }

                <span class="cov3" title="2">return spamcheck.Response{
                        Name:    "username-symbols",
                        Spam:    false,
                        Details: "no prohibited symbols in username",
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "net/http"
        "sync"
)

// HTTPClientMock is a mock implementation of tgspam.HTTPClient.
//
//        func TestSomethingThatUsesHTTPClient(t *testing.T) {
//
//                // make and configure a mocked tgspam.HTTPClient
//                mockedHTTPClient := &amp;HTTPClientMock{
//                        DoFunc: func(req *http.Request) (*http.Response, error) {
//                                panic("mock out the Do method")
//                        },
//                }
//
//                // use mockedHTTPClient in code that requires tgspam.HTTPClient
//                // and then make assertions.
//
//        }
type HTTPClientMock struct {
        // DoFunc mocks the Do method.
        DoFunc func(req *http.Request) (*http.Response, error)

        // calls tracks calls to the methods.
        calls struct {
                // Do holds details about calls to the Do method.
                Do []struct {
                        // Req is the req argument value.
                        Req *http.Request
                }
        }
        lockDo sync.RWMutex
}

// Do calls DoFunc.
func (mock *HTTPClientMock) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        if mock.DoFunc == nil </span><span class="cov0" title="0">{
                panic("HTTPClientMock.DoFunc: method is nil but HTTPClient.Do was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Req *http.Request
        }{
                Req: req,
        }
        mock.lockDo.Lock()
        mock.calls.Do = append(mock.calls.Do, callInfo)
        mock.lockDo.Unlock()
        return mock.DoFunc(req)</span>
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//        len(mockedHTTPClient.DoCalls())
func (mock *HTTPClientMock) DoCalls() []struct {
        Req *http.Request
} <span class="cov0" title="0">{
        var calls []struct {
                Req *http.Request
        }
        mock.lockDo.RLock()
        calls = mock.calls.Do
        mock.lockDo.RUnlock()
        return calls
}</span>

// ResetDoCalls reset all the calls that were made to Do.
func (mock *HTTPClientMock) ResetDoCalls() <span class="cov0" title="0">{
        mock.lockDo.Lock()
        mock.calls.Do = nil
        mock.lockDo.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *HTTPClientMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockDo.Lock()
        mock.calls.Do = nil
        mock.lockDo.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "github.com/umputun/tg-spam/lib/tgspam/plugin"
        "sync"
)

// LuaPluginEngineMock is a mock implementation of tgspam.LuaPluginEngine.
//
//        func TestSomethingThatUsesLuaPluginEngine(t *testing.T) {
//
//                // make and configure a mocked tgspam.LuaPluginEngine
//                mockedLuaPluginEngine := &amp;LuaPluginEngineMock{
//                        CloseFunc: func()  {
//                                panic("mock out the Close method")
//                        },
//                        GetAllChecksFunc: func() map[string]plugin.Check {
//                                panic("mock out the GetAllChecks method")
//                        },
//                        GetCheckFunc: func(name string) (plugin.Check, error) {
//                                panic("mock out the GetCheck method")
//                        },
//                        LoadDirectoryFunc: func(dir string) error {
//                                panic("mock out the LoadDirectory method")
//                        },
//                        LoadScriptFunc: func(path string) error {
//                                panic("mock out the LoadScript method")
//                        },
//                        ReloadScriptFunc: func(path string) error {
//                                panic("mock out the ReloadScript method")
//                        },
//                }
//
//                // use mockedLuaPluginEngine in code that requires tgspam.LuaPluginEngine
//                // and then make assertions.
//
//        }
type LuaPluginEngineMock struct {
        // CloseFunc mocks the Close method.
        CloseFunc func()

        // GetAllChecksFunc mocks the GetAllChecks method.
        GetAllChecksFunc func() map[string]plugin.Check

        // GetCheckFunc mocks the GetCheck method.
        GetCheckFunc func(name string) (plugin.Check, error)

        // LoadDirectoryFunc mocks the LoadDirectory method.
        LoadDirectoryFunc func(dir string) error

        // LoadScriptFunc mocks the LoadScript method.
        LoadScriptFunc func(path string) error

        // ReloadScriptFunc mocks the ReloadScript method.
        ReloadScriptFunc func(path string) error

        // calls tracks calls to the methods.
        calls struct {
                // Close holds details about calls to the Close method.
                Close []struct {
                }
                // GetAllChecks holds details about calls to the GetAllChecks method.
                GetAllChecks []struct {
                }
                // GetCheck holds details about calls to the GetCheck method.
                GetCheck []struct {
                        // Name is the name argument value.
                        Name string
                }
                // LoadDirectory holds details about calls to the LoadDirectory method.
                LoadDirectory []struct {
                        // Dir is the dir argument value.
                        Dir string
                }
                // LoadScript holds details about calls to the LoadScript method.
                LoadScript []struct {
                        // Path is the path argument value.
                        Path string
                }
                // ReloadScript holds details about calls to the ReloadScript method.
                ReloadScript []struct {
                        // Path is the path argument value.
                        Path string
                }
        }
        lockClose         sync.RWMutex
        lockGetAllChecks  sync.RWMutex
        lockGetCheck      sync.RWMutex
        lockLoadDirectory sync.RWMutex
        lockLoadScript    sync.RWMutex
        lockReloadScript  sync.RWMutex
}

// Close calls CloseFunc.
func (mock *LuaPluginEngineMock) Close() <span class="cov0" title="0">{
        if mock.CloseFunc == nil </span><span class="cov0" title="0">{
                panic("LuaPluginEngineMock.CloseFunc: method is nil but LuaPluginEngine.Close was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockClose.Lock()
        mock.calls.Close = append(mock.calls.Close, callInfo)
        mock.lockClose.Unlock()
        mock.CloseFunc()</span>
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//        len(mockedLuaPluginEngine.CloseCalls())
func (mock *LuaPluginEngineMock) CloseCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockClose.RLock()
        calls = mock.calls.Close
        mock.lockClose.RUnlock()
        return calls
}</span>

// ResetCloseCalls reset all the calls that were made to Close.
func (mock *LuaPluginEngineMock) ResetCloseCalls() <span class="cov0" title="0">{
        mock.lockClose.Lock()
        mock.calls.Close = nil
        mock.lockClose.Unlock()
}</span>

// GetAllChecks calls GetAllChecksFunc.
func (mock *LuaPluginEngineMock) GetAllChecks() map[string]plugin.Check <span class="cov0" title="0">{
        if mock.GetAllChecksFunc == nil </span><span class="cov0" title="0">{
                panic("LuaPluginEngineMock.GetAllChecksFunc: method is nil but LuaPluginEngine.GetAllChecks was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockGetAllChecks.Lock()
        mock.calls.GetAllChecks = append(mock.calls.GetAllChecks, callInfo)
        mock.lockGetAllChecks.Unlock()
        return mock.GetAllChecksFunc()</span>
}

// GetAllChecksCalls gets all the calls that were made to GetAllChecks.
// Check the length with:
//
//        len(mockedLuaPluginEngine.GetAllChecksCalls())
func (mock *LuaPluginEngineMock) GetAllChecksCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockGetAllChecks.RLock()
        calls = mock.calls.GetAllChecks
        mock.lockGetAllChecks.RUnlock()
        return calls
}</span>

// ResetGetAllChecksCalls reset all the calls that were made to GetAllChecks.
func (mock *LuaPluginEngineMock) ResetGetAllChecksCalls() <span class="cov0" title="0">{
        mock.lockGetAllChecks.Lock()
        mock.calls.GetAllChecks = nil
        mock.lockGetAllChecks.Unlock()
}</span>

// GetCheck calls GetCheckFunc.
func (mock *LuaPluginEngineMock) GetCheck(name string) (plugin.Check, error) <span class="cov0" title="0">{
        if mock.GetCheckFunc == nil </span><span class="cov0" title="0">{
                panic("LuaPluginEngineMock.GetCheckFunc: method is nil but LuaPluginEngine.GetCheck was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Name string
        }{
                Name: name,
        }
        mock.lockGetCheck.Lock()
        mock.calls.GetCheck = append(mock.calls.GetCheck, callInfo)
        mock.lockGetCheck.Unlock()
        return mock.GetCheckFunc(name)</span>
}

// GetCheckCalls gets all the calls that were made to GetCheck.
// Check the length with:
//
//        len(mockedLuaPluginEngine.GetCheckCalls())
func (mock *LuaPluginEngineMock) GetCheckCalls() []struct {
        Name string
} <span class="cov0" title="0">{
        var calls []struct {
                Name string
        }
        mock.lockGetCheck.RLock()
        calls = mock.calls.GetCheck
        mock.lockGetCheck.RUnlock()
        return calls
}</span>

// ResetGetCheckCalls reset all the calls that were made to GetCheck.
func (mock *LuaPluginEngineMock) ResetGetCheckCalls() <span class="cov0" title="0">{
        mock.lockGetCheck.Lock()
        mock.calls.GetCheck = nil
        mock.lockGetCheck.Unlock()
}</span>

// LoadDirectory calls LoadDirectoryFunc.
func (mock *LuaPluginEngineMock) LoadDirectory(dir string) error <span class="cov0" title="0">{
        if mock.LoadDirectoryFunc == nil </span><span class="cov0" title="0">{
                panic("LuaPluginEngineMock.LoadDirectoryFunc: method is nil but LuaPluginEngine.LoadDirectory was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Dir string
        }{
                Dir: dir,
        }
        mock.lockLoadDirectory.Lock()
        mock.calls.LoadDirectory = append(mock.calls.LoadDirectory, callInfo)
        mock.lockLoadDirectory.Unlock()
        return mock.LoadDirectoryFunc(dir)</span>
}

// LoadDirectoryCalls gets all the calls that were made to LoadDirectory.
// Check the length with:
//
//        len(mockedLuaPluginEngine.LoadDirectoryCalls())
func (mock *LuaPluginEngineMock) LoadDirectoryCalls() []struct {
        Dir string
} <span class="cov0" title="0">{
        var calls []struct {
                Dir string
        }
        mock.lockLoadDirectory.RLock()
        calls = mock.calls.LoadDirectory
        mock.lockLoadDirectory.RUnlock()
        return calls
}</span>

// ResetLoadDirectoryCalls reset all the calls that were made to LoadDirectory.
func (mock *LuaPluginEngineMock) ResetLoadDirectoryCalls() <span class="cov0" title="0">{
        mock.lockLoadDirectory.Lock()
        mock.calls.LoadDirectory = nil
        mock.lockLoadDirectory.Unlock()
}</span>

// LoadScript calls LoadScriptFunc.
func (mock *LuaPluginEngineMock) LoadScript(path string) error <span class="cov0" title="0">{
        if mock.LoadScriptFunc == nil </span><span class="cov0" title="0">{
                panic("LuaPluginEngineMock.LoadScriptFunc: method is nil but LuaPluginEngine.LoadScript was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Path string
        }{
                Path: path,
        }
        mock.lockLoadScript.Lock()
        mock.calls.LoadScript = append(mock.calls.LoadScript, callInfo)
        mock.lockLoadScript.Unlock()
        return mock.LoadScriptFunc(path)</span>
}

// LoadScriptCalls gets all the calls that were made to LoadScript.
// Check the length with:
//
//        len(mockedLuaPluginEngine.LoadScriptCalls())
func (mock *LuaPluginEngineMock) LoadScriptCalls() []struct {
        Path string
} <span class="cov0" title="0">{
        var calls []struct {
                Path string
        }
        mock.lockLoadScript.RLock()
        calls = mock.calls.LoadScript
        mock.lockLoadScript.RUnlock()
        return calls
}</span>

// ResetLoadScriptCalls reset all the calls that were made to LoadScript.
func (mock *LuaPluginEngineMock) ResetLoadScriptCalls() <span class="cov0" title="0">{
        mock.lockLoadScript.Lock()
        mock.calls.LoadScript = nil
        mock.lockLoadScript.Unlock()
}</span>

// ReloadScript calls ReloadScriptFunc.
func (mock *LuaPluginEngineMock) ReloadScript(path string) error <span class="cov0" title="0">{
        if mock.ReloadScriptFunc == nil </span><span class="cov0" title="0">{
                panic("LuaPluginEngineMock.ReloadScriptFunc: method is nil but LuaPluginEngine.ReloadScript was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Path string
        }{
                Path: path,
        }
        mock.lockReloadScript.Lock()
        mock.calls.ReloadScript = append(mock.calls.ReloadScript, callInfo)
        mock.lockReloadScript.Unlock()
        return mock.ReloadScriptFunc(path)</span>
}

// ReloadScriptCalls gets all the calls that were made to ReloadScript.
// Check the length with:
//
//        len(mockedLuaPluginEngine.ReloadScriptCalls())
func (mock *LuaPluginEngineMock) ReloadScriptCalls() []struct {
        Path string
} <span class="cov0" title="0">{
        var calls []struct {
                Path string
        }
        mock.lockReloadScript.RLock()
        calls = mock.calls.ReloadScript
        mock.lockReloadScript.RUnlock()
        return calls
}</span>

// ResetReloadScriptCalls reset all the calls that were made to ReloadScript.
func (mock *LuaPluginEngineMock) ResetReloadScriptCalls() <span class="cov0" title="0">{
        mock.lockReloadScript.Lock()
        mock.calls.ReloadScript = nil
        mock.lockReloadScript.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *LuaPluginEngineMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockClose.Lock()
        mock.calls.Close = nil
        mock.lockClose.Unlock()

        mock.lockGetAllChecks.Lock()
        mock.calls.GetAllChecks = nil
        mock.lockGetAllChecks.Unlock()

        mock.lockGetCheck.Lock()
        mock.calls.GetCheck = nil
        mock.lockGetCheck.Unlock()

        mock.lockLoadDirectory.Lock()
        mock.calls.LoadDirectory = nil
        mock.lockLoadDirectory.Unlock()

        mock.lockLoadScript.Lock()
        mock.calls.LoadScript = nil
        mock.lockLoadScript.Unlock()

        mock.lockReloadScript.Lock()
        mock.calls.ReloadScript = nil
        mock.lockReloadScript.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/sashabaranov/go-openai"
        "sync"
)

// OpenAIClientMock is a mock implementation of tgspam.openAIClient.
//
//        func TestSomethingThatUsesopenAIClient(t *testing.T) {
//
//                // make and configure a mocked tgspam.openAIClient
//                mockedopenAIClient := &amp;OpenAIClientMock{
//                        CreateChatCompletionFunc: func(contextMoqParam context.Context, chatCompletionRequest openai.ChatCompletionRequest) (openai.ChatCompletionResponse, error) {
//                                panic("mock out the CreateChatCompletion method")
//                        },
//                }
//
//                // use mockedopenAIClient in code that requires tgspam.openAIClient
//                // and then make assertions.
//
//        }
type OpenAIClientMock struct {
        // CreateChatCompletionFunc mocks the CreateChatCompletion method.
        CreateChatCompletionFunc func(contextMoqParam context.Context, chatCompletionRequest openai.ChatCompletionRequest) (openai.ChatCompletionResponse, error)

        // calls tracks calls to the methods.
        calls struct {
                // CreateChatCompletion holds details about calls to the CreateChatCompletion method.
                CreateChatCompletion []struct {
                        // ContextMoqParam is the contextMoqParam argument value.
                        ContextMoqParam context.Context
                        // ChatCompletionRequest is the chatCompletionRequest argument value.
                        ChatCompletionRequest openai.ChatCompletionRequest
                }
        }
        lockCreateChatCompletion sync.RWMutex
}

// CreateChatCompletion calls CreateChatCompletionFunc.
func (mock *OpenAIClientMock) CreateChatCompletion(contextMoqParam context.Context, chatCompletionRequest openai.ChatCompletionRequest) (openai.ChatCompletionResponse, error) <span class="cov0" title="0">{
        if mock.CreateChatCompletionFunc == nil </span><span class="cov0" title="0">{
                panic("OpenAIClientMock.CreateChatCompletionFunc: method is nil but openAIClient.CreateChatCompletion was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                ContextMoqParam       context.Context
                ChatCompletionRequest openai.ChatCompletionRequest
        }{
                ContextMoqParam:       contextMoqParam,
                ChatCompletionRequest: chatCompletionRequest,
        }
        mock.lockCreateChatCompletion.Lock()
        mock.calls.CreateChatCompletion = append(mock.calls.CreateChatCompletion, callInfo)
        mock.lockCreateChatCompletion.Unlock()
        return mock.CreateChatCompletionFunc(contextMoqParam, chatCompletionRequest)</span>
}

// CreateChatCompletionCalls gets all the calls that were made to CreateChatCompletion.
// Check the length with:
//
//        len(mockedopenAIClient.CreateChatCompletionCalls())
func (mock *OpenAIClientMock) CreateChatCompletionCalls() []struct {
        ContextMoqParam       context.Context
        ChatCompletionRequest openai.ChatCompletionRequest
} <span class="cov0" title="0">{
        var calls []struct {
                ContextMoqParam       context.Context
                ChatCompletionRequest openai.ChatCompletionRequest
        }
        mock.lockCreateChatCompletion.RLock()
        calls = mock.calls.CreateChatCompletion
        mock.lockCreateChatCompletion.RUnlock()
        return calls
}</span>

// ResetCreateChatCompletionCalls reset all the calls that were made to CreateChatCompletion.
func (mock *OpenAIClientMock) ResetCreateChatCompletionCalls() <span class="cov0" title="0">{
        mock.lockCreateChatCompletion.Lock()
        mock.calls.CreateChatCompletion = nil
        mock.lockCreateChatCompletion.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *OpenAIClientMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockCreateChatCompletion.Lock()
        mock.calls.CreateChatCompletion = nil
        mock.lockCreateChatCompletion.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "io"
        "sync"
)

// SampleUpdaterMock is a mock implementation of tgspam.SampleUpdater.
//
//        func TestSomethingThatUsesSampleUpdater(t *testing.T) {
//
//                // make and configure a mocked tgspam.SampleUpdater
//                mockedSampleUpdater := &amp;SampleUpdaterMock{
//                        AppendFunc: func(msg string) error {
//                                panic("mock out the Append method")
//                        },
//                        ReaderFunc: func() (io.ReadCloser, error) {
//                                panic("mock out the Reader method")
//                        },
//                        RemoveFunc: func(msg string) error {
//                                panic("mock out the Remove method")
//                        },
//                }
//
//                // use mockedSampleUpdater in code that requires tgspam.SampleUpdater
//                // and then make assertions.
//
//        }
type SampleUpdaterMock struct {
        // AppendFunc mocks the Append method.
        AppendFunc func(msg string) error

        // ReaderFunc mocks the Reader method.
        ReaderFunc func() (io.ReadCloser, error)

        // RemoveFunc mocks the Remove method.
        RemoveFunc func(msg string) error

        // calls tracks calls to the methods.
        calls struct {
                // Append holds details about calls to the Append method.
                Append []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
                // Reader holds details about calls to the Reader method.
                Reader []struct {
                }
                // Remove holds details about calls to the Remove method.
                Remove []struct {
                        // Msg is the msg argument value.
                        Msg string
                }
        }
        lockAppend sync.RWMutex
        lockReader sync.RWMutex
        lockRemove sync.RWMutex
}

// Append calls AppendFunc.
func (mock *SampleUpdaterMock) Append(msg string) error <span class="cov0" title="0">{
        if mock.AppendFunc == nil </span><span class="cov0" title="0">{
                panic("SampleUpdaterMock.AppendFunc: method is nil but SampleUpdater.Append was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockAppend.Lock()
        mock.calls.Append = append(mock.calls.Append, callInfo)
        mock.lockAppend.Unlock()
        return mock.AppendFunc(msg)</span>
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//        len(mockedSampleUpdater.AppendCalls())
func (mock *SampleUpdaterMock) AppendCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockAppend.RLock()
        calls = mock.calls.Append
        mock.lockAppend.RUnlock()
        return calls
}</span>

// ResetAppendCalls reset all the calls that were made to Append.
func (mock *SampleUpdaterMock) ResetAppendCalls() <span class="cov0" title="0">{
        mock.lockAppend.Lock()
        mock.calls.Append = nil
        mock.lockAppend.Unlock()
}</span>

// Reader calls ReaderFunc.
func (mock *SampleUpdaterMock) Reader() (io.ReadCloser, error) <span class="cov0" title="0">{
        if mock.ReaderFunc == nil </span><span class="cov0" title="0">{
                panic("SampleUpdaterMock.ReaderFunc: method is nil but SampleUpdater.Reader was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
        }{}
        mock.lockReader.Lock()
        mock.calls.Reader = append(mock.calls.Reader, callInfo)
        mock.lockReader.Unlock()
        return mock.ReaderFunc()</span>
}

// ReaderCalls gets all the calls that were made to Reader.
// Check the length with:
//
//        len(mockedSampleUpdater.ReaderCalls())
func (mock *SampleUpdaterMock) ReaderCalls() []struct {
} <span class="cov0" title="0">{
        var calls []struct {
        }
        mock.lockReader.RLock()
        calls = mock.calls.Reader
        mock.lockReader.RUnlock()
        return calls
}</span>

// ResetReaderCalls reset all the calls that were made to Reader.
func (mock *SampleUpdaterMock) ResetReaderCalls() <span class="cov0" title="0">{
        mock.lockReader.Lock()
        mock.calls.Reader = nil
        mock.lockReader.Unlock()
}</span>

// Remove calls RemoveFunc.
func (mock *SampleUpdaterMock) Remove(msg string) error <span class="cov0" title="0">{
        if mock.RemoveFunc == nil </span><span class="cov0" title="0">{
                panic("SampleUpdaterMock.RemoveFunc: method is nil but SampleUpdater.Remove was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Msg string
        }{
                Msg: msg,
        }
        mock.lockRemove.Lock()
        mock.calls.Remove = append(mock.calls.Remove, callInfo)
        mock.lockRemove.Unlock()
        return mock.RemoveFunc(msg)</span>
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//        len(mockedSampleUpdater.RemoveCalls())
func (mock *SampleUpdaterMock) RemoveCalls() []struct {
        Msg string
} <span class="cov0" title="0">{
        var calls []struct {
                Msg string
        }
        mock.lockRemove.RLock()
        calls = mock.calls.Remove
        mock.lockRemove.RUnlock()
        return calls
}</span>

// ResetRemoveCalls reset all the calls that were made to Remove.
func (mock *SampleUpdaterMock) ResetRemoveCalls() <span class="cov0" title="0">{
        mock.lockRemove.Lock()
        mock.calls.Remove = nil
        mock.lockRemove.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SampleUpdaterMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockAppend.Lock()
        mock.calls.Append = nil
        mock.lockAppend.Unlock()

        mock.lockReader.Lock()
        mock.calls.Reader = nil
        mock.lockReader.Unlock()

        mock.lockRemove.Lock()
        mock.calls.Remove = nil
        mock.lockRemove.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
        "context"
        "github.com/umputun/tg-spam/lib/approved"
        "sync"
)

// UserStorageMock is a mock implementation of tgspam.UserStorage.
//
//        func TestSomethingThatUsesUserStorage(t *testing.T) {
//
//                // make and configure a mocked tgspam.UserStorage
//                mockedUserStorage := &amp;UserStorageMock{
//                        DeleteFunc: func(ctx context.Context, id string) error {
//                                panic("mock out the Delete method")
//                        },
//                        ReadFunc: func(ctx context.Context) ([]approved.UserInfo, error) {
//                                panic("mock out the Read method")
//                        },
//                        WriteFunc: func(ctx context.Context, au approved.UserInfo) error {
//                                panic("mock out the Write method")
//                        },
//                }
//
//                // use mockedUserStorage in code that requires tgspam.UserStorage
//                // and then make assertions.
//
//        }
type UserStorageMock struct {
        // DeleteFunc mocks the Delete method.
        DeleteFunc func(ctx context.Context, id string) error

        // ReadFunc mocks the Read method.
        ReadFunc func(ctx context.Context) ([]approved.UserInfo, error)

        // WriteFunc mocks the Write method.
        WriteFunc func(ctx context.Context, au approved.UserInfo) error

        // calls tracks calls to the methods.
        calls struct {
                // Delete holds details about calls to the Delete method.
                Delete []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // ID is the id argument value.
                        ID string
                }
                // Read holds details about calls to the Read method.
                Read []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                }
                // Write holds details about calls to the Write method.
                Write []struct {
                        // Ctx is the ctx argument value.
                        Ctx context.Context
                        // Au is the au argument value.
                        Au approved.UserInfo
                }
        }
        lockDelete sync.RWMutex
        lockRead   sync.RWMutex
        lockWrite  sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *UserStorageMock) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        if mock.DeleteFunc == nil </span><span class="cov0" title="0">{
                panic("UserStorageMock.DeleteFunc: method is nil but UserStorage.Delete was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                ID  string
        }{
                Ctx: ctx,
                ID:  id,
        }
        mock.lockDelete.Lock()
        mock.calls.Delete = append(mock.calls.Delete, callInfo)
        mock.lockDelete.Unlock()
        return mock.DeleteFunc(ctx, id)</span>
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//        len(mockedUserStorage.DeleteCalls())
func (mock *UserStorageMock) DeleteCalls() []struct {
        Ctx context.Context
        ID  string
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                ID  string
        }
        mock.lockDelete.RLock()
        calls = mock.calls.Delete
        mock.lockDelete.RUnlock()
        return calls
}</span>

// ResetDeleteCalls reset all the calls that were made to Delete.
func (mock *UserStorageMock) ResetDeleteCalls() <span class="cov0" title="0">{
        mock.lockDelete.Lock()
        mock.calls.Delete = nil
        mock.lockDelete.Unlock()
}</span>

// Read calls ReadFunc.
func (mock *UserStorageMock) Read(ctx context.Context) ([]approved.UserInfo, error) <span class="cov0" title="0">{
        if mock.ReadFunc == nil </span><span class="cov0" title="0">{
                panic("UserStorageMock.ReadFunc: method is nil but UserStorage.Read was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        }
        mock.lockRead.Lock()
        mock.calls.Read = append(mock.calls.Read, callInfo)
        mock.lockRead.Unlock()
        return mock.ReadFunc(ctx)</span>
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//        len(mockedUserStorage.ReadCalls())
func (mock *UserStorageMock) ReadCalls() []struct {
        Ctx context.Context
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
        }
        mock.lockRead.RLock()
        calls = mock.calls.Read
        mock.lockRead.RUnlock()
        return calls
}</span>

// ResetReadCalls reset all the calls that were made to Read.
func (mock *UserStorageMock) ResetReadCalls() <span class="cov0" title="0">{
        mock.lockRead.Lock()
        mock.calls.Read = nil
        mock.lockRead.Unlock()
}</span>

// Write calls WriteFunc.
func (mock *UserStorageMock) Write(ctx context.Context, au approved.UserInfo) error <span class="cov0" title="0">{
        if mock.WriteFunc == nil </span><span class="cov0" title="0">{
                panic("UserStorageMock.WriteFunc: method is nil but UserStorage.Write was just called")</span>
        }
        <span class="cov0" title="0">callInfo := struct {
                Ctx context.Context
                Au  approved.UserInfo
        }{
                Ctx: ctx,
                Au:  au,
        }
        mock.lockWrite.Lock()
        mock.calls.Write = append(mock.calls.Write, callInfo)
        mock.lockWrite.Unlock()
        return mock.WriteFunc(ctx, au)</span>
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//        len(mockedUserStorage.WriteCalls())
func (mock *UserStorageMock) WriteCalls() []struct {
        Ctx context.Context
        Au  approved.UserInfo
} <span class="cov0" title="0">{
        var calls []struct {
                Ctx context.Context
                Au  approved.UserInfo
        }
        mock.lockWrite.RLock()
        calls = mock.calls.Write
        mock.lockWrite.RUnlock()
        return calls
}</span>

// ResetWriteCalls reset all the calls that were made to Write.
func (mock *UserStorageMock) ResetWriteCalls() <span class="cov0" title="0">{
        mock.lockWrite.Lock()
        mock.calls.Write = nil
        mock.lockWrite.Unlock()
}</span>

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *UserStorageMock) ResetCalls() <span class="cov0" title="0">{
        mock.lockDelete.Lock()
        mock.calls.Delete = nil
        mock.lockDelete.Unlock()

        mock.lockRead.Lock()
        mock.calls.Read = nil
        mock.lockRead.Unlock()

        mock.lockWrite.Lock()
        mock.calls.Write = nil
        mock.lockWrite.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package tgspam

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        tokenizer "github.com/sandwich-go/gpt3-encoder"
        "github.com/sashabaranov/go-openai"

        "github.com/umputun/tg-spam/lib/spamcheck"
)

//go:generate moq --out mocks/openai_client.go --pkg mocks --with-resets --skip-ensure . openAIClient:OpenAIClientMock

// openAIChecker is a wrapper for OpenAI API to check if a text is spam
type openAIChecker struct {
        client openAIClient
        params OpenAIConfig
}

// OpenAIConfig contains parameters for openAIChecker
type OpenAIConfig struct {
        // https://platform.openai.com/docs/api-reference/chat/create#chat/create-max_tokens
        MaxTokensResponse int // hard limit for the number of tokens in the response
        // the OpenAI has a limit for the number of tokens in the request + response (4097)
        MaxTokensRequest  int // max request length in tokens
        MaxSymbolsRequest int // fallback: Max request length in symbols, if tokenizer was failed
        Model             string
        SystemPrompt      string
        CustomPrompts     []string // additional custom prompts that can be selected
        ReasoningEffort   string   // level of reasoning effort to use
        RetryCount        int
}

type openAIClient interface {
        CreateChatCompletion(context.Context, openai.ChatCompletionRequest) (openai.ChatCompletionResponse, error)
}

const defaultPrompt = `I'll give you a text from the messaging application and you will return me a json with three fields: {"spam": true/false, "reason":"why this is spam", "confidence":1-100}. Set spam:true only of confidence above 80. Return JSON only with no extra formatting!` + "\n" + `If history of previous messages provided, use them as extra context to make the decision.`

type openAIResponse struct {
        IsSpam     bool   `json:"spam"`
        Reason     string `json:"reason"`
        Confidence int    `json:"confidence"`
}

// newOpenAIChecker makes a bot for ChatGPT
func newOpenAIChecker(client openAIClient, params OpenAIConfig) *openAIChecker <span class="cov9" title="12">{
        if params.SystemPrompt == "" </span><span class="cov9" title="12">{
                params.SystemPrompt = defaultPrompt
        }</span>
        <span class="cov9" title="12">if params.MaxTokensResponse == 0 </span><span class="cov9" title="11">{
                params.MaxTokensResponse = 1024
        }</span>
        <span class="cov9" title="12">if params.MaxTokensRequest == 0 </span><span class="cov9" title="11">{
                params.MaxTokensRequest = 1024
        }</span>
        <span class="cov9" title="12">if params.MaxSymbolsRequest == 0 </span><span class="cov9" title="11">{
                params.MaxSymbolsRequest = 8192
        }</span>
        <span class="cov9" title="12">if params.Model == "" </span><span class="cov0" title="0">{
                params.Model = "gpt-4o-mini"
        }</span>
        <span class="cov9" title="12">if params.RetryCount &lt;= 0 </span><span class="cov9" title="12">{
                params.RetryCount = 1
        }</span>
        <span class="cov9" title="12">return &amp;openAIChecker{client: client, params: params}</span>
}

// check checks if a text is spam using OpenAI API
func (o *openAIChecker) check(msg string, history []spamcheck.Request) (spam bool, cr spamcheck.Response) <span class="cov10" title="14">{
        if o.client == nil </span><span class="cov0" title="0">{
                return false, spamcheck.Response{}
        }</span>

        // update the message with the history
        <span class="cov10" title="14">if len(history) &gt; 0 </span><span class="cov4" title="3">{
                var hist []string
                for _, h := range history </span><span class="cov7" title="7">{
                        hist = append(hist, fmt.Sprintf("%q: %q", h.UserName, h.Msg))
                }</span>
                <span class="cov4" title="3">msgWithHist := fmt.Sprintf("User message:\n%s\n\nHistory:\n%s\n", msg, strings.Join(hist, "\n"))
                msg = msgWithHist</span>
        }

        // try to send a request several times if it fails
        <span class="cov10" title="14">var resp openAIResponse
        var err error
        for i := 0; i &lt; o.params.RetryCount; i++ </span><span class="cov10" title="14">{
                if resp, err = o.sendRequest(msg); err == nil </span><span class="cov8" title="10">{
                        break</span>
                }
        }
        <span class="cov10" title="14">if err != nil </span><span class="cov5" title="4">{
                return false, spamcheck.Response{
                        Spam: false, Name: "openai", Details: fmt.Sprintf("OpenAI error: %v", err), Error: err}
        }</span>

        <span class="cov8" title="10">return resp.IsSpam, spamcheck.Response{Spam: resp.IsSpam, Name: "openai",
                Details: strings.TrimSuffix(resp.Reason, ".") + ", confidence: " + fmt.Sprintf("%d%%", resp.Confidence)}</span>
}

func (o *openAIChecker) sendRequest(msg string) (response openAIResponse, err error) <span class="cov10" title="14">{
        // reduce the request size with tokenizer and fallback to default reducer if it fails.
        // the API supports 4097 tokens ~16000 characters (&lt;=4 per token) for request + result together.
        // the response is limited to 1000 tokens, and OpenAI always reserved it for the result.
        // so the max length of the request should be 3000 tokens or ~12000 characters
        reduceRequest := func(text string) (result string) </span><span class="cov10" title="14">{
                // defaultReducer is a fallback if tokenizer fails
                defaultReducer := func(text string) (result string) </span><span class="cov0" title="0">{
                        if len(text) &lt;= o.params.MaxSymbolsRequest </span><span class="cov0" title="0">{
                                return text
                        }</span>
                        <span class="cov0" title="0">return text[:o.params.MaxSymbolsRequest]</span>
                }

                <span class="cov10" title="14">encoder, tokErr := tokenizer.NewEncoder()
                if tokErr != nil </span><span class="cov0" title="0">{
                        return defaultReducer(text)
                }</span>

                <span class="cov10" title="14">tokens, encErr := encoder.Encode(text)
                if encErr != nil </span><span class="cov0" title="0">{
                        return defaultReducer(text)
                }</span>

                <span class="cov10" title="14">if len(tokens) &lt;= o.params.MaxTokensRequest </span><span class="cov10" title="14">{
                        return text
                }</span>

                <span class="cov0" title="0">return encoder.Decode(tokens[:o.params.MaxTokensRequest])</span>
        }

        <span class="cov10" title="14">r := reduceRequest(msg)

        data := []openai.ChatCompletionMessage{
                {Role: openai.ChatMessageRoleSystem, Content: o.params.SystemPrompt},
                {Role: openai.ChatMessageRoleUser, Content: r},
        }

        resp, err := o.client.CreateChatCompletion(
                context.Background(),
                openai.ChatCompletionRequest{
                        Model:          o.params.Model,
                        MaxTokens:      o.params.MaxTokensResponse,
                        Messages:       data,
                        ResponseFormat: &amp;openai.ChatCompletionResponseFormat{Type: "json_object"},
                },
        )

        if err != nil </span><span class="cov3" title="2">{
                return openAIResponse{}, fmt.Errorf("failed to create chat completion: %w", err)
        }</span>

        // openAI platform supports returning multiple chat completion choices, but we use only the first one:
        // https://platform.openai.com/docs/api-reference/chat/create#chat/create-n
        <span class="cov9" title="12">if len(resp.Choices) == 0 </span><span class="cov1" title="1">{
                return openAIResponse{}, fmt.Errorf("no choices in response")
        }</span>

        <span class="cov9" title="11">if err := json.Unmarshal([]byte(resp.Choices[0].Message.Content), &amp;response); err != nil </span><span class="cov1" title="1">{
                return openAIResponse{}, fmt.Errorf("can't unmarshal response: %s - %w", resp.Choices[0].Message.Content, err)
        }</span>

        <span class="cov8" title="10">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package plugin provides a plugin system for spam detection in tg-spam.
// It loads and executes Lua scripts that implement custom spam checking logic.
// Scripts should provide a "check" function that takes a message context and returns
// a boolean (is spam) and a string (details).
package plugin

import (
        "fmt"
        "path/filepath"
        "sync"

        lua "github.com/yuin/gopher-lua"

        "github.com/umputun/tg-spam/lib/spamcheck"
)

// Checker implements a Lua plugin engine for spam detection
type Checker struct {
        vm       *lua.LState
        checkers map[string]*lua.LFunction
        lock     sync.RWMutex // protect checkers map during concurrent access
        watcher  *Watcher     // optional file watcher for dynamic reloading
}

// Check is a function that takes a request and returns a response indicating if message is spam
type Check func(req spamcheck.Request) spamcheck.Response

// NewChecker creates a new Checker
func NewChecker() *Checker <span class="cov8" title="17">{
        L := lua.NewState()
        lc := &amp;Checker{
                vm:       L,
                checkers: make(map[string]*lua.LFunction),
        }
        lc.RegisterHelpers() // register helper functions
        return lc
}</span>

// LoadScript loads a Lua script and registers it as a checker
func (c *Checker) LoadScript(path string) error <span class="cov9" title="23">{
        c.lock.Lock()
        defer c.lock.Unlock()

        // create a new state for loading this script to avoid interference with other scripts
        tempState := lua.NewState()
        defer tempState.Close()

        // load the script in the temporary state
        if err := tempState.DoFile(path); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("failed to load Lua script: %w", err)
        }</span>

        // extract the checker function from the temporary state
        <span class="cov8" title="21">checkFunc := tempState.GetGlobal("check")
        if checkFunc.Type() != lua.LTFunction </span><span class="cov1" title="1">{
                return fmt.Errorf("script must define a 'check' function")
        }</span>

        // use filename (without extension) as checker name
        <span class="cov8" title="20">name := filepath.Base(path)
        name = name[:len(name)-len(filepath.Ext(name))]

        // now load the script in the real VM
        if err := c.vm.DoFile(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load Lua script in main VM: %w", err)
        }</span>

        // extract the checker function from the real VM
        <span class="cov8" title="20">realCheckFunc := c.vm.GetGlobal("check")
        if realCheckFunc.Type() != lua.LTFunction </span><span class="cov0" title="0">{
                return fmt.Errorf("script in main VM must define a 'check' function")
        }</span>

        // store the function from the main VM after both loads have succeeded
        <span class="cov8" title="20">c.checkers[name] = realCheckFunc.(*lua.LFunction)

        return nil</span>
}

// ReloadScript reloads a specific Lua script
func (c *Checker) ReloadScript(path string) error <span class="cov6" title="8">{
        // use filename (without extension) as checker name
        name := filepath.Base(path)
        name = name[:len(name)-len(filepath.Ext(name))]

        // remove old script from checkers
        c.lock.Lock()
        delete(c.checkers, name)
        c.lock.Unlock()

        // reload the script
        return c.LoadScript(path)
}</span>

// LoadDirectory loads all Lua scripts from a directory
func (c *Checker) LoadDirectory(dir string) error <span class="cov2" title="2">{
        files, err := filepath.Glob(filepath.Join(dir, "*.lua"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list Lua scripts in %s: %w", dir, err)
        }</span>

        <span class="cov2" title="2">for _, file := range files </span><span class="cov4" title="4">{
                if err := c.LoadScript(file); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load script %s: %w", file, err)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// GetCheck returns a Check for the specified Lua checker
func (c *Checker) GetCheck(name string) (Check, error) <span class="cov7" title="13">{
        c.lock.RLock()
        checker, ok := c.checkers[name]
        c.lock.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("lua checker %q not found", name)
        }</span>

        <span class="cov7" title="13">return c.createMetaChecker(name, checker), nil</span>
}

// GetAllChecks returns all loaded Lua checks
func (c *Checker) GetAllChecks() map[string]Check <span class="cov1" title="1">{
        result := make(map[string]Check)

        c.lock.RLock()
        for name, checker := range c.checkers </span><span class="cov2" title="2">{
                result[name] = c.createMetaChecker(name, checker)
        }</span>
        <span class="cov1" title="1">c.lock.RUnlock()

        return result</span>
}

// createMetaChecker creates a Check function from a Lua checker
func (c *Checker) createMetaChecker(name string, checker *lua.LFunction) Check <span class="cov7" title="15">{
        return func(req spamcheck.Request) spamcheck.Response </span><span class="cov10" title="34">{
                c.lock.RLock()
                defer c.lock.RUnlock()

                // create Lua table from request
                reqTable := c.vm.NewTable()
                reqTable.RawSetString("msg", lua.LString(req.Msg))
                reqTable.RawSetString("user_id", lua.LString(req.UserID))
                reqTable.RawSetString("user_name", lua.LString(req.UserName))

                // add metadata
                metaTable := c.vm.NewTable()
                metaTable.RawSetString("images", lua.LNumber(req.Meta.Images))
                metaTable.RawSetString("links", lua.LNumber(req.Meta.Links))
                metaTable.RawSetString("mentions", lua.LNumber(req.Meta.Mentions))
                metaTable.RawSetString("has_video", lua.LBool(req.Meta.HasVideo))
                metaTable.RawSetString("has_audio", lua.LBool(req.Meta.HasAudio))
                metaTable.RawSetString("has_forward", lua.LBool(req.Meta.HasForward))
                metaTable.RawSetString("has_keyboard", lua.LBool(req.Meta.HasKeyboard))
                reqTable.RawSetString("meta", metaTable)

                // call the Lua function
                if err := c.vm.CallByParam(lua.P{
                        Fn:      checker,
                        NRet:    2,
                        Protect: true,
                }, reqTable); err != nil </span><span class="cov1" title="1">{
                        return spamcheck.Response{
                                Name:    "lua-" + name,
                                Spam:    false,
                                Details: "error executing lua checker: " + err.Error(),
                                Error:   err,
                        }
                }</span>

                // get return values from stack
                <span class="cov9" title="33">isSpam := c.vm.ToBool(-2)
                details := c.vm.ToString(-1)
                c.vm.Pop(2) // pop results from stack

                return spamcheck.Response{
                        Name:    "lua-" + name,
                        Spam:    isSpam,
                        Details: details,
                }</span>
        }
}

// Close cleans up resources used by the Checker
func (c *Checker) Close() <span class="cov8" title="17">{
        // stop the watcher if it exists
        if c.watcher != nil </span><span class="cov1" title="1">{
                c.watcher.Stop()
        }</span>
        <span class="cov8" title="17">c.vm.Close()</span>
}

// SetWatcher sets the file watcher for the Checker
func (c *Checker) SetWatcher(watcher *Watcher) <span class="cov1" title="1">{
        c.watcher = watcher
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package plugin

import (
        "encoding/json"
        "io"
        "net/http"
        "net/url"
        "regexp"
        "strings"
        "time"

        lua "github.com/yuin/gopher-lua"
)

// RegisterHelpers registers common helper functions for Lua scripts
func (c *Checker) RegisterHelpers() <span class="cov9" title="17">{
        // string manipulation helpers
        c.vm.SetGlobal("count_substring", c.vm.NewFunction(countSubstring))
        c.vm.SetGlobal("match_regex", c.vm.NewFunction(matchRegex))
        c.vm.SetGlobal("contains_any", c.vm.NewFunction(containsAny))
        c.vm.SetGlobal("to_lower", c.vm.NewFunction(toLowerCase))
        c.vm.SetGlobal("to_upper", c.vm.NewFunction(toUpperCase))
        c.vm.SetGlobal("trim", c.vm.NewFunction(trim))
        c.vm.SetGlobal("split", c.vm.NewFunction(split))
        c.vm.SetGlobal("join", c.vm.NewFunction(join))
        c.vm.SetGlobal("starts_with", c.vm.NewFunction(startsWith))
        c.vm.SetGlobal("ends_with", c.vm.NewFunction(endsWith))

        // HTTP and JSON helpers
        c.vm.SetGlobal("http_request", c.vm.NewFunction(httpRequest))
        c.vm.SetGlobal("json_encode", c.vm.NewFunction(jsonEncode))
        c.vm.SetGlobal("json_decode", c.vm.NewFunction(jsonDecode))
        c.vm.SetGlobal("url_encode", c.vm.NewFunction(urlEncode))
}</span>

// countSubstring counts occurrences of a substring
func countSubstring(l *lua.LState) int <span class="cov4" title="3">{
        str := l.CheckString(1)
        substr := l.CheckString(2)
        count := strings.Count(str, substr)
        l.Push(lua.LNumber(count))
        return 1
}</span>

// matchRegex checks if a string matches a regex pattern
func matchRegex(l *lua.LState) int <span class="cov8" title="12">{
        text := l.CheckString(1)
        pattern := l.CheckString(2)

        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov4" title="3">{
                l.Push(lua.LBool(false))
                l.Push(lua.LString("invalid pattern: " + err.Error()))
                return 2
        }</span>

        <span class="cov7" title="9">matched := re.MatchString(text)
        l.Push(lua.LBool(matched))
        return 1</span>
}

// containsAny checks if a string contains any of the given substrings
func containsAny(l *lua.LState) int <span class="cov6" title="7">{
        str := l.CheckString(1)

        // check if second argument is a table
        if l.GetTop() &gt;= 2 &amp;&amp; l.Get(2).Type() == lua.LTTable </span><span class="cov4" title="3">{
                table := l.ToTable(2)
                var items []string

                table.ForEach(func(_, v lua.LValue) </span><span class="cov8" title="12">{
                        if v.Type() == lua.LTString </span><span class="cov8" title="12">{
                                items = append(items, v.String())
                        }</span>
                })

                <span class="cov4" title="3">for _, item := range items </span><span class="cov7" title="10">{
                        if strings.Contains(str, item) </span><span class="cov1" title="1">{
                                l.Push(lua.LBool(true))
                                l.Push(lua.LString(item))
                                return 2
                        }</span>
                }

                <span class="cov3" title="2">l.Push(lua.LBool(false))
                return 1</span>
        }

        // if not a table, treat remaining arguments as strings
        <span class="cov5" title="4">for i := 2; i &lt;= l.GetTop(); i++ </span><span class="cov7" title="10">{
                substr := l.CheckString(i)
                if strings.Contains(str, substr) </span><span class="cov1" title="1">{
                        l.Push(lua.LBool(true))
                        l.Push(lua.LString(substr))
                        return 2
                }</span>
        }

        <span class="cov4" title="3">l.Push(lua.LBool(false))
        return 1</span>
}

// toLowerCase converts a string to lowercase
func toLowerCase(l *lua.LState) int <span class="cov4" title="3">{
        str := l.CheckString(1)
        l.Push(lua.LString(strings.ToLower(str)))
        return 1
}</span>

// toUpperCase converts a string to uppercase
func toUpperCase(l *lua.LState) int <span class="cov5" title="4">{
        str := l.CheckString(1)
        l.Push(lua.LString(strings.ToUpper(str)))
        return 1
}</span>

// trim removes whitespace from both ends of a string
func trim(l *lua.LState) int <span class="cov5" title="4">{
        str := l.CheckString(1)
        l.Push(lua.LString(strings.TrimSpace(str)))
        return 1
}</span>

// split splits a string by a separator
func split(l *lua.LState) int <span class="cov5" title="4">{
        str := l.CheckString(1)
        sep := l.CheckString(2)

        parts := strings.Split(str, sep)

        resultTable := l.NewTable()
        for i, part := range parts </span><span class="cov10" title="22">{
                resultTable.RawSetInt(i+1, lua.LString(part))
        }</span>

        <span class="cov5" title="4">l.Push(resultTable)
        return 1</span>
}

// join joins strings with a separator
func join(l *lua.LState) int <span class="cov7" title="11">{
        sep := l.CheckString(1)

        if l.GetTop() &gt;= 2 &amp;&amp; l.Get(2).Type() == lua.LTTable </span><span class="cov6" title="7">{
                table := l.ToTable(2)
                var items []string

                table.ForEach(func(_, v lua.LValue) </span><span class="cov10" title="22">{
                        if v.Type() == lua.LTString </span><span class="cov10" title="22">{
                                items = append(items, v.String())
                        }</span>
                })

                <span class="cov6" title="7">l.Push(lua.LString(strings.Join(items, sep)))
                return 1</span>
        }

        <span class="cov5" title="4">var strs []string
        for i := 2; i &lt;= l.GetTop(); i++ </span><span class="cov7" title="9">{
                strs = append(strs, l.CheckString(i))
        }</span>

        <span class="cov5" title="4">l.Push(lua.LString(strings.Join(strs, sep)))
        return 1</span>
}

// startsWith checks if a string starts with a prefix
func startsWith(l *lua.LState) int <span class="cov4" title="3">{
        str := l.CheckString(1)
        prefix := l.CheckString(2)
        l.Push(lua.LBool(strings.HasPrefix(str, prefix)))
        return 1
}</span>

// endsWith checks if a string ends with a suffix
func endsWith(l *lua.LState) int <span class="cov3" title="2">{
        str := l.CheckString(1)
        suffix := l.CheckString(2)
        l.Push(lua.LBool(strings.HasSuffix(str, suffix)))
        return 1
}</span>

// httpRequest makes an HTTP request to the given URL and returns the response
// Lua usage: response, status_code, err = http_request(url, [method="GET"], [headers={...}], [body=""], [timeout=5])
// Example: response, status, err = http_request("https://example.com/api", "POST", {["Content-Type"]="application/json"}, '{"key":"value"}', 10)
func httpRequest(l *lua.LState) int <span class="cov5" title="5">{
        urlStr := l.CheckString(1)

        // optional parameters with defaults
        method := "GET"
        if l.GetTop() &gt;= 2 &amp;&amp; l.Get(2) != lua.LNil </span><span class="cov3" title="2">{
                method = l.CheckString(2)
        }</span>

        // default timeout of 5 seconds, can be overridden as last parameter
        <span class="cov5" title="5">timeout := 5.0
        if l.GetTop() &gt;= 5 &amp;&amp; l.Get(5) != lua.LNil </span><span class="cov0" title="0">{
                timeout = float64(l.CheckNumber(5))
        }</span>

        // create HTTP client with timeout
        <span class="cov5" title="5">client := &amp;http.Client{
                Timeout: time.Duration(timeout * float64(time.Second)),
        }

        // handle request body if provided
        var body io.Reader
        if l.GetTop() &gt;= 4 &amp;&amp; l.Get(4) != lua.LNil </span><span class="cov1" title="1">{
                body = strings.NewReader(l.CheckString(4))
        }</span>

        // create the request with context for proper cancellation
        <span class="cov5" title="5">req, err := http.NewRequest(method, urlStr, body)
        if err != nil </span><span class="cov0" title="0">{
                l.Push(lua.LNil)
                l.Push(lua.LNumber(0))
                l.Push(lua.LString(err.Error()))
                return 3
        }</span>

        // add headers if provided
        <span class="cov5" title="5">if l.GetTop() &gt;= 3 &amp;&amp; l.Get(3) != lua.LNil &amp;&amp; l.Get(3).Type() == lua.LTTable </span><span class="cov1" title="1">{
                headers := l.CheckTable(3)
                headers.ForEach(func(k, v lua.LValue) </span><span class="cov1" title="1">{
                        if k.Type() == lua.LTString &amp;&amp; v.Type() == lua.LTString </span><span class="cov1" title="1">{
                                req.Header.Set(k.String(), v.String())
                        }</span>
                })
        }

        // add default User-Agent header if not already set
        <span class="cov5" title="5">if req.Header.Get("User-Agent") == "" </span><span class="cov5" title="5">{
                req.Header.Set("User-Agent", "TG-Spam-Lua-Plugin")
        }</span>

        // execute the request
        <span class="cov5" title="5">resp, err := client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                l.Push(lua.LNil)
                l.Push(lua.LNumber(0))
                l.Push(lua.LString(err.Error()))
                return 3
        }</span>
        <span class="cov5" title="4">defer resp.Body.Close()

        // read response body
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                l.Push(lua.LNil)
                l.Push(lua.LNumber(resp.StatusCode))
                l.Push(lua.LString(err.Error()))
                return 3
        }</span>

        // return response body, status code, and nil error
        <span class="cov5" title="4">l.Push(lua.LString(string(respBody)))
        l.Push(lua.LNumber(resp.StatusCode))
        l.Push(lua.LNil) // no error
        return 3</span>
}

// jsonEncode converts a Lua table to a JSON string
// Lua usage: json_string = json_encode(table)
func jsonEncode(l *lua.LState) int <span class="cov1" title="1">{
        // function to convert Lua value to Go value
        var convertValue func(lv lua.LValue) interface{}
        convertValue = func(lv lua.LValue) interface{} </span><span class="cov7" title="9">{
                switch lv.Type() </span>{
                case lua.LTNil:<span class="cov0" title="0">
                        return nil</span>
                case lua.LTBool:<span class="cov1" title="1">
                        return lua.LVAsBool(lv)</span>
                case lua.LTNumber:<span class="cov1" title="1">
                        return float64(lua.LVAsNumber(lv))</span>
                case lua.LTString:<span class="cov5" title="4">
                        return lua.LVAsString(lv)</span>
                case lua.LTTable:<span class="cov4" title="3">
                        table := lv.(*lua.LTable)

                        // check if it's an array
                        maxn := table.MaxN()
                        if maxn &gt; 0 </span><span class="cov1" title="1">{
                                // it's an array
                                array := make([]interface{}, 0, maxn)
                                for i := 1; i &lt;= maxn; i++ </span><span class="cov3" title="2">{
                                        val := table.RawGetInt(i)
                                        if val != lua.LNil </span><span class="cov3" title="2">{
                                                array = append(array, convertValue(val))
                                        }</span>
                                }
                                <span class="cov1" title="1">return array</span>
                        }

                        // it's a map/object
                        <span class="cov3" title="2">obj := make(map[string]interface{})
                        table.ForEach(func(key, value lua.LValue) </span><span class="cov6" title="6">{
                                if key.Type() == lua.LTString </span><span class="cov6" title="6">{
                                        obj[key.String()] = convertValue(value)
                                }</span>
                        })
                        <span class="cov3" title="2">return obj</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        }

        // check we have at least one argument and it's a table
        <span class="cov1" title="1">if l.GetTop() &lt; 1 </span><span class="cov0" title="0">{
                l.Push(lua.LString(""))
                l.Push(lua.LString("no input provided"))
                return 2
        }</span>

        <span class="cov1" title="1">luaValue := l.Get(1)
        goValue := convertValue(luaValue)

        // marshal to JSON
        jsonBytes, err := json.Marshal(goValue)
        if err != nil </span><span class="cov0" title="0">{
                l.Push(lua.LString(""))
                l.Push(lua.LString(err.Error()))
                return 2
        }</span>

        <span class="cov1" title="1">l.Push(lua.LString(string(jsonBytes)))
        l.Push(lua.LNil) // no error
        return 2</span>
}

// jsonDecode parses a JSON string into a Lua table
// Lua usage: lua_table, err = json_decode(json_string)
func jsonDecode(l *lua.LState) int <span class="cov1" title="1">{
        jsonStr := l.CheckString(1)

        // function to convert Go value to Lua value
        var convertValue func(val interface{}) lua.LValue
        convertValue = func(val interface{}) lua.LValue </span><span class="cov7" title="9">{
                if val == nil </span><span class="cov0" title="0">{
                        return lua.LNil
                }</span>

                <span class="cov7" title="9">switch v := val.(type) </span>{
                case bool:<span class="cov1" title="1">
                        return lua.LBool(v)</span>
                case float64:<span class="cov1" title="1">
                        return lua.LNumber(v)</span>
                case string:<span class="cov5" title="4">
                        return lua.LString(v)</span>
                case []interface{}:<span class="cov1" title="1">
                        // array
                        table := l.NewTable()
                        for i, item := range v </span><span class="cov3" title="2">{
                                table.RawSetInt(i+1, convertValue(item))
                        }</span>
                        <span class="cov1" title="1">return table</span>
                case map[string]interface{}:<span class="cov3" title="2">
                        // object
                        table := l.NewTable()
                        for key, value := range v </span><span class="cov6" title="6">{
                                table.RawSetString(key, convertValue(value))
                        }</span>
                        <span class="cov3" title="2">return table</span>
                default:<span class="cov0" title="0">
                        return lua.LNil</span>
                }
        }

        // unmarshal JSON
        <span class="cov1" title="1">var data interface{}
        if err := json.Unmarshal([]byte(jsonStr), &amp;data); err != nil </span><span class="cov0" title="0">{
                l.Push(lua.LNil)
                l.Push(lua.LString(err.Error()))
                return 2
        }</span>

        <span class="cov1" title="1">l.Push(convertValue(data))
        l.Push(lua.LNil) // no error
        return 2</span>
}

// urlEncode encodes a string for safe use in URLs
// Lua usage: encoded = url_encode(str)
func urlEncode(l *lua.LState) int <span class="cov5" title="4">{
        str := l.CheckString(1)
        l.Push(lua.LString(url.QueryEscape(str)))
        return 1
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package plugin

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
)

// Watcher monitors a directory for changes to Lua scripts and reloads them as needed
type Watcher struct {
        checker      *Checker
        pluginsDir   string
        watcher      *fsnotify.Watcher
        done         chan struct{}
        debounceTime time.Duration
        events       map[string]time.Time
        mu           sync.Mutex
        started      bool
}

// NewWatcher creates a new file system watcher for Lua plugins
func NewWatcher(checker *Checker, pluginsDir string) (*Watcher, error) <span class="cov10" title="4">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        <span class="cov10" title="4">return &amp;Watcher{
                checker:      checker,
                pluginsDir:   pluginsDir,
                watcher:      watcher,
                done:         make(chan struct{}),
                debounceTime: 500 * time.Millisecond, // default debounce time
                events:       make(map[string]time.Time),
        }, nil</span>
}

// Start begins watching the plugins directory for changes
func (w *Watcher) Start() error <span class="cov10" title="4">{
        // avoid starting multiple watchers
        w.mu.Lock()
        if w.started </span><span class="cov1" title="1">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="3">w.started = true
        w.mu.Unlock()

        // ensure the directory exists
        if _, err := os.Stat(w.pluginsDir); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return fmt.Errorf("plugins directory %s does not exist: %w", w.pluginsDir, err)
        }</span>

        // add the directory to the watch list
        <span class="cov5" title="2">if err := w.watcher.Add(w.pluginsDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to watch plugins directory: %w", err)
        }</span>

        <span class="cov5" title="2">log.Printf("[INFO] started watching lua plugins directory: %s", w.pluginsDir)

        // start the watcher goroutine
        go w.watchLoop()

        return nil</span>
}

// Stop terminates the file watcher
func (w *Watcher) Stop() <span class="cov8" title="3">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if !w.started </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov5" title="2">close(w.done)
        if err := w.watcher.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to close file watcher: %v", err)
        }</span>
        <span class="cov5" title="2">w.started = false
        log.Printf("[INFO] stopped watching Lua plugins directory: %s", w.pluginsDir)</span>
}

// watchLoop is the main loop that handles file system events
func (w *Watcher) watchLoop() <span class="cov5" title="2">{
        ticker := time.NewTicker(w.debounceTime)
        defer ticker.Stop()

        for </span><span class="cov10" title="4">{
                select </span>{
                case &lt;-w.done:<span class="cov1" title="1">
                        return</span>
                case event, ok := &lt;-w.watcher.Events:<span class="cov8" title="3">
                        if !ok </span><span class="cov1" title="1">{
                                return
                        }</span>
                        <span class="cov5" title="2">w.handleEvent(event)</span>
                case err, ok := &lt;-w.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("[WARN] watcher error: %v", err)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        w.processEvents()</span>
                }
        }
}

// handleEvent processes a single fsnotify event
func (w *Watcher) handleEvent(event fsnotify.Event) <span class="cov10" title="4">{
        // only process .lua files
        if filepath.Ext(event.Name) != ".lua" </span><span class="cov1" title="1">{
                return
        }</span>

        // track create, write, and remove operations
        <span class="cov8" title="3">if event.Has(fsnotify.Create) || event.Has(fsnotify.Write) || event.Has(fsnotify.Remove) </span><span class="cov5" title="2">{
                w.mu.Lock()
                w.events[event.Name] = time.Now()
                w.mu.Unlock()
        }</span>
}

// processEvents handles the debounced events
func (w *Watcher) processEvents() <span class="cov1" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        now := time.Now()
        for filename, timestamp := range w.events </span><span class="cov1" title="1">{
                // skip events that are too recent (debouncing)
                if now.Sub(timestamp) &lt; w.debounceTime </span><span class="cov0" title="0">{
                        continue</span>
                }

                // handle the event based on whether the file exists
                <span class="cov1" title="1">if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // file was deleted
                        scriptName := filepath.Base(filename)
                        scriptName = scriptName[:len(scriptName)-len(filepath.Ext(scriptName))]
                        log.Printf("[INFO] lua script removed: %s", scriptName)
                        continue</span>
                }
                // file was created or modified
                <span class="cov1" title="1">log.Printf("[INFO] reloading lua script: %s", filename)
                if err := w.checker.ReloadScript(filename); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to reload lua script %s: %v", filename, err)
                }</span>

                // remove processed event
                <span class="cov1" title="1">delete(w.events, filename)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
