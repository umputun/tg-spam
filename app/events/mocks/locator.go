// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/umputun/tg-spam/app/storage"
	"github.com/umputun/tg-spam/lib/spamcheck"
	"sync"
)

// LocatorMock is a mock implementation of events.Locator.
//
//	func TestSomethingThatUsesLocator(t *testing.T) {
//
//		// make and configure a mocked events.Locator
//		mockedLocator := &LocatorMock{
//			AddMessageFunc: func(ctx context.Context, msg string, chatID int64, userID int64, userName string, msgID int) error {
//				panic("mock out the AddMessage method")
//			},
//			AddSpamFunc: func(ctx context.Context, userID int64, checks []spamcheck.Response) error {
//				panic("mock out the AddSpam method")
//			},
//			GetUserMessageIDsFunc: func(ctx context.Context, userID int64, limit int) ([]int, error) {
//				panic("mock out the GetUserMessageIDs method")
//			},
//			MessageFunc: func(ctx context.Context, msg string) (storage.MsgMeta, bool) {
//				panic("mock out the Message method")
//			},
//			MsgHashFunc: func(msg string) string {
//				panic("mock out the MsgHash method")
//			},
//			SpamFunc: func(ctx context.Context, userID int64) (storage.SpamData, bool) {
//				panic("mock out the Spam method")
//			},
//			UserNameByIDFunc: func(ctx context.Context, userID int64) string {
//				panic("mock out the UserNameByID method")
//			},
//		}
//
//		// use mockedLocator in code that requires events.Locator
//		// and then make assertions.
//
//	}
type LocatorMock struct {
	// AddMessageFunc mocks the AddMessage method.
	AddMessageFunc func(ctx context.Context, msg string, chatID int64, userID int64, userName string, msgID int) error

	// AddSpamFunc mocks the AddSpam method.
	AddSpamFunc func(ctx context.Context, userID int64, checks []spamcheck.Response) error

	// GetUserMessageIDsFunc mocks the GetUserMessageIDs method.
	GetUserMessageIDsFunc func(ctx context.Context, userID int64, limit int) ([]int, error)

	// MessageFunc mocks the Message method.
	MessageFunc func(ctx context.Context, msg string) (storage.MsgMeta, bool)

	// MsgHashFunc mocks the MsgHash method.
	MsgHashFunc func(msg string) string

	// SpamFunc mocks the Spam method.
	SpamFunc func(ctx context.Context, userID int64) (storage.SpamData, bool)

	// UserNameByIDFunc mocks the UserNameByID method.
	UserNameByIDFunc func(ctx context.Context, userID int64) string

	// calls tracks calls to the methods.
	calls struct {
		// AddMessage holds details about calls to the AddMessage method.
		AddMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg string
			// ChatID is the chatID argument value.
			ChatID int64
			// UserID is the userID argument value.
			UserID int64
			// UserName is the userName argument value.
			UserName string
			// MsgID is the msgID argument value.
			MsgID int
		}
		// AddSpam holds details about calls to the AddSpam method.
		AddSpam []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID int64
			// Checks is the checks argument value.
			Checks []spamcheck.Response
		}
		// GetUserMessageIDs holds details about calls to the GetUserMessageIDs method.
		GetUserMessageIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID int64
			// Limit is the limit argument value.
			Limit int
		}
		// Message holds details about calls to the Message method.
		Message []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg string
		}
		// MsgHash holds details about calls to the MsgHash method.
		MsgHash []struct {
			// Msg is the msg argument value.
			Msg string
		}
		// Spam holds details about calls to the Spam method.
		Spam []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID int64
		}
		// UserNameByID holds details about calls to the UserNameByID method.
		UserNameByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID int64
		}
	}
	lockAddMessage        sync.RWMutex
	lockAddSpam           sync.RWMutex
	lockGetUserMessageIDs sync.RWMutex
	lockMessage           sync.RWMutex
	lockMsgHash           sync.RWMutex
	lockSpam              sync.RWMutex
	lockUserNameByID      sync.RWMutex
}

// AddMessage calls AddMessageFunc.
func (mock *LocatorMock) AddMessage(ctx context.Context, msg string, chatID int64, userID int64, userName string, msgID int) error {
	if mock.AddMessageFunc == nil {
		panic("LocatorMock.AddMessageFunc: method is nil but Locator.AddMessage was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Msg      string
		ChatID   int64
		UserID   int64
		UserName string
		MsgID    int
	}{
		Ctx:      ctx,
		Msg:      msg,
		ChatID:   chatID,
		UserID:   userID,
		UserName: userName,
		MsgID:    msgID,
	}
	mock.lockAddMessage.Lock()
	mock.calls.AddMessage = append(mock.calls.AddMessage, callInfo)
	mock.lockAddMessage.Unlock()
	return mock.AddMessageFunc(ctx, msg, chatID, userID, userName, msgID)
}

// AddMessageCalls gets all the calls that were made to AddMessage.
// Check the length with:
//
//	len(mockedLocator.AddMessageCalls())
func (mock *LocatorMock) AddMessageCalls() []struct {
	Ctx      context.Context
	Msg      string
	ChatID   int64
	UserID   int64
	UserName string
	MsgID    int
} {
	var calls []struct {
		Ctx      context.Context
		Msg      string
		ChatID   int64
		UserID   int64
		UserName string
		MsgID    int
	}
	mock.lockAddMessage.RLock()
	calls = mock.calls.AddMessage
	mock.lockAddMessage.RUnlock()
	return calls
}

// ResetAddMessageCalls reset all the calls that were made to AddMessage.
func (mock *LocatorMock) ResetAddMessageCalls() {
	mock.lockAddMessage.Lock()
	mock.calls.AddMessage = nil
	mock.lockAddMessage.Unlock()
}

// AddSpam calls AddSpamFunc.
func (mock *LocatorMock) AddSpam(ctx context.Context, userID int64, checks []spamcheck.Response) error {
	if mock.AddSpamFunc == nil {
		panic("LocatorMock.AddSpamFunc: method is nil but Locator.AddSpam was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID int64
		Checks []spamcheck.Response
	}{
		Ctx:    ctx,
		UserID: userID,
		Checks: checks,
	}
	mock.lockAddSpam.Lock()
	mock.calls.AddSpam = append(mock.calls.AddSpam, callInfo)
	mock.lockAddSpam.Unlock()
	return mock.AddSpamFunc(ctx, userID, checks)
}

// AddSpamCalls gets all the calls that were made to AddSpam.
// Check the length with:
//
//	len(mockedLocator.AddSpamCalls())
func (mock *LocatorMock) AddSpamCalls() []struct {
	Ctx    context.Context
	UserID int64
	Checks []spamcheck.Response
} {
	var calls []struct {
		Ctx    context.Context
		UserID int64
		Checks []spamcheck.Response
	}
	mock.lockAddSpam.RLock()
	calls = mock.calls.AddSpam
	mock.lockAddSpam.RUnlock()
	return calls
}

// ResetAddSpamCalls reset all the calls that were made to AddSpam.
func (mock *LocatorMock) ResetAddSpamCalls() {
	mock.lockAddSpam.Lock()
	mock.calls.AddSpam = nil
	mock.lockAddSpam.Unlock()
}

// GetUserMessageIDs calls GetUserMessageIDsFunc.
func (mock *LocatorMock) GetUserMessageIDs(ctx context.Context, userID int64, limit int) ([]int, error) {
	if mock.GetUserMessageIDsFunc == nil {
		panic("LocatorMock.GetUserMessageIDsFunc: method is nil but Locator.GetUserMessageIDs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID int64
		Limit  int
	}{
		Ctx:    ctx,
		UserID: userID,
		Limit:  limit,
	}
	mock.lockGetUserMessageIDs.Lock()
	mock.calls.GetUserMessageIDs = append(mock.calls.GetUserMessageIDs, callInfo)
	mock.lockGetUserMessageIDs.Unlock()
	return mock.GetUserMessageIDsFunc(ctx, userID, limit)
}

// GetUserMessageIDsCalls gets all the calls that were made to GetUserMessageIDs.
// Check the length with:
//
//	len(mockedLocator.GetUserMessageIDsCalls())
func (mock *LocatorMock) GetUserMessageIDsCalls() []struct {
	Ctx    context.Context
	UserID int64
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		UserID int64
		Limit  int
	}
	mock.lockGetUserMessageIDs.RLock()
	calls = mock.calls.GetUserMessageIDs
	mock.lockGetUserMessageIDs.RUnlock()
	return calls
}

// ResetGetUserMessageIDsCalls reset all the calls that were made to GetUserMessageIDs.
func (mock *LocatorMock) ResetGetUserMessageIDsCalls() {
	mock.lockGetUserMessageIDs.Lock()
	mock.calls.GetUserMessageIDs = nil
	mock.lockGetUserMessageIDs.Unlock()
}

// Message calls MessageFunc.
func (mock *LocatorMock) Message(ctx context.Context, msg string) (storage.MsgMeta, bool) {
	if mock.MessageFunc == nil {
		panic("LocatorMock.MessageFunc: method is nil but Locator.Message was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg string
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockMessage.Lock()
	mock.calls.Message = append(mock.calls.Message, callInfo)
	mock.lockMessage.Unlock()
	return mock.MessageFunc(ctx, msg)
}

// MessageCalls gets all the calls that were made to Message.
// Check the length with:
//
//	len(mockedLocator.MessageCalls())
func (mock *LocatorMock) MessageCalls() []struct {
	Ctx context.Context
	Msg string
} {
	var calls []struct {
		Ctx context.Context
		Msg string
	}
	mock.lockMessage.RLock()
	calls = mock.calls.Message
	mock.lockMessage.RUnlock()
	return calls
}

// ResetMessageCalls reset all the calls that were made to Message.
func (mock *LocatorMock) ResetMessageCalls() {
	mock.lockMessage.Lock()
	mock.calls.Message = nil
	mock.lockMessage.Unlock()
}

// MsgHash calls MsgHashFunc.
func (mock *LocatorMock) MsgHash(msg string) string {
	if mock.MsgHashFunc == nil {
		panic("LocatorMock.MsgHashFunc: method is nil but Locator.MsgHash was just called")
	}
	callInfo := struct {
		Msg string
	}{
		Msg: msg,
	}
	mock.lockMsgHash.Lock()
	mock.calls.MsgHash = append(mock.calls.MsgHash, callInfo)
	mock.lockMsgHash.Unlock()
	return mock.MsgHashFunc(msg)
}

// MsgHashCalls gets all the calls that were made to MsgHash.
// Check the length with:
//
//	len(mockedLocator.MsgHashCalls())
func (mock *LocatorMock) MsgHashCalls() []struct {
	Msg string
} {
	var calls []struct {
		Msg string
	}
	mock.lockMsgHash.RLock()
	calls = mock.calls.MsgHash
	mock.lockMsgHash.RUnlock()
	return calls
}

// ResetMsgHashCalls reset all the calls that were made to MsgHash.
func (mock *LocatorMock) ResetMsgHashCalls() {
	mock.lockMsgHash.Lock()
	mock.calls.MsgHash = nil
	mock.lockMsgHash.Unlock()
}

// Spam calls SpamFunc.
func (mock *LocatorMock) Spam(ctx context.Context, userID int64) (storage.SpamData, bool) {
	if mock.SpamFunc == nil {
		panic("LocatorMock.SpamFunc: method is nil but Locator.Spam was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID int64
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockSpam.Lock()
	mock.calls.Spam = append(mock.calls.Spam, callInfo)
	mock.lockSpam.Unlock()
	return mock.SpamFunc(ctx, userID)
}

// SpamCalls gets all the calls that were made to Spam.
// Check the length with:
//
//	len(mockedLocator.SpamCalls())
func (mock *LocatorMock) SpamCalls() []struct {
	Ctx    context.Context
	UserID int64
} {
	var calls []struct {
		Ctx    context.Context
		UserID int64
	}
	mock.lockSpam.RLock()
	calls = mock.calls.Spam
	mock.lockSpam.RUnlock()
	return calls
}

// ResetSpamCalls reset all the calls that were made to Spam.
func (mock *LocatorMock) ResetSpamCalls() {
	mock.lockSpam.Lock()
	mock.calls.Spam = nil
	mock.lockSpam.Unlock()
}

// UserNameByID calls UserNameByIDFunc.
func (mock *LocatorMock) UserNameByID(ctx context.Context, userID int64) string {
	if mock.UserNameByIDFunc == nil {
		panic("LocatorMock.UserNameByIDFunc: method is nil but Locator.UserNameByID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID int64
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockUserNameByID.Lock()
	mock.calls.UserNameByID = append(mock.calls.UserNameByID, callInfo)
	mock.lockUserNameByID.Unlock()
	return mock.UserNameByIDFunc(ctx, userID)
}

// UserNameByIDCalls gets all the calls that were made to UserNameByID.
// Check the length with:
//
//	len(mockedLocator.UserNameByIDCalls())
func (mock *LocatorMock) UserNameByIDCalls() []struct {
	Ctx    context.Context
	UserID int64
} {
	var calls []struct {
		Ctx    context.Context
		UserID int64
	}
	mock.lockUserNameByID.RLock()
	calls = mock.calls.UserNameByID
	mock.lockUserNameByID.RUnlock()
	return calls
}

// ResetUserNameByIDCalls reset all the calls that were made to UserNameByID.
func (mock *LocatorMock) ResetUserNameByIDCalls() {
	mock.lockUserNameByID.Lock()
	mock.calls.UserNameByID = nil
	mock.lockUserNameByID.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *LocatorMock) ResetCalls() {
	mock.lockAddMessage.Lock()
	mock.calls.AddMessage = nil
	mock.lockAddMessage.Unlock()

	mock.lockAddSpam.Lock()
	mock.calls.AddSpam = nil
	mock.lockAddSpam.Unlock()

	mock.lockGetUserMessageIDs.Lock()
	mock.calls.GetUserMessageIDs = nil
	mock.lockGetUserMessageIDs.Unlock()

	mock.lockMessage.Lock()
	mock.calls.Message = nil
	mock.lockMessage.Unlock()

	mock.lockMsgHash.Lock()
	mock.calls.MsgHash = nil
	mock.lockMsgHash.Unlock()

	mock.lockSpam.Lock()
	mock.calls.Spam = nil
	mock.lockSpam.Unlock()

	mock.lockUserNameByID.Lock()
	mock.calls.UserNameByID = nil
	mock.lockUserNameByID.Unlock()
}
