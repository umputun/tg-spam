// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package webapi

import (
	"context"
	"github.com/umputun/tg-spam/app/config"
	"sync"
	"time"
)

// SettingsStoreMock is a mock implementation of SettingsStore.
//
//	func TestSomethingThatUsesSettingsStore(t *testing.T) {
//
//		// make and configure a mocked SettingsStore
//		mockedSettingsStore := &SettingsStoreMock{
//			DeleteFunc: func(ctx context.Context) error {
//				panic("mock out the Delete method")
//			},
//			ExistsFunc: func(ctx context.Context) (bool, error) {
//				panic("mock out the Exists method")
//			},
//			LastUpdatedFunc: func(ctx context.Context) (time.Time, error) {
//				panic("mock out the LastUpdated method")
//			},
//			LoadFunc: func(ctx context.Context) (*config.Settings, error) {
//				panic("mock out the Load method")
//			},
//			SaveFunc: func(ctx context.Context, settings *config.Settings) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedSettingsStore in code that requires SettingsStore
//		// and then make assertions.
//
//	}
type SettingsStoreMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context) error

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(ctx context.Context) (bool, error)

	// LastUpdatedFunc mocks the LastUpdated method.
	LastUpdatedFunc func(ctx context.Context) (time.Time, error)

	// LoadFunc mocks the Load method.
	LoadFunc func(ctx context.Context) (*config.Settings, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, settings *config.Settings) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LastUpdated holds details about calls to the LastUpdated method.
		LastUpdated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Load holds details about calls to the Load method.
		Load []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *config.Settings
		}
	}
	lockDelete      sync.RWMutex
	lockExists      sync.RWMutex
	lockLastUpdated sync.RWMutex
	lockLoad        sync.RWMutex
	lockSave        sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *SettingsStoreMock) Delete(ctx context.Context) error {
	if mock.DeleteFunc == nil {
		panic("SettingsStoreMock.DeleteFunc: method is nil but SettingsStore.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedSettingsStore.DeleteCalls())
func (mock *SettingsStoreMock) DeleteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// ResetDeleteCalls reset all the calls that were made to Delete.
func (mock *SettingsStoreMock) ResetDeleteCalls() {
	mock.lockDelete.Lock()
	mock.calls.Delete = nil
	mock.lockDelete.Unlock()
}

// Exists calls ExistsFunc.
func (mock *SettingsStoreMock) Exists(ctx context.Context) (bool, error) {
	if mock.ExistsFunc == nil {
		panic("SettingsStoreMock.ExistsFunc: method is nil but SettingsStore.Exists was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(ctx)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedSettingsStore.ExistsCalls())
func (mock *SettingsStoreMock) ExistsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// ResetExistsCalls reset all the calls that were made to Exists.
func (mock *SettingsStoreMock) ResetExistsCalls() {
	mock.lockExists.Lock()
	mock.calls.Exists = nil
	mock.lockExists.Unlock()
}

// LastUpdated calls LastUpdatedFunc.
func (mock *SettingsStoreMock) LastUpdated(ctx context.Context) (time.Time, error) {
	if mock.LastUpdatedFunc == nil {
		panic("SettingsStoreMock.LastUpdatedFunc: method is nil but SettingsStore.LastUpdated was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLastUpdated.Lock()
	mock.calls.LastUpdated = append(mock.calls.LastUpdated, callInfo)
	mock.lockLastUpdated.Unlock()
	return mock.LastUpdatedFunc(ctx)
}

// LastUpdatedCalls gets all the calls that were made to LastUpdated.
// Check the length with:
//
//	len(mockedSettingsStore.LastUpdatedCalls())
func (mock *SettingsStoreMock) LastUpdatedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLastUpdated.RLock()
	calls = mock.calls.LastUpdated
	mock.lockLastUpdated.RUnlock()
	return calls
}

// ResetLastUpdatedCalls reset all the calls that were made to LastUpdated.
func (mock *SettingsStoreMock) ResetLastUpdatedCalls() {
	mock.lockLastUpdated.Lock()
	mock.calls.LastUpdated = nil
	mock.lockLastUpdated.Unlock()
}

// Load calls LoadFunc.
func (mock *SettingsStoreMock) Load(ctx context.Context) (*config.Settings, error) {
	if mock.LoadFunc == nil {
		panic("SettingsStoreMock.LoadFunc: method is nil but SettingsStore.Load was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc(ctx)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//	len(mockedSettingsStore.LoadCalls())
func (mock *SettingsStoreMock) LoadCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}

// ResetLoadCalls reset all the calls that were made to Load.
func (mock *SettingsStoreMock) ResetLoadCalls() {
	mock.lockLoad.Lock()
	mock.calls.Load = nil
	mock.lockLoad.Unlock()
}

// Save calls SaveFunc.
func (mock *SettingsStoreMock) Save(ctx context.Context, settings *config.Settings) error {
	if mock.SaveFunc == nil {
		panic("SettingsStoreMock.SaveFunc: method is nil but SettingsStore.Save was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *config.Settings
	}{
		Ctx:      ctx,
		Settings: settings,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, settings)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedSettingsStore.SaveCalls())
func (mock *SettingsStoreMock) SaveCalls() []struct {
	Ctx      context.Context
	Settings *config.Settings
} {
	var calls []struct {
		Ctx      context.Context
		Settings *config.Settings
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// ResetSaveCalls reset all the calls that were made to Save.
func (mock *SettingsStoreMock) ResetSaveCalls() {
	mock.lockSave.Lock()
	mock.calls.Save = nil
	mock.lockSave.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SettingsStoreMock) ResetCalls() {
	mock.lockDelete.Lock()
	mock.calls.Delete = nil
	mock.lockDelete.Unlock()

	mock.lockExists.Lock()
	mock.calls.Exists = nil
	mock.lockExists.Unlock()

	mock.lockLastUpdated.Lock()
	mock.calls.LastUpdated = nil
	mock.lockLastUpdated.Unlock()

	mock.lockLoad.Lock()
	mock.calls.Load = nil
	mock.lockLoad.Unlock()

	mock.lockSave.Lock()
	mock.calls.Save = nil
	mock.lockSave.Unlock()
}
